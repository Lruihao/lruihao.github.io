[{"categories":["Grocery"],"content":"以下是常见的在线代码演示和开发环境服务，适合不同场景使用： 名称 特点与适用场景 网址 CodeSandbox 支持前后端全栈开发，内置 Docker，支持 React、Vue、Node、Python 等，适合复杂项目 https://codesandbox.io CodePen 专注于前端小效果演示，社区活跃，适合分享和展示 HTML/CSS/JS 片段 https://codepen.io JSFiddle 轻量级前端代码片段运行环境，适合快速测试和分享小 demo https://jsfiddle.net JS Bin 类似 JSFiddle，支持实时协作和分享，适合调试和教学 https://jsbin.com Playcode.io 无需登录即可运行 JS/TS，界面类似本地 IDE，适合快速原型开发 https://playcode.io Glitch 强调“可 remix”的项目协作，适合初学者和非开发者快速构建 Web 应用 https://glitch.com Replit 支持多语言（如 Python、Java、C++），适合教育用途和全栈开发 https://replit.com Gitpod 基于 VS Code 的云端 IDE，适合 GitHub 项目快速启动和协作 https://gitpod.io 码上掘金 国内版轻量 Playground，支持 React、Vue 等框架，适合中文用户 https://code.juejin.cn ","date":"2025-08-04","objectID":"/posts/code-playground/:0:0","tags":["Node.js","npm"],"title":"Code Playground","uri":"/posts/code-playground/"},{"categories":["GitHub"],"content":"Lruihao/caniuse embed element: A custom web component that embeds caniuse.com browser compatibility data for a specific feature.","date":"2025-07-22","objectID":"/projects/lruihao/caniuse-embed-element/","tags":["caniuse","caniuse-embed","custom-elements","web-components"],"title":"A custom web component that embeds caniuse.com browser compatibility data for a specific feature.","uri":"/projects/lruihao/caniuse-embed-element/"},{"categories":["GitHub"],"content":"\u003ccaniuse-embed\u003e Element A lightweight, customizable web component that embeds caniuse.com browser compatibility data for specific web features. Built with Lit and designed to seamlessly integrate into any web project. 🌟 Live Demo ✨ Features 🎯 Easy Integration: Drop-in web component that works with any framework or vanilla HTML 🎨 Theme Support: Auto, light, and dark themes that adapt to your design 📱 Responsive: Automatically adjusts height based on content ⚡ Lightweight: Built with Lit for minimal bundle size 🛠️ Customizable: Configure data source, time range, and appearance 🔒 Type Safe: Full TypeScript support with comprehensive type definitions 🚀 Quick Start CDN (Recommended) Add the script tag to your HTML: \u003cscript src=\"https://unpkg.com/@cell-x/caniuse-embed-element/dist/caniuse-embed-element.iife.js\"\u003e\u003c/script\u003e Then use the component: \u003ccaniuse-embed feature=\"css-grid\"\u003e\u003c/caniuse-embed\u003e NPM Installation npm install @cell-x/caniuse-embed-element import '@cell-x/caniuse-embed-element' 📖 Usage Examples Basic Usage \u003ccaniuse-embed feature=\"css-grid\"\u003e\u003c/caniuse-embed\u003e With Custom Configuration \u003ccaniuse-embed feature=\"flexbox\" theme=\"dark\" past=\"3\" future=\"2\" origin=\"https://caniuse.lruihao.cn\" \u003e\u003c/caniuse-embed\u003e Framework Integration Here’s an example using Vue.js. For more framework integration examples, see FRAMEWORK_INTEGRATION.md. \u003cscript setup\u003e import '@cell-x/caniuse-embed-element' \u003c/script\u003e \u003ctemplate\u003e \u003cdiv\u003e \u003ccaniuse-embed feature=\"css-grid\" theme=\"dark\" :past=\"3\" :future=\"2\" /\u003e \u003c/div\u003e \u003c/template\u003e ⚙️ API Reference Attributes/Properties Attribute Type Default Description feature string '' Required. The caniuse feature identifier (e.g., ‘css-grid’, ‘flexbox’) past 0 - 5 2 Number of past browser versions to display future 0 - 3 1 Number of future browser versions to display origin string 'https://caniuse.lruihao.cn' Base URL of the caniuse embed service theme 'auto' | 'light' | 'dark' 'auto' Color theme for the embedded content loading 'eager' | 'lazy' 'lazy' Loading strategy for the iframe (eager or lazy) meta string auto-generated Unique identifier for the embed instance Finding Feature Names Feature names correspond to the identifiers used on caniuse.com. You can find them in: The URL path: https://caniuse.com/css-grid → feature name is css-grid The search results on caniuse.lruihao.cn The caniuse-db repository Common Feature Examples css-grid - CSS Grid Layout flexbox - Flexible Box Layout arrow-functions - Arrow Functions webp - WebP Image Format css-variables - CSS Custom Properties async-functions - Async/Await Functions … CSS Classes .ciu-embed-iframe - The embedded iframe element .ciu-embed-empty - Empty state when no feature is specified 🌐 Browser Support This web component works in all modern browsers that support: Custom Elements v1 Shadow DOM v1 ES2015+ features 🔧 Development Prerequisites Node.js 20+ pnpm 10+ Setup # Clone the repository git clone https://github.com/Lruihao/caniuse-embed-element.git cd caniuse-embed-element # Install dependencies pnpm install # Start development server pnpm dev Build # Build all formats pnpm build:all # Build specific formats pnpm build:lib # ES modules and types pnpm build:iife # IIFE for CDN usage pnpm build # Demo build Scripts pnpm dev - Start development server pnpm build - Build demo pnpm build:lib - Build library (ES modules + types) pnpm build:iife - Build IIFE bundle for CDN pnpm build:all - Build all formats pnpm lint - Run ESLint pnpm preview - Preview built demo 📦 Distribution The package provides multiple build formats: ES Modules (dist/) - For modern bundlers IIFE Bundle (dist/caniuse-embed-element.iife.js) - For CDN usage TypeScript Definitions (dist/types/) - For TypeScript projects 🤝 Contributing Contributions are welcome! Please feel free to submit a Pull Request. For major changes, please open an issue first to discuss what you would like to change. Fork the repository Create your feature branch (git checkout -b feature/amazing-feature) Commit your changes (git co","date":"2025-07-22","objectID":"/projects/lruihao/caniuse-embed-element/:0:0","tags":["caniuse","caniuse-embed","custom-elements","web-components"],"title":"A custom web component that embeds caniuse.com browser compatibility data for a specific feature.","uri":"/projects/lruihao/caniuse-embed-element/"},{"categories":["CSS"],"content":"在现代前端开发中，CSS 的样式管理一直是一个令人头疼的问题。随着项目的不断扩展，样式规则的冲突、覆盖以及维护成本的增加，都给开发者带来了巨大的挑战。幸运的是，CSS 的 @layer 规则为我们提供了一种全新的解决方案，帮助我们更好地管理样式层级，提升代码的可维护性和可读性。本文将深入探讨 @layer 的背景、作用以及语法，带你一探究竟。 1 @layer 的背景 在 CSS 的发展历程中，样式的优先级规则一直是核心概念之一。默认情况下，CSS 样式按照选择器的优先级（如内联样式 \u003e ID 选择器 \u003e 类选择器 \u003e 元素选择器）以及代码的书写顺序来决定最终的样式效果。然而，这种简单的优先级规则在大型项目中常常会引发问题： 样式冲突：多个样式规则可能同时作用于同一个元素，导致样式冲突，开发者需要不断调整选择器的优先级来解决问题。 维护困难：随着项目的复杂度增加，样式文件变得庞大且难以维护。开发者很难快速定位和修改特定的样式规则。 组件化开发的挑战：在组件化开发中，不同组件的样式可能会相互干扰，导致样式管理混乱。 为了解决这些问题，CSS 工作组引入了 @layer 规则。@layer 允许开发者显式地定义样式的层级关系，从而更好地组织和管理样式规则。 2 @layer 的作用 2.1 定义样式层级 @layer 的核心作用是允许开发者显式地定义样式的层级关系。通过将样式规则分层，我们可以明确地控制样式的优先级顺序。例如，我们可以将基础样式定义在较低的层级，而将特定组件的样式定义在较高的层级，从而避免样式冲突。 @layer base { body { font-family: Arial, sans-serif; margin: 0; padding: 0; } } 2.2 提升代码可维护性 使用 @layer 可以让样式文件的结构更加清晰。开发者可以按照功能或模块将样式规则分层，便于后续的修改和扩展。同时，分层的样式规则也更容易被团队成员理解和协作。 2.3 支持组件化开发 在组件化开发中，@layer 可以帮助我们更好地隔离组件的样式。每个组件可以定义自己的样式层级，从而避免组件之间的样式相互干扰。这大大提升了组件的复用性和可维护性。 例如： @layer components { .cell-button { background-color: blue; color: white; padding: 10px; border: none; cursor: pointer; } } 在业务代码中，我们可以无视组件 CSS 的优先级，直接进行重置： .cell-button { background-color: red; /* 覆盖组件样式 */ } 眼见为实： 可以理解为 @layer 定义的层级会整体下降一个优先级，这样便于分开业务代码和组件代码的样式管理。 3 @layer 的语法 3.1 基本语法 @layer layer-name? {rules} @layer layer-name; @layer layer-name, layer-name, layer-name; 简而言之，@layer 规则可以用来定义一个样式层级或者改变现有层级的优先级。 @layer layer-name? {rules}; 这种形式用于定义一个新的样式层级，如果名称为空，则为匿名层级。 @layer 后接一个或多个层级名称，用于指定样式层级的优先级顺序，按照前后顺序。 3.2 让整个 CSS 文件变成 @layer 如果我们希望将整个 CSS 文件作为一个层级，可以使用以下语法： @import 中使用： @import (utilities.css) layer(utilities); \u003clink\u003e 元素引用 (*)： 警告 该用法有待考证，在 MDN 上尚未找到明确文档。 \u003clink rel=\"stylesheet\" href=\"utilities.css\" layer=\"utilities\"\u003e \u003c!-- 样式引入到一个匿名级联层中 --\u003e \u003clink rel=\"stylesheet\" href=\"utilities.css\" layer\u003e 3.3 嵌套层级 @layer 也支持嵌套定义，这使得我们可以在一个层级中进一步细分样式规则。例如： @layer base { @layer typography { h1 { font-size: 24px; } p { font-size: 16px; } } } 在嵌套层级中，外层层级的优先级低于内层层级。 多嵌套语法下的优先级： @layer A { p { color: red; } @layer B { p { color: green; } } } @layer C { p { color: orange; } @layer D { p { color: blue; } } } 其中的优先级大小是这样的：C \u003e C.D \u003e A \u003e A.B 另外，嵌套语法还支持使用级联写法简化。 例如，普通内外嵌套写法： @layer outer { button { width: 100px; height: 30px; } @layer inner { button { height: 40px; width: 160px; } } } 上面的内外嵌套语法还可以写成下面这样： @layer outer { button { width: 100px; height: 30px; } } @layer outer.inner { button { height: 40px; width: 160px; } } 4 @layer 的兼容性 5 参考 MDN Web Docs - @layer 详解日后定会大规模使用的 CSS @layer 规则 ","date":"2025-06-18","objectID":"/posts/at-layer/:0:0","tags":["CSS","@layer"],"title":"CSS @layer：构建更高效、更可维护的样式层级","uri":"/posts/at-layer/"},{"categories":["Vue.js"],"content":" 在使用 Vue.js 开发前端应用时，开启 history 模式可以让你的路由更加友好。然而，在部署应用时，需要正确配置 NGINX，以支持前端路由和 API 请求。本文将详细介绍如何配置 NGINX，使其能够处理 Vue 应用的 history 模式，并设置 API 代理。 1 前提条件 在开始之前，请确保你已经完成以下步骤： 安装并配置好 NGINX。 完成 Vue.js 应用的开发，并使用 npm run build 命令打包应用。 2 NGINX 配置示例 以下是一个典型的 NGINX 配置示例： server { listen 80; # 监听80端口 server_name your_domain.com; # 替换为你的域名 location / { root /path/to/your/dist; # 指向打包后的文件夹 try_files $uri $uri/ /index.html; # 尝试访问指定文件，如果找不到则重定向到index.html } # API 代理设置 location /api/ { proxy_pass http://your_api_server; # 替换为你的 API 服务器地址 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; } } 2.1 配置说明 listen: 指定 NGINX 监听的端口，通常是 80（HTTP）。 server_name: 配置你的域名。 root: 指向 Vue 应用的打包输出目录，通常是 dist 文件夹。 try_files: 尝试访问请求的文件，如果不存在，则返回 index.html，以允许 Vue Router 处理前端路由。 location /api/: 所有以 /api/ 开头的请求会被代理到指定的 API 服务器。 proxy_pass: 设置 API 请求转发到的后端服务器地址。 2.2 部署步骤 打包 Vue 应用： npm run build 上传内容：将 dist 文件夹的内容上传到服务器的指定路径。 修改 NGINX 配置：编辑 NGINX 配置文件，通常在 /etc/nginx/sites-available/default 或 /etc/nginx/nginx.conf。 检查配置：检查 NGINX 配置是否有语法错误： sudo nginx -t 重新加载 NGINX： sudo systemctl reload nginx 3 总结 通过上述配置，你的 Vue.js 应用将可以在 NGINX 上正常运行，并支持 history 模式的路由。同时，所有以 /api/ 开头的请求将被有效地代理到后端服务器。这样，前端与后端的交互就更加流畅自然。 希望这篇文章能帮助你顺利部署 Vue 应用！如有任何问题，欢迎留言讨论。 ","date":"2025-06-11","objectID":"/posts/vue-build/:0:0","tags":["nginx","Vue3","proxy"],"title":"Vue.js History 模式下的 NGINX 配置与 API 代理","uri":"/posts/vue-build/"},{"categories":["GitHub"],"content":"Lruihao/mmt webfont: The webfont package for the MMT typeface.","date":"2025-04-10","objectID":"/projects/lruihao/mmt-webfont/","tags":["cjk","mmt","vue3","webfont"],"title":"The webfont package for the MMT typeface.","uri":"/projects/lruihao/mmt-webfont/"},{"categories":["GitHub"],"content":"MMT webfont package The webfont package for the MMT typeface. Demo MMT typeface online demo Installation Browser The link embedding method can be used by web pages, mini-programs, and other platforms that support loading CSS styles. \u003clink rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/mmt-webfont/dist/result.css\"\u003e @import url('https://cdn.jsdelivr.net/npm/mmt-webfont/dist/result.css'); NPM To use the MMT webfont in your project, you can install it via npm: npm install mmt-webfont Then, you can import the CSS file in your project: import 'mmt-webfont/dist/result.css' Usage Restricted font usage area: article { font-family: 'MMT'; } ","date":"2025-04-10","objectID":"/projects/lruihao/mmt-webfont/:0:0","tags":["cjk","mmt","vue3","webfont"],"title":"The webfont package for the MMT typeface.","uri":"/projects/lruihao/mmt-webfont/"},{"categories":["GitHub"],"content":"Lruihao/vercel proxy: API proxies powered by Vercel.","date":"2025-04-09","objectID":"/projects/lruihao/vercel-proxy/","tags":["gravatar","vercel"],"title":"API proxies powered by Vercel.","uri":"/projects/lruihao/vercel-proxy/"},{"categories":["GitHub"],"content":"Vercel API Proxy API proxies powered by Vercel. [toc] Hosts https://api.lruihao.cn https://cell-api.vercel.app API List Go to the Vercel API Proxy and select the API you want to use. Gravatar API: /gravatar/avatar/(.*) Method: GET/POST Get the avatar of the email fee47a2f4f2cc71f99a02b0a73ecfee0 by Gravatar API. GET /gravatar/avatar/fee47a2f4f2cc71f99a02b0a73ecfee0 HTTP/1.1 Host: cell-api.vercel.app Google API: /gravatar/avatar/(.*) Method: * Get favicons by Google API. GET /google/s2/favicons?sz=64\u0026domain=lruihao.cn HTTP/1.1 Host: cell-api.vercel.app Netease Comment API: /netease/comment Method: GET/POST Request parameter: name Required type description type no string Type is text, returns text, is Json, returns Json by default id no int Specify the playlist id to get the hot reviews, default is NetEase Cloud Hot Songs List Request example: GET /netease/comment?mid=2280569152 HTTP/1.1 Host: cell-api.vercel.app Response example: { \"code\": 1, \"data\": { \"musicId\": 40915177, \"musicName\": \"父亲写的散文诗\", \"musicUrl\": \"http://music.163.com/song/media/outer/url?id=40915177\", \"artist\": \"许飞\", \"picUrl\": \"http://p1.music.126.net/h00CveXrABOfiWmFDLzRDg==/3405187515194971.jpg\", \"content\": \"一首歌 一万个人的故事\", \"nickname\": \"Gallianoo\", \"avatarUrl\": \"http://p2.music.126.net/3U7kD9M39sfkrPdWVvaGog==/109951163278309929.jpg\", \"likedCount\": 4743, \"time\": 1457059879799, \"timeStr\": \"2016-03-04\" } } ","date":"2025-04-09","objectID":"/projects/lruihao/vercel-proxy/:0:0","tags":["gravatar","vercel"],"title":"API proxies powered by Vercel.","uri":"/projects/lruihao/vercel-proxy/"},{"categories":["CSS"],"content":"本指南完整解释了弹性盒子（Flexible Box）的所有内容，重点介绍了父元素（弹性容器）和子元素（弹性项目）的所有不同可能属性。 提示 快速参考手册经常参考本指南？这里有一张你可以打印的高分辨率图像！免费下载。 背景 Flex 布局（弹性盒子）模块（截至 2017 年 10 月为 W3C 候选推荐）旨在提供一种更有效的方法来布局、对齐和分配容器中项目之间的空间，即使它们的大小未知和/或动态（因此有“弹性（flex）”一词）。 Flex 布局的主要思想是赋予容器调整其项目宽度/高度（和顺序）的能力，以最佳填充可用空间（主要是适应各种显示设备和屏幕尺寸）。一个弹性容器会扩展项目以填充可用的空闲空间，或缩小它们以防止溢出。 最重要的是，Flex 布局是方向无关的，与常规布局（块布局是基于垂直的，而行内布局是基于水平的）相比。虽然这些布局在页面上工作良好，但它们缺乏灵活性（不带双关意味）来支持大型或复杂的应用程序（特别是在方向变化、调整大小、拉伸、收缩等方面）。 注意 Flex 布局最适合应用程序的组件和小规模布局，而 网格布局（Grid） 则用于更大规模的布局。 基础知识和术语 由于 flexbox 是一个整体模块，而不是单个属性，因此它涉及很多内容，包括其整个属性集。其中一些属性应设置在容器（父元素，称为“弹性容器”）上，而其他属性应设置在子元素（称为“弹性项目”）上。 如果“常规”布局基于块和内联流方向，则弹性布局基于“弹性流方向”。请看规范中的这张图，它解释了弹性布局背后的主要思想。 弹性盒主轴上的尺寸称为主尺寸，另一个方向的尺寸称为横向尺寸。这些尺寸有主起点、主终点、横向起点和横向终点 项目将按照主轴（main axis）或横轴（cross axis）进行布局。 弹性容器（flex container） 包含弹性项目的父元素。 弹性项目（flex item） 弹性容器的子元素。 主轴（main axis） 弹性容器的主轴是弹性项目排列的主要轴。请注意，主轴不一定是水平的；这取决于属性 flex-direction（见下文）。 主轴起点（main-start） | 主轴终点（main-end） 弹性项目从主轴起点开始排列，直到主轴终点。 主轴尺寸（main size） 弹性项目的宽度或高度，取决于主轴的方向，是项目的主尺寸。弹性项目的主尺寸属性是主维度上的 width 或 height 属性。 横轴（cross axis） 与主轴垂直的轴称为横轴。其方向取决于主轴的方向。 横轴起点（cross-start） | 横轴终点（cross-end） 弹性行（flex line）填充项目并放置在容器中，从横轴起点开始，向横轴终点方向排列。 横轴尺寸（cross size） 弹性项目的宽度或高度，取决于横轴的方向，是项目的横尺寸。横尺寸属性是横向维度上的 width 或 height 属性。 弹性布局属性 父元素（弹性容器）的属性 display 这定义了一个弹性容器；根据给定的值，可以是内联或块级。这为其所有直接子元素启用弹性上下文。 .container { display: flex | inline-flex; } 请注意，CSS 列对弹性容器没有影响。 flex-direction 这建立了主轴，从而定义了弹性项目在弹性容器中放置的方向。Flexbox 是一个单向布局概念（除了可选的换行）。将弹性项目主要视为在水平行或垂直列中布局。 .container { flex-direction: row | row-reverse | column | column-reverse; } row（默认）：在 ltr 中从左到右；在 rtl 中从右到左 row-reverse：在 ltr 中从右到左；在 rtl 中从左到右 column：与 row 相同，但从上到下 column-reverse：与 row-reverse 相同，但从下到上 flex-wrap 默认情况下，所有弹性项目都将尝试适应一行。你可以更改此属性并允许项目根据需要换行。 .container { flex-wrap: nowrap | wrap | wrap-reverse; } nowrap（默认）：所有弹性项目都在一行上。 wrap：弹性项目将换行到多行，从上到下。 wrap-reverse：弹性项目将从下到上换行到多行。 flex-flow 这是 flex-direction 和 flex-wrap 属性的简写，它们共同定义了弹性容器的主轴和横轴。默认值是 row nowrap。 .container { flex-flow: column wrap; } justify-content 这定义了沿主轴的对齐方式。它有助于分配当所有弹性项目在一行上都不可调整大小或可调整大小但已达到最大尺寸时剩余的额外空间。它还对项目溢出行时的对齐方式施加了一些控制。 .container { justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right ... + safe | unsafe; } flex-start（默认）：项目向弹性方向的起点对齐。 flex-end：项目向弹性方向的终点对齐。 start：项目向 writing-mode 方向的起点对齐。 end：项目向 writing-mode 方向的终点对齐。 left：项目向容器的左边缘对齐，除非这与 flex-direction 不符，则表现为 start。 right：项目向容器的右边缘对齐，除非这与 flex-direction 不符，则表现为 end。 center：项目在行中居中对齐 space-between：项目在行中均匀分布；第一个项目在起始线，最后一个项目在终止线 space-around：项目在行中均匀分布，周围有相等的空间。请注意，视觉上这些空间并不相等，因为所有项目在两侧都有相等的空间。第一个项目在容器边缘有一个单位的空间，但下一个项目之间有两个单位的空间，因为下一个项目有自己的间距。 space-evenly：项目分布，使得任何两个项目之间的间距（以及到边缘的空间）相等。 请注意，这些值的浏览器支持是有差异的。例如，某些版本的 Edge 从未支持 space-between，而 start/end/left/right 尚未在 Chrome 中实现。MDN 有详细的图表。最安全的值是 flex-start、flex-end 和 center。 还有两个附加关键字可以与这些值配对：safe 和 unsafe。使用 safe 确保无论你如何进行这种类型的定位，都不会将元素推到屏幕外（例如，推到顶部）以至于内容无法滚动到（称为“数据丢失”）。 align-items 这定义了当前行上弹性项目沿横轴的默认布局行为。可以将其视为横轴（垂直于主轴）的 justify-content 版本。 .container { align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end + ... safe | unsafe; } stretch（默认）：拉伸以填充容器（仍然遵守最小宽度/最大宽度） flex-start / start / self-start：项目放置在横轴的起点。这些之间的区别很微妙，主要是关于遵守 flex-direction 规则或 writing-mode 规则。 flex-end / end / self-end：项目放置在横轴的终点。区别再次很微妙，主要是关于遵守 flex-direction 规则与 writing-mode 规则。 center：项目在横轴上居中对齐 baseline：项目对齐，使它们的基线对齐 safe 和 unsafe 修饰符关键字可以与所有这些关键字结合使用（尽管请注意浏览器支持），并帮助你防止对齐元素使内容变得不可访问。 align-content 这在横轴上有额外空间时对齐弹性容器的行，类似于 justify-content 在主轴上对齐单个项目。 警告 此属性仅在多行弹性容器上生效，其中 flex-wrap 设置为 wrap 或 wrap-reverse。单行弹性容器（即 flex-wrap 设置为其默认值 no-wrap）将不反映 align-content。 .container { align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch | start | end | baseline | first baseline | last baseline + ... safe | unsafe; } normal（默认）：项目按默认位置打包，仿佛未设置任何值。 flex-start / start：项目打包到容器的起点。（更多支持的）flex-start 遵守 flex-direction，而 start 遵守 writing-mode 方向。 flex-end / end：项目打包到容器的终点。（更多支持的）flex-end","date":"2025-01-20","objectID":"/posts/flexbox/:0:0","tags":["CSS","Flexbox"],"title":"CSS Flexbox 布局指南","uri":"/posts/flexbox/"},{"categories":["GitHub"],"content":"hugo fixit/action component list: Generate a list of all hugo-fixit theme components.","date":"2025-01-14","objectID":"/projects/hugo-fixit/action-component-list/","tags":["github-actions"],"title":"Generate a list of all hugo-fixit theme components.","uri":"/projects/hugo-fixit/action-component-list/"},{"categories":["GitHub"],"content":"action-component-list | FixIt This is a GitHub Action to generate a list of all hugo-fixit theme components. How to use You can reference different stable versions of this action. For more information, see Versioning in the GitHub Actions toolkit. To include the action in a workflow in another repository, you can use the uses syntax with the @ symbol to reference a specific branch, tag, or commit hash. Star this repository 😉 Go to your repository Add the following section to your README.md file, you can give whatever title you want. Just make sure that you use \u003c!-- HUGO_FIXIT_COMPONENTS:START --\u003e\u003c!-- HUGO_FIXIT_COMPONENTS:END --\u003e in your readme. The workflow will replace this comment with the actual blog post list: # Hugo FixIt Components \u003c!-- HUGO_FIXIT_COMPONENTS:START --\u003e \u003c!-- HUGO_FIXIT_COMPONENTS:END --\u003e Create a folder named .github and create a workflows folder inside it, if it doesn’t exist. Create a new file named fixit-component-list.yml with the following contents inside the workflows folder: name: Generate hugo-fixit component list on: schedule: # Run workflow automatically - cron: '0 0 * * *' # Runs every day at 00:00 UTC workflow_dispatch: # Run workflow manually (without waiting for the cron to be called), through the GitHub Actions Workflow page directly permissions: contents: write # To write the generated contents to the readme jobs: generate-component-list: name: Update this repo's README with the list of hugo-fixit theme components runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 - name: Generate hugo-fixit component list id: test-action uses: hugo-fixit/action-component-list@v1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} with: comment_tag_name: HUGO_FIXIT_COMPONENTS template: '- [{$repo.name}]({$repo.html_url}): {$repo.description}' - name: Print Output id: output run: echo \"${{ steps.test-action.outputs.repos }}\" - name: Commit changes uses: stefanzweifel/git-auto-commit-action@v5 with: commit_message: 'Docs: update hugo-fixit component list' commit_author: 'github-actions[bot] \u003cgithub-actions[bot]@users.noreply.github.com\u003e' Go to repository settings, Click on Actions \u003e General. Update the “Workflow permissions” to “Read and write permissions”. Click on save. Wait for it to run automatically, or you can also trigger it manually to see the result instantly. Inputs Name Description Default comment_tag_name The tag name to look for in the readme file HUGO_FIXIT_COMPONENTS readme_path Comma separated paths of the readme files you want to update ./README.md exclude_repos Comma separated list of repos to exclude from the list template Template to use while creating the list of hugo-fixit theme components. It can contain {$repo.name} etc. as variables - [{$repo.name}]({$repo.html_url}): {$repo.description} Outputs Name Description repos The list of hugo-fixit theme components repos that were updated. Example Insert the following code block in your Markdown file to display the list of hugo-fixit components. The list of hugo-fixit components will be displayed here. \u003c!-- HUGO_FIXIT_COMPONENTS:START --\u003e \u003c!-- HUGO_FIXIT_COMPONENTS:END --\u003e The list of hugo-fixit components will be displayed here. fixit-bundle 🌲 Bundles the FixIt core theme and all hugo-fixit components into a single component. cmpt-flyfish 🐟 A canvas implemented animation effect of small fish swimming. cmpt-mdevtools Mobile devtools component powered by vConsole and eruda. cmpt-translate 🌐 A component for site automatic translation. component-projects 🐙 Display your GitHub projects in the FixIt theme and generate blog posts from readme. hugo-atom-feed Hugo theme component for ATOM feed custom Output Format. hugo-json-feed Hugo theme component for JSON feed custom Output Format. shortcode-asciinema A Hugo theme component with asciinema-embed shortcode. shortcode-caniuse A Hugo theme component with caniuse shortcode. shortcode-docs-bookmark 🔖 Embed bookmark of FixIt Docs. shortcode-missing-translation A Hugo theme component wi","date":"2025-01-14","objectID":"/projects/hugo-fixit/action-component-list/:0:0","tags":["github-actions"],"title":"Generate a list of all hugo-fixit theme components.","uri":"/projects/hugo-fixit/action-component-list/"},{"categories":["GitHub"],"content":"hugo fixit/shortcode asciinema: A Hugo theme component with asciinema-embed shortcode.","date":"2025-01-08","objectID":"/projects/hugo-fixit/shortcode-asciinema/","tags":["asciinema","hugo","shortcodes","theme-component"],"title":"A Hugo theme component with asciinema-embed shortcode.","uri":"/projects/hugo-fixit/shortcode-asciinema/"},{"categories":["GitHub"],"content":" shortcode-asciinema | FixIt 一个带有 asciinema-embed shortcode 的 Hugo 主题组件。 简体中文 | 繁體中文 | English | Français | Русский язык | Español | हिन्दी | deutsch | 한국어 | しろうと Demo 安装主题#CLI | FixIt 要求 适用于所有 Hugo 主题。 安装组件 安装方式与 安装主题 相同，有多种安装方式，任选一种即可，这里介绍两种主流方式。 作为 Hugo 模块安装 首先确保你的项目本身是一个 Hugo 模块。 然后将此主题组件添加到你的 hugo.toml 配置文件中： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" [[module.imports]] path = \"github.com/hugo-fixit/shortcode-asciinema\" 在 Hugo 的第一次启动时，它将下载所需的文件。 要更新到模块的最新版本，请运行： hugo mod get -u hugo mod tidy 作为 Git 子模块安装 将 FixIt 和此 git 存储库克隆到你的主题文件夹中，并将其作为网站目录的子模块添加。 git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt git submodule add https://github.com/hugo-fixit/shortcode-asciinema.git themes/shortcode-asciinema 接下来编辑项目的 hugo.toml 并将此主题组件添加到你的主题中： theme = [\"FixIt\", \"shortcode-asciinema\"] 记录终端 你可以使用 asciinema 命令记录终端并将其上传到 asciinema.org。 asciinema rec demo.cast # press \u003cctrl-d\u003e or type \"exit\" when you're done asciinema upload demo.cast 使用 Shortcode 以下是一个使用示例： {{\u003c asciinema-embed 697494 \u003e}} 呈现效果如下： 参考 开发主题组件 | FixIt 如何开发 Hugo 主题组件 | FixIt ","date":"2025-01-08","objectID":"/projects/hugo-fixit/shortcode-asciinema/:0:0","tags":["asciinema","hugo","shortcodes","theme-component"],"title":"A Hugo theme component with asciinema-embed shortcode.","uri":"/projects/hugo-fixit/shortcode-asciinema/"},{"categories":["CSS"],"content":"在这篇文章中，我们将探讨如何使用 CSS 获取视口尺寸，并展示一个简单的实现示例。 1 效果 调整浏览器窗口大小，你会发现视口的宽度和高度会实时更新（旧浏览器可能不支持）。 重要的是，这个效果是纯 CSS 实现的，不需要 JavaScript，真的震惊了！ 2 实现原理 定义 CSS 自定义属性（@property） --vw 和 --vh，分别表示视口的宽度和高度。 使用 tan() 和 atan2() 函数计算视口的宽度和高度。 使用 counter 和 counter-reset 属性将计算结果显示在页面上。 2.1 计算视口尺寸 我们可以使用 vw 和 vh 获取浏览器视口尺寸，但是这是相对单位，所以需要转换为 px 才行。我们先利用自定义属性把相对单位转成 px，然后最关键的一步是巧妙地利用了三角函数 $tan(arctan(a)) = a$ 来实现这个转换。 2.2 三角函数 在三角函数中，$tan(θ)$ 表示一个角度 $θ$ 的正切值，它等于对边（opposite）与邻边（adjacent）的比值。反过来，$arctan(a)$ 表示一个数值 $a$ 的反正切值，它返回一个角度 $θ$，使得 $tan(θ) = a$，因此得到公式： $$ tan(arctan(a)) = a $$ CSS 中的 tan() 和 atan2() 函数可以用来计算正切值和反正切值。 tan() 函数的语法如下： /* 单个 \u003cangle\u003e 值 */ width: calc(100px * tan(45deg)); width: calc(100px * tan(0.125turn)); width: calc(100px * tan(0.785398163rad)); /* 单个 \u003cnumber\u003e 值 */ width: calc(100px * tan(0.5773502)); width: calc(100px * tan(1.732 – 1)); /* 其他值 */ width: calc(100px * tan(pi / 3)); width: calc(100px * tan(e)); atan2() 函数接受两个参数，对于所给两值 x 和 y，函数 atan2(y, x) 计算并返回正半横轴与从原点到点 (x, y) 的射线的夹角。函数的语法如下： /* 两个 \u003cnumber\u003e 值 */ transform: rotate(atan2(3, 2)); /* 两个 \u003cdimension\u003e 值 */ transform: rotate(atan2(1rem, -0.5rem)); /* 两个 \u003cpercentage\u003e 值 */ transform: rotate(atan2(20%, -30%)); /* 其他值 */ transform: rotate(atan2(pi, 45)); transform: rotate(atan2(e, 30)); 3 代码示例 以下是完整的 HTML 和 CSS 代码，你也可以在我的 html-demo 中查看。 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eCSS Viewport Size\u003c/title\u003e \u003cstyle\u003e /* 自定义属性是为了把 vw 和 vh 转成 px */ @property --vw { syntax: '\u003clength\u003e'; inherits: true; initial-value: 100vw; } @property --vh { syntax: '\u003clength\u003e'; inherits: true; initial-value: 100vh; } /* 核心公式： tan(θ) = opposite / adjacent θ = arctan(opposite / adjacent) tan(arctan(a)) = a */ :root { --width: tan(atan2(var(--vw), 1px)); --height: tan(atan2(var(--vh), 1px)); } body::before { content: counter(width) ' X ' counter(height); counter-reset: width var(--width) height var(--height); display: block; font-size: 150px; font-weight: 900; position: fixed; width: fit-content; height: fit-content; inset: 0; margin: auto; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 4 兼容性 主要是 counter 和 counter-reset 属性的兼容性问题，看漫山红遍，层林尽染。 ","date":"2024-12-06","objectID":"/posts/css-viewport/:0:0","tags":["CSS"],"title":"震惊！CSS 竟然能获取视口尺寸？","uri":"/posts/css-viewport/"},{"categories":["GitHub"],"content":"hugo fixit/cmpt translate: 🌐 A component for site automatic translation.","date":"2024-12-02","objectID":"/projects/hugo-fixit/cmpt-translate/","tags":["hugo","hugo-fixit","i18n","theme-component","translatejs"],"title":"🌐 A component for site automatic translation.","uri":"/projects/hugo-fixit/cmpt-translate/"},{"categories":["GitHub"],"content":" Auto Translate | FixIt 一个基于 translate.js 实现网站自动翻译的组件。 简体中文 | 繁體中文 | English | Français | Русский язык | Español | हिन्दी | deutsch | 한국어 | しろうと Demo 无论原站点是多语言还是单语言，都可以通过此组件额外增加自动翻译功能。 多语言 Hugo 站点：fixit.lruihao.cn 单语言 Hugo 站点：lruihao.cn 在网站右上角切换配置的翻译语言，或者在 URL 中添加 ?lang= 参数指定任意支持的翻译语言。例如：?lang=korean。 特性 每日翻译字符 200 万！ 无语言配置文件、无 API Key、对 SEO 友好！ 支持整页自动翻译 支持指定翻译语言 支持可选翻译服务 支持忽略翻译元素 支持忽略选择器 支持忽略关键词翻译 支持检测本地语言 支持自定义翻译术语 支持 CDN 支持企业级翻译通道 * 要求 Hugo v0.146.0 或更高版本。 FixIt v0.4.0 或更高版本。 安装组件 安装方式与 安装主题 相同，有多种安装方式，任选一种即可，这里介绍两种主流方式。 作为 Hugo 模块安装 首先确保你的项目本身是一个 Hugo 模块。 然后将此主题组件添加到你的 hugo.toml 配置文件中： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" [[module.imports]] path = \"github.com/hugo-fixit/cmpt-translate\" 在 Hugo 的第一次启动时，它将下载所需的文件。 要更新到模块的最新版本，请运行： hugo mod get -u hugo mod tidy 作为 Git 子模块安装 将 FixIt 和此 git 存储库克隆到你的主题文件夹中，并将其作为网站目录的子模块添加。 git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt git submodule add https://github.com/hugo-fixit/cmpt-translate.git themes/cmpt-translate 接下来编辑项目的 hugo.toml 并将此主题组件添加到你的主题中： theme = [ \"FixIt\", \"cmpt-translate\" ] 配置 为了通过 FixIt 主题在 layouts/_partials/custom.html 文件中开放的 自定义块 将 cmpt-translate.html 注入到 custom-assets 中，你需要填写以下必要配置： [params] [params.customPartials] head = [] menuDesktop = [ \"inject/translate-menu-desktop.html\", ] menuMobile = [ \"inject/translate-menu-mobile.html\", ] profile = [] aside = [] comment = [] footer = [] widgets = [] assets = [ \"inject/cmpt-translate.html\", ] postFooterBefore = [] postFooterAfter = [] 另外，你还可以通过以下配置来自定义翻译的语言： [languages] [languages.zh-cn] languageCode = \"zh-CN\" languageName = \"简体中文\" [params] [params.autoTranslate] enable = true service = 'client.edge' languages = [] ignoreID = [] ignoreClass = [] ignoreTag = [] detectLocalLanguage = false cdn = \"\" enterprise = false enable：是否启用自动翻译。 service：翻译服务提供商，可选值为 client.edge 和 translate.service，详见：翻译服务提供商。 languages：要翻译到的语言 ID 列表，例如 [\"english\", \"chinese_simplified\", \"chinese_traditional\", ...]，详见：完整语言列表。 ignoreID：需要忽略翻译的元素 ID，例如 [\"comment\", ...]。 ignoreClass：需要忽略翻译的类名，例如 [\"post-category\", ...]。 ignoreTag：需要忽略翻译的标签，例如 [\"title\", ...]。 ignoreText：需要忽略翻译的文本，例如 [\"FixIt\", \"Lruihao\", ...]。 detectLocalLanguage：是否检测本地语言。 cdn：translate.js 的 CDN，例如 https://cdn.jsdelivr.net/npm/i18n-jsautotranslate@latest。 enterprise：是否启用企业级翻译通道。 注意 为了避免翻译语言获取失败，即使你的站点本身是单语言的，也需要配置 languageCode 和 languageName，例如： [languages] [languages.zh-cn] languageCode = \"zh-CN\" languageName = \"简体中文\" Front Matter autoTranslate: local: '' fromLanguages: [] onlyLocalLang: false local: String 用于指定当前页面的本地语言，例如 local: english。 默认本地语言同 Hugo 站点配置相同，如果某个页面实际语言与站点配置不同，可以通过 local 参数指定。 fromLanguages: Array 类型，用于指定当前页面内容中出现的语种是否需要翻译。 例如：网页本身是中文，但是内容中还有其他语言，你可以指定需要翻译的语种，例如： fromLanguages: - chinese_simplified - chinese_traditional onlyLocalLang: Boolean 类型，用于指定是否只翻译当前页面本地语言，默认为 false。 例如：网页本身是中文，但是内容中其他语言的摘要引用，设置 onlyLocalLang: true 可以只翻译中文。 自定义翻译术语 在你的项目目录 data 文件夹下创建 nomenclature.yml 文件，然后添加自定义翻译术语，例如： - from: english to: chinese_simplified properties: Hello: 你好 World: 世界 - from: english to: french properties: Hello: Bonjour World: Monde 企业级翻译通道 企业级稳定翻译通道，仅针对付费用户开放。 体验额度：每天有 5 万字符的体验额度，超出部分将不再翻译！ 在 FixIt 里启用企业级翻译通道，设置 params.autoTranslate.enterprise 为 true 即可，企业级翻译通道相对于普通翻译通道有以下优势： 服务 开源翻译通道 企业级翻译通道 服务端缓存层数 1 层 (文件式缓存) 1 层 (内存 + 文件式缓存) 翻译响应速度 1.5~5 秒 0.8~1.5 秒 翻译服务器 1 台 \u003e=3 台 网络节点 2 个 \u003e=4 个 翻译通道 手动设置 自动匹配最优 国内缓存节点 无 有 每日翻译字符 200 万 5000 万 赞助费用 考虑到 FixIt 生态受众群体大多为个人用户，因此我（@Lruihao）以个人名义拿出赞助收入进行补贴。 提示 FixIt 项目补贴价：¥10 ¥50 / 域名 / 月 到期自动禁用，需要重新赞助续费！ 符合以下性质的可以免费联系我开通企业级翻译通道： translate.js 及相关生态产品的开发者 FixIt 及相关生态产品的开发者 另外，Hugo FixIt 星球 成员每人补贴赠送 6 个月服务 / 年。 赞助方式 微信支付 支付宝 选择赞助金额，然后在留言中备注 AutoTranslate: 你的域名 即可。 通过以下方式联系作者： 邮箱：1024#lruihao.cn (将 # 替换为 @) 微信：关注公众号回复“Cell”获取作者微信 致谢 translate.js 提供技术支持和赞助企业级翻译通道。 ","date":"2024-12-02","objectID":"/projects/hugo-fixit/cmpt-translate/:0:0","tags":["hugo","hugo-fixit","i18n","theme-component","translatejs"],"title":"🌐 A component for site automatic translation.","uri":"/projects/hugo-fixit/cmpt-translate/"},{"categories":["GitHub"],"content":"hugo fixit/cmpt flyfish: 🐟 A canvas implemented animation effect of small fish swimming.","date":"2024-11-05","objectID":"/projects/hugo-fixit/cmpt-flyfish/","tags":["canvas","hugo","hugo-fixit","theme-component"],"title":"🐟 A canvas implemented animation effect of small fish swimming.","uri":"/projects/hugo-fixit/cmpt-flyfish/"},{"categories":["GitHub"],"content":"Fly Fish 👉 简体中文说明 | English README 一个 canvas 实现的小鱼游动动画效果。 Demo https://lruihao.cn 要求 FixIt v0.4.0 或更高版本。 安装组件 安装方法与 安装主题 相同。有几种安装方式，请选择一种，例如，通过 Hugo 模块安装： 作为 Hugo 模块安装 首先确保你的项目本身是一个 Hugo 模块。 然后将此主题组件添加到你的 hugo.toml 配置文件中： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" [[module.imports]] path = \"github.com/hugo-fixit/cmpt-flyfish\" 在 Hugo 的第一次启动时，它将下载所需的文件。 要更新到模块的最新版本，请运行： hugo mod get -u hugo mod tidy 作为 Git 子模块安装 将 FixIt 和此 git 存储库克隆到你的主题文件夹中，并将其作为网站目录的子模块添加。 git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt git submodule add https://github.com/hugo-fixit/cmpt-flyfish.git themes/cmpt-flyfish 接下来编辑项目的 hugo.toml 并将此主题组件添加到你的主题中： theme = [\"FixIt\", \"cmpt-flyfish\"] 配置 为了通过 FixIt 主题在 layouts/_partials/custom.html 文件中开放的 自定义块 将 cmpt-flyfish.html 注入到 custom-assets 中，你需要填写以下必要配置： [params] [params.customPartials] # ... other partials assets = [ \"inject/cmpt-flyfish.html\" ] # ... other partials 配置小鱼主题色，并启用动画： [params] [params.flyfish] enable = true light = \"rgb(0 119 190 / 10%)\" dark = \"rgb(255 255 255 / 10%)\" 参考 开发主题组件 | FixIt 如何开发 Hugo 主题组件 | FixIt ","date":"2024-11-05","objectID":"/projects/hugo-fixit/cmpt-flyfish/:0:0","tags":["canvas","hugo","hugo-fixit","theme-component"],"title":"🐟 A canvas implemented animation effect of small fish swimming.","uri":"/projects/hugo-fixit/cmpt-flyfish/"},{"categories":["Memo"],"content":"在这个博客中，我经常会写一些关于开源项目的文章，而这些开源项目通常都是托管在 GitHub 上的。为了方便内容同步，我希望能够自动获取 GitHub 仓库的 README 内容，然后添加到 Hugo 文章中。这样，我就不用再手动复制粘贴 README 内容了。 17 前言 这个愿景我想了很久了，但是用 JS 通过 GitHub API 获取 README 内容的实现方式体验并不好，所以我一直没有实现。直到最近，我发现了 Hugo v0.126.0 版本新增了一个内容适配器（Content adapters）的概念。 Create content adapters to dynamically add content when building your site. 也就是说，我们可以在构建 Hugo 站点时，通过自定义的适配器动态添加内容。理论可行，实践开始。 18 GitHub API 首先，我们需要找到 GitHub API 获取 README 内容的接口。懒得翻文档了，直接浏览器打开 https://api.github.com，在 API 列表中最终找到了获取 README 内容的接口： GET /repos/{owner}/{repo}/readme HTTP/1.1 Host: api.github.com Authorization: token {your_token} 有些仓库会有多种语言的 README，还需要获取指定语言的 README 内容： GET /repos/{owner}/{repo}/contents/README.{lang}.md HTTP/1.1 Host: api.github.com Authorization: token {your_token} 另外，GitHub API 有访问频率限制，需要在请求头中添加 Authorization 字段，值为 token {your_token}。1 19 Content Adapters 在项目文件夹中创建 _content.gotmpl，添加以下代码： {{- partial \"adapters/projects.html\" . -}} 目录结构如下： content/ ├── projects/ │ ├── _content.gotmpl \u003c-- content adapter │ └── _index.md \u003c-- layout: projects data/ └── projects.yml \u003c-- projects data 然后，打开 hugo.toml 文件，配置的 projectsAdapters 选项，启用内容适配器： [params] [params.projectsAdapters] enable = true onlyPublic = true categories = [] collections = [] ignoreList = [] 好了，现在准备工作都做完了，剩下要做的就是实现 adapters/projects.html 就好了。 思路： 遍历 data/projects.yml 中的项目数据 通过 GitHub API 获取 README 内容 README 解析为 Markdown 格式，并处理图片链接，部分字符转义 将 README 内容添加到 Hugo 文章中 具体的源码实现可以查看 component-projects 主题组件。 20 实现效果 我的开源 Theme Components ｜ FixIt 点击跳到 GitHub 生成 token，选择名为 public_repo 的范围以生成个人访问令牌。 ↩︎ ","date":"2024-10-06","objectID":"/posts/content-adapters/:0:0","tags":["hugo","GitHub API"],"title":"自动获取 GitHub README 内容添加到 Hugo 文章","uri":"/posts/content-adapters/"},{"categories":["GitHub"],"content":"Lruihao/html demo: 不使用任何框架，只使用原生 HTML、CSS 和 JavaScript 的一些小 demo。","date":"2024-09-13","objectID":"/projects/lruihao/html-demo/","tags":["html-css-javascript"],"title":"不使用任何框架，只使用原生 HTML、CSS 和 JavaScript 的一些小 demo。","uri":"/projects/lruihao/html-demo/"},{"categories":["GitHub"],"content":"HTML demos 不使用任何框架，只使用原生 HTML、CSS 和 JavaScript 的一些小 demo。 文件预览 直接浏览器打开 src 目录下的 HTML 文件。 serve 预览 yarn yarn serve 然后访问 http://localhost:3000。 ","date":"2024-09-13","objectID":"/projects/lruihao/html-demo/:0:0","tags":["html-css-javascript"],"title":"不使用任何框架，只使用原生 HTML、CSS 和 JavaScript 的一些小 demo。","uri":"/projects/lruihao/html-demo/"},{"categories":["GitHub"],"content":"hugo fixit/fixit releaser: ⚙️ Versioning, change-log and release.","date":"2024-09-04","objectID":"/projects/hugo-fixit/fixit-releaser/","tags":["auto-changelog","changelog","hugo-fixit","nodejs","semver"],"title":"⚙️ Versioning, change-log and release.","uri":"/projects/hugo-fixit/fixit-releaser/"},{"categories":["GitHub"],"content":"FixIt Releaser 中文 | English 版本控制、变更日志和发布工具，适用于 Hugo FixIt 的类似提交风格。 功能 更新 FixIt 内部版本号。(仅适用于 FixIt) 自动生成变更日志。（由 auto-changelog 提供支持） 安装 包管理器 命令 pnpm pnpm add -D @hugo-fixit/fixit-releaser yarn yarn add -D @hugo-fixit/fixit-releaser npm npm i -D @hugo-fixit/fixit-releaser 配置 在 FixIt 项目的 package.json 中添加以下内容。 { \"scripts\": { \"version\": \"fixit-releaser version --prod\", \"release\": \"fixit-releaser changelog\" } } fixit-releaser changelog 配置与 auto-changelog 兼容。 使用方法 版本 将 FixIt 版本从 v0.3.12-1ca9fdb7 更新到 v0.3.12。 npx fixit-releaser version --prod 将 FixIt 版本从 v0.3.12-1ca9fdb7 更新到 v0.3.12-2ca9fdb7。 npx fixit-releaser version --dev 变更日志 从 v0.3.10 生成变更日志。 npx fixit-releaser changelog --starting-version v0.3.10 # auto-changelog: 6 kB written to CHANGELOG.md 更多用法请参见 auto-changelog。 ","date":"2024-09-04","objectID":"/projects/hugo-fixit/fixit-releaser/:0:0","tags":["auto-changelog","changelog","hugo-fixit","nodejs","semver"],"title":"⚙️ Versioning, change-log and release.","uri":"/projects/hugo-fixit/fixit-releaser/"},{"categories":["GitHub"],"content":"hugo fixit/hugo atom feed: Hugo theme component for ATOM feed custom Output Format.","date":"2024-08-22","objectID":"/projects/hugo-fixit/hugo-atom-feed/","tags":["atom","feed","hugo","theme-component"],"title":"Hugo theme component for ATOM feed custom Output Format.","uri":"/projects/hugo-fixit/hugo-atom-feed/"},{"categories":["GitHub"],"content":"Hugo ATOM Feed 中文 | English Hugo 主题组件，用于自定义 ATOM feed 输出格式。 该组件为您的站点启用 ATOM feeds。 安装组件 安装方法与安装主题相同。有几种安装方式，选择一种，例如通过 Hugo Modules 安装： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" + [[module.imports]] + path = \"github.com/hugo-fixit/hugo-atom-feed\" 配置 将 “atom” 添加到您希望创建 ATOM feeds 的所有页面类型中： [outputs] # \u003cbaseURL\u003e/atom.xml home = [\"html\", \"rss\", \"atom\"] # \u003cbaseURL\u003e/posts/atom.xml 等 section = [\"html\", \"rss\", \"atom\"] # \u003cbaseURL\u003e/tags/foo/atom.xml 等 term = [\"html\", \"rss\", \"atom\"] 如果您的站点使用多个主题组件，则需要合并所有主题组件的 outputs 配置。例如，如果您的站点同时使用 FixIt 和 hugo-atom-feed 主题组件，则需要合并两个主题组件的 outputs 配置： [outputs] _merge = \"shallow\" home = [\"html\", \"rss\", \"atom\", \"archives\", \"offline\", \"readme\", \"baidu_urls\", \"search\"] page = [\"html\", \"markdown\"] section = [\"html\", \"rss\", \"atom\"] taxonomy = [\"html\"] term = [\"html\", \"rss\", \"atom\"] 参数 您可以在站点配置文件中设置以下参数： [params] # 全局 ATOM feed 配置 [params.feed] # feed 中包含的文章数量。如果设置为 -1，则包含所有文章。 limit = 10 # 是否在 feed 中显示全文。 fullText = true # 分类页面配置（分类中的所有页面） [params.section] # 分类页面的 ATOM feed 配置 [params.section.feed] # feed 中包含的文章数量。如果设置为 -1，则包含所有文章。 limit = -1 # 是否在 feed 中显示全文。 fullText = false # 标签列表（分类或标签）页面配置 [params.list] # 标签列表的 ATOM feed 配置 [params.list.feed] # feed 中包含的文章数量。如果设置为 -1，则包含所有文章。 limit = -1 # 是否在 feed 中显示全文。 fullText = false Front matter 您可以在内容文件的 front matter 中设置以下参数： --- title: \"Hello World\" date: 2024-08-24T16:06:33+08:00 hiddenFromFeed: true feed: # feed.limit 仅在分类或标签页面（_index.md）中有效。 limit: 10 fullText: true --- ","date":"2024-08-22","objectID":"/projects/hugo-fixit/hugo-atom-feed/:0:0","tags":["atom","feed","hugo","theme-component"],"title":"Hugo theme component for ATOM feed custom Output Format.","uri":"/projects/hugo-fixit/hugo-atom-feed/"},{"categories":["GitHub"],"content":"hugo fixit/hugo json feed: Hugo theme component for JSON feed custom Output Format.","date":"2024-08-22","objectID":"/projects/hugo-fixit/hugo-json-feed/","tags":["hugo","json-feed","theme-component"],"title":"Hugo theme component for JSON feed custom Output Format.","uri":"/projects/hugo-fixit/hugo-json-feed/"},{"categories":["GitHub"],"content":"Hugo JSON Feed 中文 | English Hugo 主题组件，用于自定义 JSON feed 输出格式。 该组件为您的站点启用 JSON feeds。 演示 主页 Feed 文章 Feed 列表 Feed 安装组件 安装方法与安装主题相同。有几种安装方式，选择一种，例如通过 Hugo Modules 安装： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" + [[module.imports]] + path = \"github.com/hugo-fixit/hugo-json-feed\" 配置 将 “jsonfeed” 添加到您希望创建 JSON feeds 的所有页面类型中： [outputs] # \u003cbaseURL\u003e/feed.json home = [\"html\", \"rss\", \"jsonfeed\"] # \u003cbaseURL\u003e/posts/feed.json 等 section = [\"html\", \"rss\", \"jsonfeed\"] # \u003cbaseURL\u003e/tags/foo/feed.json 等 term = [\"html\", \"rss\", \"jsonfeed\"] 如果您的站点使用多个主题组件，则需要合并所有主题组件的 outputs 配置。例如，如果您的站点同时使用 FixIt 和 hugo-json-feed 主题组件，则需要合并两个主题组件的 outputs 配置： [outputs] _merge = \"shallow\" home = [\"html\", \"rss\", \"jsonfeed\", \"archives\", \"offline\", \"readme\", \"baidu_urls\", \"search\"] page = [\"html\", \"markdown\"] section = [\"html\", \"rss\", \"jsonfeed\"] taxonomy = [\"html\"] term = [\"html\", \"rss\", \"jsonfeed\"] 参数 您可以在站点配置文件中设置以下参数： [params] # 全局 JSON feed 配置 [params.feed] # feed 中包含的文章数量。如果设置为 -1，则包含所有文章。 limit = 10 # 是否在 feed 中显示全文。 fullText = true # 分类页面配置（分类中的所有页面） [params.section] # 分类页面的 JSON feed 配置 [params.section.feed] # feed 中包含的文章数量。如果设置为 -1，则包含所有文章。 limit = -1 # 是否在 feed 中显示全文。 fullText = false # 标签列表（分类或标签）页面配置 [params.list] # 标签列表的 JSON feed 配置 [params.list.feed] # feed 中包含的文章数量。如果设置为 -1，则包含所有文章。 limit = -1 # 是否在 feed 中显示全文。 fullText = false Front matter 您可以在内容文件的 front matter 中设置以下参数： --- title: \"Hello World\" date: 2024-08-24T16:06:33+08:00 hiddenFromFeed: true feed: # feed.limit 仅在分类或标签页面（_index.md）中有效。 limit: 10 fullText: true --- ","date":"2024-08-22","objectID":"/projects/hugo-fixit/hugo-json-feed/:0:0","tags":["hugo","json-feed","theme-component"],"title":"Hugo theme component for JSON feed custom Output Format.","uri":"/projects/hugo-fixit/hugo-json-feed/"},{"categories":null,"content":"本页面记录了自「菠菜眾長」博客创建以来，所有的打赏记录。感谢大家的支持！","date":"2024-08-16","objectID":"/reward/","tags":null,"title":"赞赏记录","uri":"/reward/"},{"categories":null,"content":" 如果我或者我的开源帮助到了你，请考虑给我买杯咖啡，谢谢！ 打赏时可以给我留言，以便于我记录一下，FixIt 相关的记录，不再重复记录在本页，传送门。 给博主买杯卡布奇诺～ 赞赏 支付宝 微信 本页面记录了自「菠菜眾長」博客创建以来，所有的打赏记录。感谢大家的支持！❤️ 总计 ¥403.32 单笔最大 🏆 王二愣子 的 ¥66.00 francs ¥67.60 王二愣子 ¥66.00 K*n ¥50.00 Z 通过 微信 打赏了 ¥20.00 备注：感谢作者的答疑解惑😋 2024-11-16 18:27:58王二愣子 通过 微信 打赏了 ¥66.00 备注：感谢大佬的答疑解惑！ 2024-11-06 11:22:04deequoique 通过 微信 打赏了 ¥10.00 备注：FixIt👍请佬喝杯蜜雪 2024-09-10 18:51:27SuLis 通过 微信 打赏了 ¥10.00 备注：感谢作者对 FixIt 的付出！ 2024-08-03 19:25:50WindSun 通过 微信 打赏了 ¥20.00 备注：歪瑞古德 2024-07-16 00:09:47贺雄彪 通过 微信 打赏了 ¥5.21 备注：感谢李瑞豪同学🧑‍🎓 2024-04-03 17:10:15杨潇 通过 微信 打赏了 ¥5.20 备注：辛苦了，宝贝 2024-04-03 17:02:03淮屿 通过 赞赏码 打赏了 ¥10.00 备注：非常棒的主题👍 2024-02-05 15:42:42匿名 通过 赞赏码 打赏了 ¥15.00 2024-01-13 21:39:37丰果 通过 FixIt 主题交流群 QQ 红包 打赏了 ¥15.00 备注：请喝杯咖啡 2023-11-03 22:35:07🐟 通过 微信 打赏了 ¥1.00 备注：感谢 FixIt 作者 2023-05-24 15:49:46建议去世 通过 微信 打赏了 ¥20.00 备注：主题不错 2023-04-17 10:35:26乐语 通过 微信 打赏了 ¥5.00 备注：很好用的主题，谢谢作者💪 2023-04-03 17:49:12D*n 通过 微信 打赏了 ¥11.11 备注：加油 2023-03-17 14:57:41K*n 通过 微信 打赏了 ¥50.00 2023-03-17 14:05:49✘✘波 通过 支付宝 打赏了 ¥20.00 备注：感谢帮忙解决 FixIt 的问题 2023-02-13 10:01:58✘✘松 通过 支付宝 打赏了 ¥2.00 2022-12-02 13:01:48✘喜洲 通过 QQ 打赏了 ¥20.20 备注：来自 101****073 2020-01-17✘昌升 通过 微信 打赏了 ¥2.00 备注：来自 231****047#qq.com 2019-03-19✘昌升 通过 支付宝 打赏了 ¥10.00 备注：上课的时候听到了支付宝清脆的支付宝到账 10 元的声音！ 2018-12-04✘昌升 通过 支付宝 打赏了 ¥18.00 2018-12-04francs 通过 QQ 打赏了 ¥8.80 2018-11francs 通过 QQ 打赏了 ¥8.80 备注：今天学校运动会没课，睡到 9 点多起来看到 QQ 收到一个红包，感谢支持！ 2018-10-26francs 通过 支付宝 打赏了 ¥50.00 备注：大学生时期，第一次收到别人的支持，内心表示受宠若惊又非常开心。非常感谢老哥的支持！ 2018-09-28 - 次阅读 ","date":"2024-08-16","objectID":"/reward/:0:0","tags":null,"title":"赞赏记录","uri":"/reward/"},{"categories":["GitHub"],"content":"hugo fixit/cmpt mdevtools: Mobile devtools component powered by vConsole and eruda.","date":"2024-08-07","objectID":"/projects/hugo-fixit/cmpt-mdevtools/","tags":["eruda","hugo","theme-component","vconsole"],"title":"Mobile devtools component powered by vConsole and eruda.","uri":"/projects/hugo-fixit/cmpt-mdevtools/"},{"categories":["GitHub"],"content":"cmpt-mdevtools Mobile devtools component powered by vConsole and eruda. Requirements FixIt v0.4.0 or later. eruda vConsole Install Component The installation method is the same as installing a theme. There are several ways to install, choose one, for example, install through Hugo Modules: [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" + [[module.imports]] + path = \"github.com/hugo-fixit/cmpt-mdevtools\" Configuration # Mobile Devtools config [params.mDevtools] enable = false # \"eruda\", \"vConsole\" supported type = \"eruda\" Inject Partial In order to Inject the partial cmpt-mdevtools.html into the custom-assets through the custom block opened by the FixIt theme in the layouts/_partials/custom.html file, you need to fill in the following necessary configurations: [params] [params.customPartials] # ... other partials head = [ \"inject/cmpt-mdevtools.html\" ] # ... other partials References Develop Theme Components | FixIt How to Develop a Hugo Theme Component | FixIt ","date":"2024-08-07","objectID":"/projects/hugo-fixit/cmpt-mdevtools/:0:0","tags":["eruda","hugo","theme-component","vconsole"],"title":"Mobile devtools component powered by vConsole and eruda.","uri":"/projects/hugo-fixit/cmpt-mdevtools/"},{"categories":["CSS"],"content":"本文将介绍另外一个非常实用的 CSS 数学函数 - round() 及其实际应用场景。 1 何为 CSS round 函数 这是一个比较新的 CSS 函数，在 CSS Values and Units Module Level 4 规范中提出，自 2024 年 5 月起，此功能适用于最新设备和浏览器版本。此功能可能无法在较旧的设备或浏览器中使用。 CSS round() 函数根据选定的舍入策略返回舍入数。 作者应使用自定义 CSS 属性（例如 --my-property）作为舍入值、间隔或两者兼而有之；如果这些函数具有已知值，使用 round() 函数显然不太必要。 1.1 语法规则 round() 的完整语法规则还是比较复杂的。完整的介绍可以看 MDN - round()。 \u003cround()\u003e = round( \u003crounding-strategy\u003e?, \u003cvalueToRound\u003e , \u003croundingInterval\u003e ) round(\u003crounding-strategy\u003e, valueToRound, roundingInterval) 函数指定可选的舍入策略、要舍入的值（或数学表达式）和舍入间隔（或数学表达式）。根据舍入策略，valueToRound 四舍五入到 roundingInterval 的最接近整数倍。 \u003crounding-strategy\u003e: 可选参数，表示舍入策略。这可能是以下值之一： up: 相当于 JavaScript Math.ceil() 方法，将 valueToRound 向上舍入到 roundingInterval 最接近的整数倍。这相当于 JavaScript Math.ceil() 方法。 down: 将 valueToRound 向下舍入为 roundingInterval 最接近的整数倍。这相当于 JavaScript Math.floor() 方法。 nearest: 将 valueToRound 舍入为 roundingInterval 的最接近的整数倍，该倍数可以高于或低于该值。如果 valueToRound 是上方和下方舍入目标之间的一半，则会向上舍入。相当于 JavaScript Math.round()。 to-zero: 将 valueToRound 舍入为 roundingInterval 接近/接近零的最接近整数倍。这相当于 JavaScript Math.trunc() 方法。 \u003cvalueToRound\u003e: 需要被四舍五入的值。必须是 \u003cnumber\u003e、\u003cdimension\u003e 或 \u003cpercentage\u003e，或者解析为这些值之一的数学表达式。 \u003croundingInterval\u003e: 舍入的间隔规则。这是一个 \u003cnumber\u003e、\u003cdimension\u003e 或 \u003cpercentage\u003e，或者解析为这些值之一的数学表达式。 1.2 示例 width: round(var(--width), 50px); width: round(up, 101px, var(--interval)); width: round(down, var(--height), var(--interval)); margin: round(to-zero, -105px, 10px); MDN 官方写了一个完整的例子，可以看 Playground | MDN。 2 有什么用 上面讲了一大堆概念，那这玩意到底有什么用勒？ 好好好，那就再回想一下在此之前我们开发中遇到的痛点吧： 解决基于 transform 的模糊问题 使用 round() 模拟步骤缓动动画 解决百分比或者 rem 单位的四舍五入问题 前两点可以看 ChokCoco 的文章 现代 CSS 解决方案：数学函数 Round，里面有详细的讲解。 而我遇到的主要问题就是第三点，也就是由于浏览器渲染机制，导致有时百分比或者 rem 的单位实际计算值为小数的情况引起的系列问题。 造成这个现象的主要原因有： 像素单位和设备像素比（DPR） 浏览器的子像素渲染偏差 举个例子吧： .container { width: 100px; } .child { width: 33.33%; } 如果容器 .container 中有三个 .child 元素，那么每个 .child 的理论宽度应该是 33.33px。然而，由于不能将像素拆分，浏览器采取四舍五入方式处理，从而得到了 33px 或 34px 的结果。然而，为了保持布局的精确性，浏览器实际上以子像素的方式保存了这些值，并且在渲染时考虑了这部分差异。 但是！！！坑爹的是，不同浏览器的处理方式也会不同，还有就是子孙节点继承宽度时可能会有四舍五入导致子孙节点宽度大于父节点宽度的问题。 3 实际场景应用 在 FixIt 主题中，页面内容分为左、中、右三栏： .wrapper main.container { display: flex; align-items: flex-start; justify-content: center; padding-inline: 1rem; gap: 0.5rem; .page { width: 56%; #comments { width: 100%; // 评论区域 iframe iframe { width: 100%; } } } } 例如在 1440px 的屏幕上，中间内容宽度应该为 (1440 - 2 * 16) * 0.56 = 788.48px，实际渲染结果却是 788.48px。 问题来了，在内容的最后加上一个 giscus 评论区域，评论区域容器 iframe 和 iframe 里面的内容按理说应该都是 788.48px，但是实际渲染结果却是： 评论容器 iframe：788.48px iframe 内评论内容 HTML：789px 怎么说？无奈不，四舍五入，你舍掉其实这个场景我也就不纠结了，恰好它是符合五入的规则，向上 1px 取整了，导致的视觉上的影响就是 giscus 评论区域右侧的边框恰巧不见了。—T_T— 那怎么搞勒，治标不治本的做法就是，把评论区 #comments 的宽度缩小一些，但是我不想这样做。 我想既然问题是小数点造成的，避免产生小数点不就好了，然后就用到了 round() 函数： .page { width: round(56%, 2px); } 我希望页面中间永远是偶数，这样可以同时避免左、中、右三个部分出现小数，所以这里的 roundingInterval 设置为 2px，表示四舍五入到 2px 的整数倍，这样就避免了小数点的问题。 好了，问题就这样愉快地解决了……吗？ 好吧，并没有。—T_T— 4 兼容性 开头说了这是一个比较新的 CSS 函数，所以兼容性肯定是个问题。尽管截至 2024 年 7 月 29 日，round() 函数覆盖了 67.63% 的浏览器，并且在各类浏览器中的最新几个版本都得到了完全支持（忽略 IE），但是在一些老版本的浏览器中还是不支持的，如下图。 那又怎么搞勒？要崩溃了，最讨厌兼容性了，也讨厌 Polyfill，但是毕竟 FixIt 主题不是我一个人在用，还是加一下 Polyfill 吧。 好家伙！没有 Polyfill 可用。真要崩溃了，前面都白折腾了？—T_T— 也不是没有办法，自己写一个，利用 @supports 写一些兼容性代码吧，不支持的就不用 round() 函数了。 上面简化后的例子兼容性可以这样写： // 顺便提一下，大写 ROUND 是为了避免和 Sass 的 round 函数冲突，CSS 中对函数关键词大小写不敏感。 .wrapper main.container { display: flex; align-items: flex-start; justify-content: center; padding-inline: 1rem; gap: 0.5rem; .page { width: ROUND(56%, 2px); #comments { width: 100%; // 评论区域 iframe iframe { width: 100%; } } } // 如果不支持 round() 函数，回退到设定固定值 56% @supports not (width: ROUND(56%, 2px)) { .page { width: 56%; } } /* ... */ } 好了，跌跌撞撞就这样了，等过两年 round() 函数覆盖率更高了我第一件事就是把上面的兼容性代码删掉。😂 ","date":"2024-07-29","objectID":"/posts/css-round/:0:0","tags":["CSS","round"],"title":"现代 CSS 解决方案：CSS 四舍五入数值单位","uri":"/posts/css-round/"},{"categories":["GitHub"],"content":"hugo fixit/shortcode rewards: A Hugo theme component with reward-log or sponsor-log shortcode.","date":"2024-07-21","objectID":"/projects/hugo-fixit/shortcode-rewards/","tags":["hugo","reward-log","shortcodes","theme-component"],"title":"A Hugo theme component with reward-log or sponsor-log shortcode.","uri":"/projects/hugo-fixit/shortcode-rewards/"},{"categories":["GitHub"],"content":"shortcode-rewards A Hugo theme component with reward-log or sponsor-log shortcode. Demo FixIt Docs Lruihao’s Blog Requirements Developed based on the FixIt Timeline plugin. FixIt v0.4.0 or later. Install Component The installation method is the same as installing a theme. There are several ways to install, choose one, for example, install through Hugo Modules: [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" + [[module.imports]] + path = \"github.com/hugo-fixit/shortcode-rewards\" Configuration In order to Inject the partial shortcode-rewards.html into the custom-head through the custom block opened by the FixIt theme in the layouts/partials/custom.html file, you need to fill in the following necessary configurations: [params] [params.customPartials] # ... other partials head = [ \"inject/shortcode-rewards.html\" ] # ... other partials Usage First, create the reward-log.yml file and edit your data: cp themes/shortcode-sponsor-log/reward_log.yml.example data/reward_log.yml If your site is multilingual, you can create a reward_log.en.yml file for English and reward_log.zh-cn.yml for Chinese. Next, use the reward-log shortcode in any page: {{\u003c reward-log \u003e}} 注意 For compatibility with older versions, sponsor-log shortcode can also be used, and the corresponding data file is sponsor_log.yml. Params Shortcode The reward-log shortcode has the following named parameters, and the positional parameters ordered from top to bottom: Parameter Description Type Optional values Default reverse whether the node is ascending or descending boolean - true placement position of timestamp string top / bottom bottom animation whether to enable animation boolean - false size node size string small / medium / large medium node node style string circle / dot circle width # container width string - - height # container height string - - class # container classname string - - Parameters marked with # only support named parameters. Data The reward_log.yml file has the following fields: # The sponsor logs data format is as follows # currency: [CNY, USD, EUR, ...] https://gohugo.io/functions/lang/formatcurrency/ # origin: [alipay, bitcoin, paypal, wechatpay, ...] message: Thanks all! currency: CNY symbol: ¥ # The sponsor logs inherit the FixIt Timeline events logs: - date: \"2006-01-02 15:04:05\" sponsor: Cell money: 50 origin: alipay remark: \"Come on!\" References Develop Theme Components | FixIt How to Develop a Hugo Theme Component | FixIt ","date":"2024-07-21","objectID":"/projects/hugo-fixit/shortcode-rewards/:0:0","tags":["hugo","reward-log","shortcodes","theme-component"],"title":"A Hugo theme component with reward-log or sponsor-log shortcode.","uri":"/projects/hugo-fixit/shortcode-rewards/"},{"categories":["Git"],"content":"使用 Git 命令统计在某段时间内项目中的代码量。 1 统计 commit 数 git log --author=\"1024@lruihao.cn\" --since=\"2023-01-01\" --until=\"2023-12-31\" --oneline | wc -l 2 统计行数 git log --author=\"1024@lruihao.cn\" --pretty=tformat: --since=\"2023-01-01\" --until=\"2023-12-31\" --numstat -- . \":(exclude)build\" \":(exclude)dist\" \":(exclude)node_modules\" \":(exclude)test\" \":(exclude)static\" -numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' 3 整合成一个脚本 统计所有作者移除 --author=\"$author_email\" #!/bin/bash project_name=$(basename \"$(pwd)\") author_email=\"1024@lruihao.cn\" # since_date=\"1 year ago\" since_date=\"2023-01-01\" until_date=\"2023-12-31\" # 统计 commit 数量 commit_count=$(git log --author=\"$author_email\" --since=\"$since_date\" --until=\"$until_date\" --oneline | wc -l) # 统计代码行数（排除目录 build、dist、node_modules、test、static） line_stats=$(git log --author=\"$author_email\" --pretty=tformat: --since=\"$since_date\" --until=\"$until_date\" --numstat -- . \":(exclude)build\" \":(exclude)dist\" \":(exclude)node_modules\" \":(exclude)test\" \":(exclude)static\" | awk '{ add += $1; subs += $2; } END { printf \"%s ++\\t%s --\\n\", add, subs }') echo \"$project_name:\\t$commit_count commits\\t$line_stats\" 例如在 FixIt 项目中截至 2024-07-17 为止我的代码统计如下： FixIt: 1022 commits 82040 ++ 103942 -- ","date":"2024-07-17","objectID":"/posts/git-summary/:0:0","tags":["Git"],"title":"Git 统计代码量","uri":"/posts/git-summary/"},{"categories":["CSS"],"content":"今天记录一个 CSS 小知识点，如何给异形元素设置阴影。 1 遇到的问题 之前给博客头部设置了一个 异形元素，当时给它父元素设置了如下 box-shadow： header { box-shadow: 0 0 1.5rem 0 rgba(0, 0, 0, 0.1); } 发现只有矩形部分有阴影，异形部分没有阴影。是因为 box-shadow 只能给盒子模型设置阴影，异形元素无法设置阴影的。 那怎么给异形元素设置阴影呢？ 2 解决方法 可以使用 filter 属性的 drop-shadow 函数来给异形元素设置阴影。 drop-shadow 绘制的投影实际上是输入图像的 alpha 蒙版的一个模糊的、偏移的版本，用特定的颜色绘制并合成在图像下面。 备注 这个函数有点类似于 box-shadow 属性。box-shadow 属性在元素的整个框后面创建一个矩形阴影，而 drop-shadow() 过滤器则是创建一个符合图像本身形状 (alpha 通道) 的阴影。 语法如下： drop-shadow(offset-x offset-y standard-deviation color) 可以看出，drop-shadow 比 box-shadow 少了一个阴影的扩展半径 spread-radius 参数（或者说尚未实现）。 回到我的问题，给异形元素设置阴影的代码如下： header { filter: drop-shadow(0 0 0.75rem rgba(0, 0, 0, 0.1)); } 3 浏览器支持 4 参考链接 drop-shadow() - CSS: Cascading Style Sheets | MDN ","date":"2024-07-15","objectID":"/posts/drop-shadow/:0:0","tags":["CSS","drop-shadow","box-shadow"],"title":"现代 CSS 解决方案之异形元素怎么设置阴影？","uri":"/posts/drop-shadow/"},{"categories":["GitHub"],"content":"hugo fixit/shortcode docs bookmark: 🔖 Embed bookmark of FixIt Docs.","date":"2024-07-14","objectID":"/projects/hugo-fixit/shortcode-docs-bookmark/","tags":["fixit-docs-bookmark","hugo","hugo-fixit","shortcodes","theme-component"],"title":"🔖 Embed bookmark of FixIt Docs.","uri":"/projects/hugo-fixit/shortcode-docs-bookmark/"},{"categories":["GitHub"],"content":"fixit-docs-bookmark 🔖 Embed bookmark of FixIt Docs. Requirements FixIt v0.4.0 or later. Install Component The installation method is the same as installing a theme. There are several ways to install, choose one, for example, install through Hugo Modules: [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" + [[module.imports]] + path = \"github.com/hugo-fixit/shortcode-docs-bookmark\" Configuration In order to Inject the partial fixit-docs-bookmark.html into the custom-head through the custom block opened by the FixIt theme in the layouts/_partials/custom.html file, you need to fill in the following necessary configurations: [params] [params.customPartials] # ... other partials head = [ \"inject/fixit-docs-bookmark.html\" ] # ... other partials Use Shortcode Here is an example of usage: {{\u003c fixit-docs-bookmark \u003e}} ","date":"2024-07-14","objectID":"/projects/hugo-fixit/shortcode-docs-bookmark/:0:0","tags":["fixit-docs-bookmark","hugo","hugo-fixit","shortcodes","theme-component"],"title":"🔖 Embed bookmark of FixIt Docs.","uri":"/projects/hugo-fixit/shortcode-docs-bookmark/"},{"categories":["CSS"],"content":"本文将通过一个实际应用场景，展示如何使用现代 CSS 实现时间轴、背景图 loading 效果、渐变边框等效果。","date":"2024-07-14","objectID":"/posts/fixit-docs-bookmark/","tags":["CSS","Scss"],"title":"CSS 实现时间轴、背景图 loading 和渐变边框","uri":"/posts/fixit-docs-bookmark/"},{"categories":["CSS"],"content":"本文将通过一个实际应用场景，展示如何使用现代 CSS 实现时间轴、背景图 loading 效果、渐变边框等效果。 1 背景 最近在调整 FixIt 主题的官方文档，调整过程中总觉得首页空荡荡的少了些内容，然后就在脑海里构思了如本文封面图所示的效果，希望引导用户阅读文档。 需求分析： 整体布局：左右两栏，左侧为主题文档大纲，右侧为网站预览图 左侧需要显示时间轴，时间轴带有跑马灯动画效果（暗指文档阅读顺序） 右侧加载网站预览图时，需要有 loading 效果 整体边框需要渐变效果 第一点很简单，一个 flex 布局就能搞定了，这里不再展开。 接下来我们重点看看如何实现时间轴、背景图 loading 效果和渐变边框。 2 时间轴 先睹为快，效果如下： 从上到下依次点亮时间轴 我不希望时间轴的实现和其他 UI 框架一样拥有复杂的 DOM 结构，所以使用最简单的 ul 和 li 即可，关键代码如下： \u003cul class=\"docs-outline\"\u003e \u003cli\u003e\u003ca href=\"{{ $page1.Permalink }}\"\u003e{{ $page1.LinkTitle }}\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"{{ $page2.Permalink }}\"\u003e{{ $page2.LinkTitle }}\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"{{ $page3.Permalink }}\"\u003e{{ $page3.LinkTitle }}\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"{{ $page4.Permalink }}\"\u003e{{ $page4.LinkTitle }}\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e DOM 结构就这么简单，重点在于 CSS 的实现，实现思路如下： 先把 ul 设置 list-style: none，去掉默认的 li 样式 利用 ::before 和 ::after 伪元素实现时间轴的小圆点和连接线 动画效果：四个小圆点默认和连接线一样灰色，然后依次点亮，可以使用 animation-delay 属性实现 动画效果关键帧代码如下： li::before { border: var(--timeline-width) solid var(--timeline-color); animation-name: border-color-fade; animation-duration: 2s; animation-iteration-count: infinite; animation-delay: calc(var(--timeline-index) * 0.3s); @keyframes border-color-fade { 0% { border-color: var(--timeline-color); } 50% { border-color: var(--timeline-circle-color); } 100% { border-color: var(--timeline-color); } } } 通过 nth-child 选择器来设置 --timeline-index 来线性增加每个小圆点的动画延迟时间，从而在视觉上出现依次点亮的效果。 如果使用 SCSS 可以简化代码，如下： @for $i from 1 through 4 { li:nth-child(#{$i}) { --timeline-index: #{$i}; \u0026::before { content: '#{$i}'; } } } 如果需要在小圆点的内部显示序号，可以像设置 --timeline-index 一样依次设置 content。 然后在小圆点点亮动画过程中同时转变 color: transparent 到具体的颜色即可。 3 背景图 loading 效果 先加载 loading 图再加重预览图 如果只是想实现图片的 loading 效果其实很简单，之前在「浏览器 IMG 图片原生懒加载 Loading=“lazy”」中有介绍过，但是这次我是把图片当作背景图片使用的，那问题来了，不通过 JS 背景图片的 loading 效果怎么实现呢？ 还是可以利用 ::before 和 ::after 伪元素，一个伪元素用来显示 loading 图，另一个伪元素用来显示背景图片。 原理：利用两张图片加载的时间差，由于 loading 图片很小，所以加载很快，而背景图片加载较慢，然后默认不设置 z-index 的情况下，后面的元素会在上层，所以在背景图片加载完成前，loading 图片会一直显示。 关键代码如下： .docs-preview { \u0026::before, \u0026::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-position: center; background-repeat: no-repeat; } \u0026::before { background-color: rgba(204, 204, 204, 0.1); background-image: url(/images/loading.min.svg); background-size: 60px; [data-theme='dark'] \u0026 { background-color: rgba(0, 0, 0, 0.1); } } \u0026::after { background-image: url(/images/apple-devices-preview.webp); background-size: 130%; } } 4 全尺寸带圆角渐变边框 最后实现一个全尺寸带圆角渐变边框效果，一句话概括为利用线性渐变 linear-gradient 分别设置 padding-box 和 border-box 的背景，然后 border 颜色设置为透明即可实现。 .docs-navigation { border-radius: 2.5px; background: linear-gradient(#fff, #fff) padding-box, linear-gradient(45deg, #42d392, #FF7359) border-box; border: 0.25rem solid transparent; } 值得一提的是，这里面利用到的一个核心概念是 background-clip 属性，详见 background-clip - CSS: Cascading Style Sheets | MDN： padding-box 表示背景延伸到内边距边界 border-box 表示背景延伸到边框边界。 另外，如果想实现渐变边框的动画效果，用 SCSS 可以这样做（虽然我不认为这是一个好的做法）： .docs-navigation { border-radius: 2.5px; background: linear-gradient(#fff, #fff) padding-box, linear-gradient(var(--gradient-angle), #42d392, #FF7359) border-box; border: 0.25rem solid transparent; transition: background-color 0.5s, border-color 0.5s; --gradient-angle: 45deg; animation: gradient-angle-change 10s infinite linear; // 分的越细，动画效果越平滑 @keyframes gradient-angle-change { @for $i from 0 through 100 { #{$i * 1%} { --gradient-angle: #{45 + $i * 4}deg; } } } } 5 最后的效果 为了方便使用 FixIt 主题的用户在自己的笔记内插入 FixIt 官方文档的书签，我把这个效果封装成了一个独立的组件，你可以在 hugo-fixit/shortcode-docs-bookmark 中找到完整代码及食用方法。 安装篇入门篇内容管理进阶篇 6 总结 很多时候都感觉写 CSS 就像在写诗，相同的效果 CSS 实现往往会比 JS 更加优雅。 ","date":"2024-07-14","objectID":"/posts/fixit-docs-bookmark/:0:0","tags":["CSS","Scss"],"title":"CSS 实现时间轴、背景图 loading 和渐变边框","uri":"/posts/fixit-docs-bookmark/"},{"categories":["CSS"],"content":"使用 scrollbar-width 和 scrollbar-color 属性设置滚动条的样式。 21 简介 从 Chrome 版本 2 开始，可以使用 ::-webkit-scrollbar-* 伪元素设置滚动条的样式。此方法在 Chrome 和 Safari 中都很有效，但 CSS 工作组从未标准化。 MDN - ::-webkit-scrollbar Non-standard: This feature is non-standard and is not on a standards track. Do not use it on production sites facing the Web: it will not work for every user. There may also be large incompatibilities between implementations and the behavior may change in the future. 实现标准化的是 scrollbar-width 和 scrollbar-color 属性，它们是 CSS Scrollbars Styling Module Level 1 的一部分。从 Chrome 121 开始，这些属性受支持。 22 滚动条入门指南 22.1 滚动条剖析 滚动条至少由一个轨迹和一个滑块组成。滑道是拇指可以移动的区域。轨迹表示整个滚动距离。滑块表示可滚动区域内的当前位置。滚动时，它会在轨道内移动。拇指通常也是可拖动的。 不过，滚动条可以有多个部分，而不仅仅是滑块和滑道。例如，滚动条可以包含一个或多个用于递增或递减滚动偏移的按钮。滚动条的组成部分由底层操作系统决定。 左侧插图是一个最小的滚动条，其中只有轨迹和拇指。右边的按钮也有一些按钮。 22.2 传统滚动条和重叠式滚动条 在介绍如何设置滚动条的样式之前，请务必先了解两种滚动条之间的区别。 操作系统 默认滚动条 Mac 叠加滚动条（Overlay scrollbars） Windows 经典滚动条（Classic scrollbars） 22.2.1 叠加滚动条 叠加层滚动条是在下方内容之上的浮动滚动条。默认情况下，这些按钮不会显示，只有当主动滚动时才会显示。为了让内容保持可见状态，它们通常采用半透明形式，但这由操作系统来决定。在与它们互动时，它们的大小也可能有所变化。 滚动条会叠加在内容上；滑块是部分透明的。 22.2.2 经典滚动条 传统滚动条是放置在专用_滚动条边线_中的滚动条。滚动条边线是内边框边缘与外内边距边缘之间的空间。这些滚动条通常是不透明的（不透明），并会占用相邻内容的某些空间。 滚动条位于内容旁边的专用区域中；内容的可用宽度会缩小（相对于使用叠加层滚动条时的可用宽度）。 23 scrollbar-color 和 scrollbar-width 属性 23.1 scrollbar-color 设置滚动条颜色 参考 https://developer.mozilla.org/zh-CN/docs/Web/CSS/scrollbar-color 借助 scrollbar-color 属性，可以更改滚动条的配色方案。该属性接受两个 \u003ccolor\u003e 值。 第一个值用于确定滑块（thumb）的颜色 第二个值用于确定要用于轨道（track）的颜色 如需使用操作系统提供的默认呈现方式，请使用 auto 作为其值。 /* 关键字值 */ scrollbar-color: auto; /* \u003ccolor\u003e 值 */ scrollbar-color: rebeccapurple green; /* 两个有效的颜色。 第一个应用于滚动条的滑块，第二个应用于轨道。 */ /* 全局值 */ scrollbar-color: inherit; scrollbar-color: initial; scrollbar-color: revert; scrollbar-color: revert-layer; scrollbar-color: unset; 默认情况下，使用叠加滚动条时，轨迹的颜色不起作用。不过，将鼠标悬停在滚动条上时，系统会显示航迹。 23.2 scrollbar-width 设置滚动条粗细 参考 https://developer.mozilla.org/zh-CN/docs/Web/CSS/scrollbar-width 借助 scrollbar-width 属性，可以选择较窄的滚动条，甚至可以完全隐藏滚动条而不影响可滚动性。 接受的值包括 auto、thin 和 none。 auto：平台提供的默认滚动条宽度。 thin：平台提供的滚动条的细变体，或比默认平台滚动条更细的自定义滚动条。 none：有效隐藏滚动条。不过，此元素仍然可滚动。 无法使用 \u003clength\u003e（例如 16px）作为 scrollbar-width 的值。 /* 关键字值 */ scrollbar-width: auto; scrollbar-width: thin; scrollbar-width: none; /* 全局值 */ scrollbar-width: inherit; scrollbar-width: initial; scrollbar-width: revert; scrollbar-width: revert-layer; scrollbar-width: unset; 使用叠加滚动条时，仅当你主动滚动可滚动区域时，才会显示滚动条滑块。 24 支持旧版浏览器 为了满足不支持 scrollbar-color 和 scrollbar-width 的浏览器版本，可以同时使用新的 scrollbar-* 和 ::-webkit-scrollbar-* 属性。 /* Modern browsers with `scrollbar-*` support (high priority) */ @supports (scrollbar-width: auto) { * { scrollbar-color: var(--scrollbar-thumb-color) var(--scrollbar-track-color);; scrollbar-width: var(--scrollbar-width); } } /* Legacy browsers with `::-webkit-scrollbar-*` support */ ::-webkit-scrollbar { height: var(--scrollbar-width-legacy); width: var(--scrollbar-width-legacy); overflow: visible; } ::-webkit-scrollbar-button { height: 0; width: 0; } ::-webkit-scrollbar-corner { background-color: var(--scrollbar-track-color); } ::-webkit-scrollbar-thumb { background-color: var(--scrollbar-thumb-color); } ::-webkit-scrollbar-thumb:hover { background-color: var(--scrollbar-thumb-hover-color); } ::-webkit-scrollbar-track { background-color: var(--scrollbar-track-color); } ::-webkit-scrollbar-thumb, ::-webkit-scrollbar-track { background-clip: padding-box; border: 3px solid transparent; border-radius: 100px; } 请注意，当设置 ::-webkit-scrollbar 的 width 或 height 时，系统始终会显示叠加层滚动条，实际上会变为经典滚动条。 25 总结一下 可以看到，其实就目前 scrollbar-width 而言，其能力还是属于比较鸡肋的。相对正常的样式，仅仅多了一种瘦版样式选择以及提供了无滚动条模式。 当然，整个 scrollbar-color 和 scrollbar-width 相较于非标准的 ::-webkit-scrollbar 规范已经是非常大的一步跨越。只是其功能的丰富性和全面性还需要等待。 ","date":"2024-06-28","objectID":"/posts/scrollbar-styling/:0:0","tags":["CSS","scrollbar-styling"],"title":"标准滚动条控制规范","uri":"/posts/scrollbar-styling/"},{"categories":["GitHub"],"content":"hugo fixit/shortcode caniuse: A Hugo theme component with caniuse shortcode.","date":"2024-06-28","objectID":"/projects/hugo-fixit/shortcode-caniuse/","tags":["caniuse-embed","hugo","hugo-fixit","shortcodes","theme-component"],"title":"A Hugo theme component with caniuse shortcode.","uri":"/projects/hugo-fixit/shortcode-caniuse/"},{"categories":["GitHub"],"content":"Hugo shortcode for CanIUse 在 Hugo 中使用 shortcode 方式内嵌 CanIUse 到你的文章中。 依赖 FixIt 主题 v0.4.0 及以上版本。 安装组件 和 安装主题 一样，安装方式有多种，选择其一即可，例如通过 Hugo Modules 安装： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" + [[module.imports]] + path = \"github.com/hugo-fixit/shortcode-caniuse\" 配置 为了通过 FixIt 主题在 layouts/partials/custom.html 文件中开放的 自定义块 将 shortcode-caniuse.html 注入到 custom-assets 中，你需要填写以下必要配置： [params] [params.customPartials] # ... other partials assets = [ \"inject/shortcode-caniuse.html\" ] # ... other partials 组件配置： [params] # CanIUse Embed Element Configuration # See: https://github.com/Lruihao/caniuse-embed-element [params.caniuse_embed] # show the past N versions that match the feature, range is 0 - 5, default is 2 past = 2 # show the future N versions that match the feature, range is 0 - 3, default is 1 future = 1 # the origin of the caniuse embed data source, default is \"https://caniuse.lruihao.cn\" origin = \"https://caniuse.lruihao.cn\" # loading strategy for the iframe (eager or lazy), default is lazy loading = \"lazy\" # only production environment effective # e.g. https://unpkg.com/@cell-x/caniuse-embed-element/dist/caniuse-embed-element.iife.js cdn = \"\" 使用 Shortcode caniuse shortcode 有以下命名参数： feature [必需]（第一个位置参数）特性名称 past [可选]（第二个位置参数）显示过去 N 个版本，范围是 0 - 5，默认为 2 future [可选]（第三个位置参数）显示未来 N 个版本，范围是 0 - 3，默认为 1 origin [可选]（第四个位置参数）caniuse embed 数据源，例如：https://caniuse-embed-x.vercel.app loading [可选]（第五个位置参数）iframe 的加载策略（eager 或 lazy），默认为 lazy 点击 caniuse.com 网站上功能左边 # 号，URL 中的 pathname 即为 feature 参数。 这是一个用法示例： {{\u003c caniuse feature=\"flexbox\" \u003e}} 或者 {{\u003c caniuse \"flexbox\" \u003e}} 参考 The CanIUse Embed — Add support tables to your site Can I use… Support tables for HTML5, CSS3, etc 致谢 Lruihao/caniuse-embed-element pengzhanbo/caniuse-embed mdn-browser-compat-data Fyrd/caniuse ","date":"2024-06-28","objectID":"/projects/hugo-fixit/shortcode-caniuse/:0:0","tags":["caniuse-embed","hugo","hugo-fixit","shortcodes","theme-component"],"title":"A Hugo theme component with caniuse shortcode.","uri":"/projects/hugo-fixit/shortcode-caniuse/"},{"categories":["Vue.js"],"content":"边界拖拽调整窗口大小功能是一个很常见的功能，比如浏览器、编辑器等很多场景都有应用，这种功能不仅提高了用户体验，也增强了应用的灵活性。 1 效果演示 vue-el-demo/#/aside-toggle-drag 2 实现代码 @/components/AsideToggler 3 实现思路 怎么说呢，写这篇文章就是想记录一下思路，本来想画个图说明一下的，但是懒得画了，随便说几句吧。 实现边界拖拽调整窗口大小功能，主要是通过鼠标按下、移动、松开事件来实现的，主要思路如下： 在 mousedown 事件中，我们记录下鼠标的初始位置和元素的初始宽度。 在 mousemove 事件中，我们根据鼠标的新位置计算出新的宽度，并使用 clamp() 函数将其限制在最小宽度和最大宽度之间。 同时，我们还需要根据鼠标位置的变化，动态更新鼠标样式，以提示用户当前的拖拽状态。 在 mouseup 事件中，我们清除之前设置的事件监听器，并恢复鼠标样式。 实现过程中，有两个比较巧妙的点： 计算宽度的时候，没有使用 JS 计算，而是直接使用了 CSS 的 clamp() 函数，一目了然。 为了鼠标移动到可拖拽边界时显示一条蓝色的线，但是又不想改变元素的宽度，所以 resize-bar 元素的使用了 position: absolute，并且设置了 translateX(-50%) 来让其居中显示。当鼠标移入时，通过线性渐变的背景色巧妙地来实现蓝色线条的效果。 正是因为第二点的实现方式，使得在边界线左右两侧都能拖拽，这一点是优于 VSCode 的，因为 VSCode 只能在左侧拖拽 😂。 ","date":"2024-06-13","objectID":"/posts/aside-toggle-drag/:0:0","tags":["Vue2","CSS","JavaScript"],"title":"如何实现 VSCode 编辑器窗口边界拖拽类似功能","uri":"/posts/aside-toggle-drag/"},{"categories":["Spec"],"content":"本文节选自 奔波儿灞取经 的《程序员的必修课》，文中的“我”指原作者奔波儿灞取经。 设计模式不是必须的，但是如果你的代码是“非一次性的”，那么它就是必须的。 对于大多数开发者来说，代码都是需要维护的，而不是写一遍就放起来不管了。既然需要维护，就要不断地读读改改，那就不是一次性的，那么怎么让他“读读改改”起来方便些呢？嗯，设计模式！ 设计模式切记不要死记硬背，不要生搬硬套，否则不如不学。而且不要一上来就说：要用 xxx 模式！需求还没出，你猴急个锤子，难不成是你刚学会这个模式，想拿来练练手，就想把它硬塞到需求里去吗？ 那么，如果需求已经出了呢？也别急，先想想，想好了怎么写，选择哪种设计模式；如果没有合适的，套不进去，那就别套了，只要方便维护，就是好的设计，不一定非要去套现有的设计模式。 当然，要想正确地使用设计模式，还是先得透彻地了解了它们。因此，接下来我们就先来了解下设计模式的“祖宗”：六大设计原则。 1 单一职责原则（SRP） 单一职责原则（Single Responsibility Principle，简称 SRP）：一个类只干一件事。 可以看到，单一职责的核心就是：只做一件事。不过，关键点就是这个“事”的范围不好定义。 比如，写一个音乐播放器，一个类负责播放，一个类负责停止，这也满足单一职责。但是，这个职责太小了。那么，如果把播放、停止、甚至下载歌曲，都塞进一个类里面呢，那就太大了。所以，职责的范围很重要，只要确定好了这个范围，那这个原则就已经实现了 90%。 那么，这个范围怎么确定呢？我们可以这么理解：一些相关的、关联性比较强的，就把它们当作同一种职责，放到一个单独的类（文件）里。 那么，怎么确定是否相关呢？看需求！这个只能看需求，没有别的方法。如果需求没有明确，那么我们就要联系现实来决定，毕竟程序的本质就是模拟现实。 比如，我在 2015 年实习的时候，IBM 公司有个考勤系统，需要添加一个指纹打卡功能。需求是这样的：部门主管以下的员工可以用指纹来打卡。 那么，这个“打卡功能”是属于员工的，是属于打卡器的？换句话说，这个打卡的函数，是写在员工类里面呢，还是写在打卡器类里面呢？需求没说啊。 那么，我们就联系现实来决定。 在现实生活中，应该是一个打卡器放在门口，员工向打卡器录入指纹，来进行打卡，说白了就是：“员工使用打卡器来打卡”，也就是：“员工使用打卡器”“打卡器打卡”，所以，打卡功能是打卡器的，员工只是使用它的这个功能。所以，这个函数应该定义在打卡器里面，员工调用打卡器的这个函数来进行打卡。 如果有人不爽，非要定义在员工类里面呢？你可以这么干。不过，后来需求改变成：非员工，比如保洁人员，也需要每天打卡签到。这时候，那位非常有个性有特色的人，估计脑瓜子嗡嗡的了吧。 单一职责不仅可以用在类（文件）里面，也可以用在函数里面。 比如，现在需要写一个校验函数，校验用户的性别和年龄，必须是 18 岁及以上的男性才有资格，很简单的我们可以这么写： public static boolean checkSexAndAge(boolean isMan, int age){ return isMan \u0026\u0026 age \u003e= 18; } 使用： private void login(){ if(checkSexAndAge(false, 17)) { tips(\"不是 18 岁以上的男性\") return; } } 这里有人有意见了，说这样写不太好，因为每个校验的地方都要自己弹出提示，这样就是很多重复的代码，所以提示这个逻辑应该放在checkSexAndAge()这个函数里面去，也就是下面这样： public static boolean checkSexAndAge(boolean isMan, int age){ if(isMan \u0026\u0026 age \u003e= 18) return true; tips(\"不是 18 岁以上的男性\"); return false; } 这样简直美滋滋，任何时候只要直接调checkSexAndAge()就行，判断了还自带提示。这在目前当然是完美的，虽然方法名不太合适。 如果有一天，我们的需求变成了：年龄不满足就开启未成年人保护模式，不需要弹出提示。我们直接删除tips()这个调用吗？这样不太好，如果别的地方也调用了这个方法，并且需要提示，就完了。所以我们应该有两个方法：方法 A 只检测，方法 B 使用 A 的检测结果并弹出提示。代码如下所示： // 判断加提示 public static boolean checkAndTips(boolean isMan, int age) { if(!checkSexAndAge(isMan, age)) { tips(\"不是 18 岁以上的男性\"); return false; } return true; } // 新方法，只做逻辑判断 public static boolean checkSexAndAge(boolean isMan, int age){ return isMan \u0026\u0026 age \u003e= 18; } 这里我们只抽离了一个方法，但是却反映出了单一职责的好处：职责越单一，因为修改而引起的问题就越少。换句话说就是：需求的粒度跟单一职责的优势成正比，需求越详细，越能看出单一职责的好处。所以我们要尽量避免大方法、大类、大模块，因为一个类越大，涉及的东西就越多，用到它的地方就越多，那么这个类就不能轻易修改，因为一旦修改，涉及的地方就越多，就越危险，所以我们一定要尽量避免。其实 MVC 就是一个宏观的、大的单一职责思想。 单一职责不仅适用于类和文件，还适用于函数、模块等，这是一种思想，一定要掌握。 2 里氏置换原则（LSP） 里氏置换原则（Liskov Substitution Principle，简称 LSP）：凡是使用基类的地方都必须能透明地使用子类。 用人话说就是：用子类替换父类不会改变原有逻辑。众所周知，面向对象有三大基本原则：封装、继承和多态。子类本来就继承了父类，用到父类的地方替换成子类肯定没问题啊，这个原则不是废话吗，不一定！因为子类有自己的特色，也就是多态，如果这个特色太特色的话，就不适合了。 比如，“我用电脑工作和游戏”，改成“我用苹果电脑工作，用联想电脑打游戏”，没问题！ 但是如果“我开车上班，坐车下班”，改成“我开玩具车上班，坐遥控车下班”，这个可能吗？ 但是，玩具车和遥控车也是“车”的子类啊，它俩也是车啊。 那么这个问题出在哪里呢？明明所有的定义都是 OK 的。这是因为子类太特色了。 我们定义的车，其出发点是“能跑”，也就是说，只要能跑的都是“车”，都是它的子类，所以，玩具车和遥控车都能跑，也都是车的子类。但是，车都能载人吗？猛一看，都能！仔细一想，玩具车不能！所以，我们上述 Demo 中用到的是车的“载人”功能，而不是车的“能跑”功能，所以，玩具车就不合适了。 那么，怎么改呢？有如下两种方法： 提取一个可载人的接口 interface IManned，明确表示哪些车可以载人； 提取一个二级父类 class MannedCar，表示该类车可以载人。 公共点就是：把“可载人”这个点明确出来。 所以，里氏置换更简洁的说法就是：子类可以有自己的特色，但是不能太反常，如果子类的特色跟父类差太多，那么就应该细化父类或者剥离接口。 可以看到，里氏置换原则就是对继承的校验，不恰当的继承关系就不满足里氏置换原则，所以，如果我们无法确定某两个类之间是否应该用继承关系时，就可以套用里氏置换原则来校验下。 3 依赖倒置原则（DIP） 依赖倒置原则（Dipendence Inversion Principle，简称 DIP）：面向接口编程或面向抽象编程。 依赖倒置的官方定义：高层不应该依赖底层，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象。其实狭义的说就是：面向接口编程，广义的说就是：面向抽象编程。也就是说，我们在使用类的时候，优先考虑使用抽象类或接口。具体一点就是：成员变量、函数参数和返回值都尽量定义成接口。 为什么要这么干呢？这么干有什么好处呢？ 我们知道，接口都是抽象的，抽象的就是不确定的，不确定的就是可变的。而我们的大部分代码都是“非一次性的”，也都是需要改变的，所以，接口正合适。 换句话说，接口就是具有某种功能的某种东西，是什么我不管，只要具有这种功能就行，而我们需要的，也就是具有这种功能的东西。 比如，我需要给手机充个电，我需要的是一个“能充电的东西”，而你却对外说：“我需要个充电宝！”如果有人没有充电宝，只有电源呢，他就不认你了。在这里，你把我需要的东西具象化了，也就是把范围缩小了，范围越小越精确，就越不容易改变，这明显是不对的。 再比如，现在我要提供一个音乐播放器，我直接使用移动端的 MediaPlayer，很容易就写出了如下代码： class MediaPlayer { public void play(String path) {} public void stop(){} public void pause(){} public void resume(){} } 三分钟就写完了，使用方直接调用： class User { private MediaPlayer mediaPlayer; public void play(){ mediaplayer.play(\"xxx\"); } } 完事之后某一天，主管又问：“咱们的播放器不好用，能用那个开源的吗？” 当然可以，于是就去改，但是发现，要改的地方太多了，我不但要改MedidPlayer这个类，甚至调用我播放器的人","date":"2024-06-09","objectID":"/posts/design-principles/:0:0","tags":["Design Patterns","Java"],"title":"架构之基：从根儿上了解设计原则","uri":"/posts/design-principles/"},{"categories":["CSS"],"content":"在做博客顶部栏下落奶油图的时候，就在想怎么适配暗黑模式和明亮模式呢？本文将记录两个思路。 9 方案一：通过模板生成两张图片 这是最容易想到的，也是我最初的想法，通过两张图片来实现暗黑模式和明亮模式的切换。 假设我们已经有了两张图片，drop.min.svg 和 drop-dark.min.svg，那么我们可以通过 CSS 来实现切换： #header-desktop { \u0026::after { background-image: url(/images/drop.min.svg); } [data-theme='dark'] \u0026 { background-image: url(/images/drop-dark.min.svg); } } 再创建一个模板文件 drop.template.svg： {{- $color := cond .isDark \"#252627\" \"#e6e5f8\" -}} \u003csvg viewBox=\"0 0 778.95 302.64\" xmlns=\"http://www.w3.org/2000/svg\"\u003e \u003cpath d=\"m28 14.56h778.71c-8.44 1.45-18.8 3-29.06 5-13.35 2.63-25.55 8.28-37.25 15-9.4 5.44-15.62 13.66-19.51 23.52-8.79 22.33-10 45.36-6 68.89 2.21 13.09 4.06 26.26 5.47 39.45a36.37 36.37 0 0 1 -1.59 13.5c-1.76 6.12-6.65 9.46-12 9.4s-9.52-3.32-11.77-9.32c-3.27-8.7-3.39-17.75-2-26.7 3-18.85 5.71-37.7 4.73-56.86a46.33 46.33 0 0 0 -1.6-9.56c-1.36-5.06-3.63-9.74-9.74-10s-10.86 2.71-13.77 8.06c-5 9.18-5.52 19.16-4.79 29.32.76 10.6 2 21.21 2 31.81 0 5.9-1.82 11.95-3.68 17.65s-6.11 8.1-11.52 7.92c-5-.17-8.76-3.08-10.72-8.53-2.42-6.69-1.42-13.44 0-20.13 2.61-12 5.78-23.85 7.89-35.92 2.43-13.92 3.11-27.94-2.19-41.55-4.23-10.85-14.09-12.81-21.12-3.56a61.82 61.82 0 0 1 -18.93 16.39c-3.95 2.27-7.46 5.32-11.13 8.07-7.31 5.46-13.69 4.33-18.88-3.22-5.52-8-9-16.89-11.55-26.27a56.4 56.4 0 0 0 -4.49-12c-3.1-5.81-9.92-6.05-12.45-.07a62 62 0 0 0 -4.39 18.75c-1.64 19.65 3.05 38.79 5.56 58.1.68 5.24.44 10.61.49 15.92a10.44 10.44 0 0 1 -.83 3.43c-1.68 4.76-5.19 7.58-9 7.29s-7.57-4-7.63-9.07c-.09-7.8.77-15.61 1-23.42s.69-15.38.32-23c-.19-3.87-1.42-8.17-6.18-9.32a8.82 8.82 0 0 0 -10.4 5.05c-3 6.5-6.06 13.34-7.05 20.33-3.34 23.67-2.93 47.47-.37 71.23 2.06 19.08 4.48 38.13 6.07 57.25 1.1 13.29.43 26.63-3.49 39.55a30.52 30.52 0 0 1 -3.69 8c-4.75 7.12-13 7.49-18.15.65a28.17 28.17 0 0 1 -4.42-9.55c-4.22-15.75-3.16-31.62-.46-47.48 4.92-29 11.36-57.79 9.32-87.49-.87-12.69-3.56-24.86-11.22-35.45-5.59-7.73-12.08-10.24-20.8-6.34-8 3.55-15.42 4.52-24 2.25-8.4-2.23-16.74 3.72-20.65 13.16-4.89 11.8-4.15 24-2.15 36.22 1.35 8.29 3.32 16.52 1.46 25-1.65 7.55-5.75 12.08-11.15 11.76s-9.66-5.63-9-13.27c.81-9.36 2.87-18.62 4.68-27.87 2-10.34 4.32-20.77 2-31.18-1.3-5.86-4.33-11.49-7.4-16.74-1.31-2.25-4.51-3.84-7.19-4.76-6.55-2.24-11.76 1.36-11.86 8.29-.07 4.84.91 9.68 1.25 14.54a73 73 0 0 1 .33 11.91c-.55 5.75-4.3 9.55-9.36 10.42-4.85.83-10.69-2-12.48-7.22a27 27 0 0 1 -1.22-12c1.62-11.68 4.51-23.21 5.7-34.92.64-6.26-.52-13-2.12-19.14-1.86-7.18-9.18-10.05-16-7a53.2 53.2 0 0 0 -8.63 5.33c-2.77 2-5.25 4.35-8 6.35-7 5.13-11.33 4.93-18.63.1-3.4-2.25-7.09-4.61-11-5.49-14.83-3.34-25.13 5.83-25.77 22.26-.71 18.29.73 36.32 5.61 54 1.64 6 .52 11.74-2.34 17.18-3.89 7.4-9.56 10.74-15.92 9.39-5.95-1.27-11.29-7.9-11-15.5.35-9 2-17.87 2.82-26.83.58-6.59 1.46-13.31.8-19.83-1-10.3-8.28-14.9-18.33-12.24-14.63 3.87-24.42 11.86-27.78 28-4.53 21.8-3.6 43.53-2.49 65.36 1.36 26.85 9.17 52.61 13.89 78.9 2.22 12.38 3.17 25.1-1.34 37.26-1.46 3.94-4.1 8.12-7.4 10.58-10 7.42-22.1 2.86-23.9-9.4a110.27 110.27 0 0 1 -.57-30c3.9-29.74 9.37-59.37 8-89.47-1-22.07-1.74-44.34-8.78-65.68-3.29-10-8.3-18.25-18-23.72-5.32-3-9.91-7.88-13.77-12.76-4-5.1-8.66-8-15-7.87a52.19 52.19 0 0 0 -11 1c-14 3.26-23.37-3.18-30.62-14.24-2.06-3.41-3.85-7.19-6.43-10.41-15-18.79-35-29.58-58.16-34.93-1.69-.39-3.39-.76-5.08-1.13z\" transform=\"translate(-27.76 -14.56)\" /\u003e \u003c/svg\u003e 然后，我们可以通过 Hugo 的模板引擎来生成两张图片： {{- $template := resources.Get \"images/drop.template.svg\" -}} {{- $resource := ($template | resources.ExecuteAsTemplate \"images/drop.svg\" (dict \"isDark\" false) | minify).RelPermalink -}} {{- $resourceDark := ($template | resources.ExecuteAsTemplate \"images/drop-dark.svg\" (dict \"isDark\" true) | minify).RelPermalink -}} 这样，我们就得到了暗黑模式和明亮模式的两张图片，正如现在博客所看到的一样。 10 方案二：通过 CSS 实现响应式 然后，我在想这两张图除了背景色，其他都一毛一样，能不能通过 CSS 来实现呢？ 一番尝试过后，答案是肯定的。 假设我们只有一张图片，drop.responsive.svg，还是通过 CSS 来实现切换： #header-desktop { \u0026::after { background-image: url(/images/drop.responsive.svg); } [data-theme='dark'] \u0026 { background-image: url(/images/drop.responsive.svg#drop-dark-only); } } 再创建一个 SVG 文件 drop","date":"2024-06-06","objectID":"/posts/svg-dark-light/:0:0","tags":["CSS","SVG","hugo"],"title":"怎么生成暗黑模式和明亮模式的 SVG 图片？","uri":"/posts/svg-dark-light/"},{"categories":["瞎折腾"],"content":"在开发和部署网站时，经常会遇到加载外部资源较慢的问题。其中之一就是加载 Gravatar 头像图片时可能会受到网络延迟的影响。为了解决这个问题，我们可以利用 Vercel 平台的反向代理功能来实现镜像加速。 1 思路 解析请求的 URL，并将其 host 修改为我们要代理的目标域名（这里是 www.gravatar.com）。 获取原始请求的方法、头部信息，并创建一个新的请求头部对象。 将新请求头部对象中的 Host 字段设置为目标域名，并将 Referer 字段设置为原始请求的 URL。 使用修改后的 URL、方法和头部信息发送请求到目标域名。 获取原始响应的状态码、头部信息和响应体，并克隆原始响应对象。 检查请求的 Referer 来源域名是否合法，如果不合法则返回一个 403 Forbidden 的响应。 设置新的响应头部信息，包括允许的请求方法、请求头部和缓存控制策略。 构造最终的响应对象，其中响应体为原始响应的内容，状态码和头部信息为修改后的值。 返回最终的响应对象。 安装上面的思路，理论上我们可以反代任何一个网站，并且支持设置 CORS 策略。GitHub 上也有类似的项目，比如 https://github.com/gaowanlu/google. 当然，网络不是非法之地，不要滥用这个功能反代一些不合法的网站哦。 2 实现 ⬆️ https://gravatar.lruihao.cn/avatar/fee47a2f4f2cc71f99a02b0a73ecfee0?s=64 实现 API 代码： const allowedReferrers = [ \"lruihao.cn\", \"gravatar-x.vercel.app\", \"-lrh-dev.vercel.app\", \"-cell-x.vercel.app\", \"localhost\", ]; const upstream = \"www.gravatar.com\"; /** * whether the hostname is allowed * @param {String} hostname * @returns */ function isAllowedHost(hostname) { const regExp = new RegExp(allowedReferrers.join(\"|\"), \"g\"); // if hostname matches allowed referrers if (!hostname || regExp.test(hostname)) { return true } for (const referrer of allowedReferrers) { // if hostname ends with allowed referrers if (hostname.endsWith(referrer)) { return true } } return false } async function fetchAndApply(request) { let response = null; let url = new URL(request.url); url.host = upstream; let method = request.method; let request_headers = request.headers; let new_request_headers = new Headers(request_headers); new_request_headers.set(\"Host\", upstream); new_request_headers.set(\"Referer\", url.href); let original_response = await fetch(url.href, { method: method, headers: new_request_headers, }); let original_response_clone = original_response.clone(); let original_text = null; let response_headers = original_response.headers; let new_response_headers = new Headers(response_headers); let status = original_response.status; const hostname = (() =\u003e { try { return new URL(request.headers.get(\"Referer\")).hostname; } catch (e) { return \"\"; } })(); if (!isAllowedHost(hostname)) { return new Response(`403 Forbidden: ${hostname}`, { headers: { \"Content-Type\": \"text/html\" }, status: 403, statusText: \"Forbidden\", }); } // new_response_headers.set(\"access-control-allow-origin\", \"https://lruihao.cn\"); new_response_headers.set(\"Access-Control-Allow-Methods\", \"GET, POST, OPTIONS\"); new_response_headers.set(\"Access-Control-Allow-Headers\", \"Content-Type\"); new_response_headers.set( \"Cache-Control\", \"max-age=600, s-maxage=2592000, stale-while-revalidate\" ); new_response_headers.delete(\"link\"); original_text = original_response_clone.body; response = new Response(original_text, { status, headers: new_response_headers, }); return response; } export const config = { runtime: \"experimental-edge\", }; export default function (req) { return fetchAndApply(req); } 配置 vercel.json 文件： { \"rewrites\": [ { \"source\": \"/avatar/(.*)\", \"destination\": \"api/gravatar\" } ] } 最后部署到 Vercel 平台即可。 3 源码 Lruihao/vercel-gravatar Public archived Gravatar Proxy powered by Vercel. JavaScript 2 1 ","date":"2024-04-17","objectID":"/projects/vercel-gravatar/:0:0","tags":["Vercel","Gravatar"],"title":"利用 Vercel 反代 Gravatar 实现镜像加速","uri":"/projects/vercel-gravatar/"},{"categories":["GitHub"],"content":"Lruihao/vercel gravatar: Gravatar Proxy powered by Vercel.","date":"2024-04-17","objectID":"/projects/lruihao/vercel-gravatar/","tags":["gravatar","vercel"],"title":"Gravatar Proxy powered by Vercel.","uri":"/projects/lruihao/vercel-gravatar/"},{"categories":["GitHub"],"content":"Vercel Gravatar 注意 Superseded by Lruihao/vercel-proxy. Gravatar Proxy powered by Vercel. Go to test Gravatar: https://gravatar.lruihao.cn/avatar/ https://gravatar-x.vercel.app/avatar/ ","date":"2024-04-17","objectID":"/projects/lruihao/vercel-gravatar/:0:0","tags":["gravatar","vercel"],"title":"Gravatar Proxy powered by Vercel.","uri":"/projects/lruihao/vercel-gravatar/"},{"categories":["GitHub"],"content":"hugo fixit/component projects: 🐙 Display your GitHub projects in the FixIt theme and generate blog posts from readme.","date":"2024-04-09","objectID":"/projects/hugo-fixit/component-projects/","tags":["hugo","hugo-fixit","shortcodes","theme-component"],"title":"🐙 Display your GitHub projects in the FixIt theme and generate blog posts from readme.","uri":"/projects/hugo-fixit/component-projects/"},{"categories":["GitHub"],"content":" GitHub Projects Embed | FixIt 在 FixIt 主题中展示你的 GitHub 项目并根据 README 自动生成博客文章。 简体中文 | 繁體中文 | English | Français | Русский язык | Español | हिन्दी | deutsch | 한국어 | しろうと Demo 生态系统 | FixIt Lruihao 的开源项目 特性 支持 GitHub 项目卡片展示（layout 或者 shortcodes） 支持根据 README 自动生成博客文章（content adapter） 要求 FixIt v0.4.0 或更高版本 安装 安装方法与 安装主题 相同。有几种安装方法，请选择一种。 安装为 Hugo 模块 首先确保你的项目本身是一个 Hugo 模块。 然后将此主题组件添加到你的 hugo.toml 配置文件中： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" [[module.imports]] path = \"github.com/hugo-fixit/component-projects\" 在第一次启动 Hugo 时，它将下载所需的文件。 要更新到模块的最新版本，请运行： hugo mod get -u hugo mod tidy 安装为 Git 子模块 将 FixIt 和此 git 存储库克隆到你的主题文件夹中，并将其添加为网站目录的子模块。 git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt git submodule add https://github.com/hugo-fixit/component-projects.git themes/component-projects 接下来编辑项目的 hugo.toml 并将此主题组件添加到你的主题中： theme = [\"FixIt\", \"component-projects\"] 配置 最后，为了通过 FixIt 主题在 layouts/_partials/custom.html 文件中开放的 自定义块 将 component-projects.html 注入到 custom-head 或 custom-assets 中，你需要填写以下必要配置： [params] [params.customPartials] # ... other partials assets = [ \"inject/component-projects.html\" ] # ... other partials 访问令牌（可选） 获取仓库信息依赖 GitHub 官方 API。在开始使用之前，建议在 GitHub 上生成个人访问令牌，以防止 GitHub API 使用限制。 点击跳到 GitHub 生成 token，选择名为 public_repo 的范围以生成个人访问令牌。 配置环境变量 HUGO_PARAMS_GHTOKEN=your-person-access-token，详细信息请参见 os.Getenv | Hugo 使用 布局 首先，创建 projects.yml 文件并编辑数据： cp themes/component-projects/projects.yml.example data/projects.yml 如果你的网站是多语言的，你可以为英语创建一个 projects.en.yml 文件，为中文创建一个 projects.zh-cn.yml 文件。 接下来，使用 projects 布局创建一个新页面： hugo new projects/_index.md 编辑新页面的标题和内容： --- title: My Projects titleIcon: fa-solid fa-laptop-code subtitle: \u003chttps://github.com/Lruihao\u003e sectionSlot: Some text to display in the section slot which is above the related articles list. hiddenAdapters: false layout: projects --- Some text to display at the start of the page. Shortcodes 在任何页面中使用 gh-repo-card-container 和 gh-repo-card 短代码来显示卡片式 GitHub 存储库： {{\u003c gh-repo-card-container \u003e}} {{\u003c gh-repo-card repo=\"hugo-fixit/component-projects\" \u003e}} {{\u003c gh-repo-card repo=\"Lruihao/hugo-blog\" \u003e}} {{\u003c /gh-repo-card-container \u003e}} 内容适配器 🎉 这是一个很棒的功能！它能够根据你配置的项目数据，把仓库的 README 自动生成博客文章。 在项目文件夹中创建 _content.gotmpl，添加以下代码： {{- partial \"adapters/projects.html\" . -}} 目录结构如下： content/ ├── projects/ │ ├── _content.gotmpl \u003c-- content adapter │ └── _index.md \u003c-- layout: projects data/ └── projects.yml \u003c-- projects data 然后，打开 hugo.toml 文件，配置的 projectsAdapters 选项，启用内容适配器： [params] [params.projectsAdapters] enable = true onlyPublic = true categories = [] collections = [] ignoreList = [] [params.projectsAdapters.params] hiddenFromHomePage = true # more font matter here ... 自定义块 你可以通过 define 来实现这些块。 块名称 描述 projects-aside 显示在项目页面的侧边栏中 projects-meta 显示在项目页面的开始处 projects-footer 显示在项目页面的底部处 定时任务 由于采用服务端渲染，所有数据是在构建时获取的，而不会在每次访问时都请求 GitHub API。因此，我们可以使用定时任务来更新数据，从而保持其最新状态。 部署到 GitHub Pages 如果你的网站托管在 GitHub Pages 上，你可以使用 GitHub Actions 自动部署。 name: Hugo build and deploy on: schedule: # Rebuid the site every day at 00:00 UTC to update the projects data - cron: '0 0 * * *' push: branches: [ main ] workflow_dispatch: jobs: # Your build and deploy jobs here 部署到 Vercel 如果你的网站托管在 Vercel 上，你可以使用 Vercel 的 Deploy Hooks 功能配合 GitHub Actions 自动部署。 name: Vercel deploy hook on: schedule: # Rebuid the site every day at 00:00 UTC to update the projects data - cron: '0 0 * * *' jobs: Vercel-Deploy: runs-on: ubuntu-latest steps: - name: Trigger Vercel deploy hook run: | curl -X POST ${{ secrets.VERCEL_DEPLOY_HOOK }} 在 Vercel 的项目设置中，创建一个部署钩子，并在 GitHub 项目的 Secrets 中添加 VERCEL_DEPLOY_HOOK 变量。 故障排除 本地调试时，可以在 hugo server 命令后加上 --ignoreCache 参数以清除缓存。 ","date":"2024-04-09","objectID":"/projects/hugo-fixit/component-projects/:0:0","tags":["hugo","hugo-fixit","shortcodes","theme-component"],"title":"🐙 Display your GitHub projects in the FixIt theme and generate blog posts from readme.","uri":"/projects/hugo-fixit/component-projects/"},{"categories":["Vue.js","JavaScript"],"content":"开发完 CoverView之后，在调整博客文章封面图的时候，我发现首页的多端缩略图还是只能自己 P 图诶，于是我又决定再写一个小工具，用来生成网站预览图。。 1 在线体验 vue-el-demo#apple-devices-preview 源码 2 实现原理 实现原理很简单，就是先写好布局，然后每个设备里面套一个 iframe，然后通过 iframe 的 src 属性来加载网页。 3 卡壳点 iframe 存在跨域问题。 在将 DOM 转图片的时候，iframe 里面的内容无法转换，尝试了 html2canvas 和 dom-to-image-more 都不行，放弃了，改为用浏览器插件 Fireshot 截图。 一个未尝试的思路，如果跨域问题得以解决，转换图片的步骤可以分解为： 拿到每个 iframe 里的 body 内容，转为图片，然后将图片相对定位到对应的设备 iframe 里 隐藏原来的 iframe 最后将父容器的 DOM 转为图片 4 效果图 输入不同设备的 URL，选择背景颜色，点击预览，然后自行截图即可，比如用 Fireshot 插件捕获可见区域。 ","date":"2024-04-04","objectID":"/projects/apple-devices-preview/:0:0","tags":["Vue2"],"title":"临时决定再写一个小工具 - 网站预览图生成器","uri":"/projects/apple-devices-preview/"},{"categories":["React"],"content":"🛠 Create awesome cover images for your blog posts quickly.","date":"2024-04-02","objectID":"/projects/coverview/","tags":["CoverView","React"],"title":"用五天时间给自己制作一个封面图生成工具","uri":"/projects/coverview/"},{"categories":["React"],"content":" Cool! 苦封面图久矣，今日终有所成。 1 心路历程 写博客一直都懒得配图，主要是除了截图一直懒得找素材，然后还得考虑压缩等，直到心血来潮写文档时加上了封面图，发现效果还不错，就开始思考如何快速地搞定封面图，经历了以下几个阶段： Google 搜图：最开始的时候，直接 Google 搜图，然而很难找到合适的图片。 手动制作：然后开始用 Excalidraw 制作，但是每篇文章都要重新画，太麻烦了。 稿定: FixIt 主题群群友推荐了 稿定，可以快速生成封面图，但是要付费啊，受不了一点。 原 CoverView：最后还是 FixIt 主题群群友又推荐了 CoverView，哎！这个可以，但是样式有点跑版，还有图片无法下载等诸多 BUG，主要还无法适配 Hugo FixIt 主题的封面尺寸。 自己写：既然 CoverView 是开源的，那就先克隆一份，自己改改啰。 为什么封面图片比你想象的更重要？ 每天约有 700 万篇博文被发表。随着新时代博客工具的兴起，这个数字还会持续上升。一个好的封面图片比随机的库存图片能带来更高的转化率。 2 项目介绍 该项目基于原项目 CoverView 修改而成，感谢原作者 Rutik Wankhade 的优秀作品，我又连夜花了五天时间，做了如下改动和优化： 修复了带有图案背景的图片无法下载的问题 修复了无法下载和上传 SVG 格式图标的问题 修复了移动端样式混乱的问题 修复了重置所有按钮功能异常的问题 添加了 ESLint 支持 添加了 I18n 支持 增强了 Unsplash 图片搜索功能 添加了下载图片格式选择（PNG/JPEG），并支持 JPEG 图片质量调整 优化了图片下载速度 优化了 Devicons 以多色 SVG 图标显示 添加了更多字体和平台支持 统一了不同主题下载图片的大小 以及更多 … 至此已经足以让我感到满足和使用了，当然还有一些正在开发或者尝试开发的需求： 支持复制到剪切板和从剪切板上传截图 #8 尝试实现拖拽文本或者图标 #9 设置自定义平台封面图片的宽高比、适配常用尺寸宽高比 #10 现在 demo 版本已经上线，Unsplash API 的 production 版本还在审核中，最后传承开源精神开源出来，并保留了原作者 commit 记录聊表敬意。 🛠 Create awesome cover images for your blog posts quickly. https://github.com/Lruihao/CoverView 3 如何使用 可以看到，本文的封面图就是它生成的，很快啊！我当时大意了！没有闪！（玩个梗😂） 在线使用地址： https://coverview.lruihao.cn https://coverview-x.vercel.app 添加博客文章的标题和作者 自定义颜色、字体、图标等 从不同的主题中选择 点击下载按钮，即可下载封面图 有了简单、快速、易用的 CoverView，为博客创建封面图片现在变得非常容易，这样大家就可以专注于撰写博客，而不必担心封面图片了。 4 图片压缩 关于图片压缩问题，当时在开发之初 #9，是准备增加下载为 WebP 格式的功能，但是由于没找到合适的实现库，所以很遗憾没有实现，可手动通过 Cwebp 工具转换。 例如： cwebp -q 50 cover_*.jpeg -o cover.webp cwebp -q 50 -lossless cover_*.png -o cover_lossless.webp 幸运的是，我增加了下载为 JPEG 格式的功能，可以在下载时调整图片质量，以减少图片大小。 比如上面这张图片，选择 JPEG 格式，图片质量选择 50%，下载下来的体积仅仅 70kb，wow! 太棒了！只需要简单输入，然后轻轻一点。 当然啦，可以找压缩工具进行压缩，例如：TinyPNG，它可以帮助你快速压缩图片，减少图片大小，提高网站加载速度。 5 收获 为了这个完善开发这个工具，先顺手学了一下 React，发现其实入门上手也很简单。 就这样，我又多了一个得心应手的工具 🛠️。 ","date":"2024-04-02","objectID":"/projects/coverview/:0:0","tags":["CoverView","React"],"title":"用五天时间给自己制作一个封面图生成工具","uri":"/projects/coverview/"},{"categories":["GitHub"],"content":"Lruihao/CoverView: 🛠 Create awesome cover images for your blog posts quickly.","date":"2024-03-28","objectID":"/projects/lruihao/coverview/","tags":[],"title":"🛠 Create awesome cover images for your blog posts quickly.","uri":"/projects/lruihao/coverview/"},{"categories":["GitHub"],"content":"CoverView 👉 简体中文说明 | English README 该项目基于原始的 CoverView。 现在为你的博客创建封面图片变得非常简单。 💥 变更通知 自 2024 年 03 月 28 日起，已将原始的 CoverView 复刻到我的存储库，并进行了以下更改和增强： 修复了具有图案背景的图像无法下载的问题 修复了无法下载和上传 SVG 格式图标的问题 修复了移动端样式混乱的问题 修复了 重置所有 按钮功能异常的问题 添加了 ESLint 支持 添加了 I18n 支持 增强了 Unsplash 图像搜索功能 添加了下载图像格式选择（PNG/JPEG/SVG/Blob），并支持 JPEG 图像质量调整 优化了图像下载速度 优化 Devicons 以多色 SVG 图标显示 添加了更多字体和平台支持 统一了不同主题下下载图像的尺寸 等等… ⚡ 特性 🚀 超快速且易于使用 🌈 7 种不同主题，多种字体 🌠 100+ 开发图标，并提供上传自定义图标选项 ✨ 15+ 种不同背景图案 💾 基于博客平台或常用尺寸的封面大小 Hashnode Dev.to Hugo FixIt 稀土掘金 👩‍💻 开发 本项目主要使用以下技术栈： React 19 Tailwind CSS Vite 下载项目并安装依赖： git clone https://github.com/Lruihao/CoverView.git cd CoverView/ pnpm i 从 Unsplash API 获取访问密钥。 在 .env.local 文件中添加 REACT_APP_UNSPLASH_ACCESS_KEY 环境变量。 # https://unsplash.com/ Access Key REACT_APP_UNSPLASH_ACCESS_KEY=\"your_access_key_here\" 运行以下命令开始项目： pnpm dev 👇 贡献 欢迎提交拉取请求。对于重大更改，请先打开一个问题来讨论你想要更改的内容。 克隆它 (https://github.com/Lruihao/CoverView/fork) 创建你的功能分支 (git checkout -b feature/fooBar) 提交你的更改 (git commit -am 'Add some fooBar') 推送到分支 (git push origin feature/fooBar) 创建一个新的拉取请求 🙏 致谢 Rutik Wankhade（原始 CoverView） dom-to-image-more Hero Patterns Devicons Font Virgil Font MMT 如果你觉得这个项目有用，请别忘了留下一个 ⭐。 ","date":"2024-03-28","objectID":"/projects/lruihao/coverview/:0:0","tags":[],"title":"🛠 Create awesome cover images for your blog posts quickly.","uri":"/projects/lruihao/coverview/"},{"categories":["Memo"],"content":"对于本文的标题的思考来自于 Hugo 配置文档中的一个配置 titleCaseStyle，默认情况下，Hugo 在创建自动章节标题以及使用 strings.Title 函数转换字符串时遵循美联社样本中发布的大小写规则。 但是这似乎和我高中所学的英文标题大小写规则有所出入，我记得我的高中英语老师教的是虚词不需要大写的，而不是美联社风格的每个单词都首字母大写。 经过一番查阅，以下部分内容引用北京师范大学 - 出版科学研究院的一篇文章，“出版物中，英文什么时候要大写？ ”。 1 标题中的大写规则 1.1 英式英语 文章标题一般只第一个单词的首字母大写，主副标题均是。 例如：China Daily《中国日报》的文章标题均第一个单词首字母大写。 China’s panda protection bears fruit amid 150th anniversary of discovery. 1.2 美式英语（比较常见） 标题的第一个单词，无论是实词还是虚词，首字母要大写。 实词首字母要大写，比如名词、动词、形容词、副词、代词等。 虚词推荐使用小写，除非在标题的第一个单词，比如冠词、介词、连词、感叹词等。 满 5 个字母的虚词可以大写，不满 5 个字母的不得大写，满 7 个字母的虚词（through）则在标题或条标中必须大写。 还有一种说法：虚词字母多于 3 个（不含 3）时首字母大写。 例如： The Visual Arts and the Catholic Reformation 视觉艺术与天主教改革 看到这里和我高中所学的规则是一致的，终于对上了。另外这种风格对应的就是 Hugo 的 titleCaseStyle 配置项的 chicago，Chicago Manual of Style（应该是吧 :D） 2 句子的大写规则 句子开头的第一个字母要大写。“I（我）”在句中任何位置都要大写。 例如：Mary and I are teachers． 直接引语中，句首字母要大写。 例如：“Then,” I said, “You have been making a mistake, and the letter is not in the apartment.” 诗歌每一行的第一个单词的首字母要大写。 3 专有名词、缩略词及其他大写情况 国名、地名、人名、艺术作品、船只、航空器等专有名词首字母要大写。 例如：Russia（俄罗斯），Youyang（酉阳），Chengdu（成都），Jack（杰克） 由普通名词构成的专有名词词组，除其中的冠词、较短的介词和连词外，每个词的首字母都要大写。 例如：the Great Wall（长城），the United States（美国） 表示语种、民族的名词或形容词首字母要大写。 例如：Russian（俄语、俄罗斯人的），Chinese（汉语、中国人的） 星期、月份名称的首字母要大写，但季节名称首字母不大写。 例如：Sunday 星期天，August 八月（星期、月份大写） winter 冬天，spring 春天（季节不大写） 一些大型节日名称的第一个实词的首字母大写。 例如：Children’s Day 儿童节，National Day 国庆节，Teachers’ Day 教师节 大型会议、文件、条约、组织机关、学校等名称中的每个实词的首字母都要大写，这些名称的缩略词也大写。 例如：Conference of Asia and Africa 亚非会议 World Trade Organization 世界贸易组织（WTO） Beijing Normal University 北京师范大学（BNU） 书名、报刊名中的每个实词的首字母应大写（且用斜体）。 New York Times《纽约时报》 English Coaching Paper《英语辅导报》 south，north 等方位名词一般小写，但形成专有名词时要大写。 例如：South Africa（南非），North Carolina（北卡罗莱纳州） 一些亲属关系（如 mother，sister，mum，dad 等）用作称呼语时首字母要大写。 例如：Thank you, Granny．谢谢你，奶奶。 人名前的称呼，以及头衔、职务的词首字母要大写。 例如：Mr Green 格林先生，Dr. Li 李博士 大多数的缩略词要大写。 例如：OK (Okay), CCTV (China Central Television) 由单词首字母构成的缩略词一般全部字母都大写，注意区分下列情况： who 谁 WHO (World Health Organization) 世界卫生组织 Project Hope 希望工程 Project HOPE (Health Opportunities for People Everywhere) 世界健康基金会（简称世健会） 4 全部字母大写 表示惊讶、感叹或强调时，部分单词会全部大写。 美术设计根据需要，书名会全部字母大写。 例如： LOOKING AHEAD ","date":"2024-03-26","objectID":"/posts/c6bc2d5/:0:0","tags":["English"],"title":"写文档时英文标题什么时候要大写？","uri":"/posts/c6bc2d5/"},{"categories":["Vue.js","JavaScript"],"content":"在 Element UI 的表格组件中，当表格列的内容过长时，设置 show-overflow-tooltip 会自动显示一个 tooltip 来展示完整的内容。这个功能在实际项目中也是非常常见的，那么我们该如何实现这个功能呢？ 1 Demo 先来看一下效果：demo 2 实现代码 直接贴上完整的代码，通过一个自定义指定 v-overflow-tooltip 来实现： const setTooltip = (el, binding) =\u003e { // 设置内容 el.innerText = binding.value const elComputed = document.defaultView.getComputedStyle(el, '') const padding = parseInt(elComputed.paddingLeft.replace('px', '')) + parseInt(elComputed.paddingRight.replace('px', '')) const range = document.createRange() range.setStart(el, 0) range.setEnd(el, el.childNodes.length) const rangeWidth = range.getBoundingClientRect().width const isEllipsis = rangeWidth + padding \u003e el.offsetWidth || el.scrollWidth \u003e el.offsetWidth // 鼠标移入时，将浮层元素插入到 body 中 el.onmouseenter = function(e) { if (!isEllipsis) { return } // 创建浮层元素并设置样式 const vcTooltipDom = document.createElement('div') Object.assign(vcTooltipDom.style, { position: 'absolute', background: '#303133', color: '#fff', fontSize: '12px', zIndex: '6000', padding: '10px', borderRadius: '4px', lineHeight: 1.2, minHeight: '10px', wordWrap: 'break-word', }) // 设置 id 方便寻找 vcTooltipDom.setAttribute('id', 'vc-tooltip') // 将浮层插入到 body 中 document.body.appendChild(vcTooltipDom) // 浮层中的文字 通过属性值传递动态的显示文案 document.getElementById('vc-tooltip').innerHTML = binding.value } // 鼠标移动时，动态修改浮层的位置属性 el.onmousemove = function(e) { if (!isEllipsis) { return } const vcTooltipDom = document.getElementById('vc-tooltip') const padding = 5 let offsetX = e.clientX + 15 let offsetY = e.clientY + 15 // 判断是否超出视窗边界（横向） if (offsetX + vcTooltipDom.offsetWidth \u003e document.documentElement.clientWidth) { offsetX = document.documentElement.clientWidth - vcTooltipDom.offsetWidth - padding } if (offsetX \u003c= 0) { offsetX = padding vcTooltipDom.style.width = document.documentElement.clientWidth - padding * 2 + 'px' } // 判断是否超出视窗边界（纵向） if (offsetY + vcTooltipDom.offsetHeight \u003e document.documentElement.clientHeight) { offsetY = document.documentElement.clientHeight - vcTooltipDom.offsetHeight - padding } if (offsetY \u003c= 0) { offsetY = padding vcTooltipDom.style.height = document.documentElement.clientHeight - padding * 2 + 'px' } vcTooltipDom.style.left = offsetX + 'px' vcTooltipDom.style.top = offsetY + 'px' // 注：当浮层元素和窗口大小差不多时，浮层会覆盖原本的内容，导致浮层闪一下就不见了 } // 鼠标移出时将浮层元素销毁 el.onmouseleave = function() { if (!isEllipsis) { return } // 找到浮层元素并移出 const vcTooltipDom = document.getElementById('vc-tooltip') vcTooltipDom \u0026\u0026 document.body.removeChild(vcTooltipDom) } } const plugin = { install(Vue) { Vue.directive('overflow-tooltip', { inserted: (el, binding) =\u003e { // 设置元素样式 Object.assign(el.style, { overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap', }) // 监控元素可见性变化 const observer = new IntersectionObserver((entries) =\u003e { if (entries[0].isIntersecting) { setTooltip(el, binding) } }) observer.observe(el) // 监控元素宽度变化 const resizeObserver = new ResizeObserver(() =\u003e { setTooltip(el, binding) }) resizeObserver.observe(el) // 设置浮层内容 setTooltip(el, binding) }, update: (el, binding) =\u003e { // 更新浮层内容 setTooltip(el, binding) }, unbind: (el) =\u003e { el.onmouseenter = null el.onmousemove = null el.onmouseleave = null }, }) } } let GlobalVue = null if (typeof window !== 'undefined') { GlobalVue = window.Vue } else if (typeof global !== 'undefined') { GlobalVue = global.Vue } if (GlobalVue) { GlobalVue.use(plugin) } export default plugin 使用很简单，导入并注册之后，就可以在需要的地方使用 v-overflow-tooltip 指令了： import overflowTooltip from '@/directives/overflow-tooltip' Vue.use(overflowTooltip) 比如说： \u003cspan v-overflow-tooltip=\"content\" style=\"display: inline-block; width: 100px;\" /\u003e 3 实现原理 通过 getComputedStyle 获取元素的 padding 值，然后通过 createRange 获取元素的宽度。 如果元素的内容宽度大于元素的宽度，那么就显示 tooltip。 鼠标移入时，将浮层元素插入到 body 中，鼠标移动时，动态修改浮层的位置属性，鼠标移出时将浮层元素销毁。（浮层需要做边界检测） 其中最关键的一段代码是： const range = document.createRange() range.setStart(el, 0) range.setEnd(el, el.childNodes.length) const rangeWidth = range.getBoundingClientRect().width 这段代码是通过 createRange 设置元素的范围，然后通过 getBoundingClientRect 获取元素的宽度。 ","date":"2024-02-29","objectID":"/posts/overflow-tooltip/:0:0","tags":["Vue2"],"title":"实现类似于 Element UI 表格的溢出文本提示功能","uri":"/posts/overflow-tooltip/"},{"categories":["HTML"],"content":"聊聊 Chrome 新增的 sizes=“auto” 属性。 1 前景 起因是网友给 FixIt 提了一个 issue hugo-fixit/FixIt#411，说图片比例异常，我一回想，最近没动过图片的代码，于是用 Safari 和 Edge 试了一下，发现没问题，那么基本可以确定是 Chrome 新版的问题了。 经查，从 Chrome (121.0.6167.85) 开始，给 img size=“auto” 加了一个默认样式，恰巧 FixIt 主题之前用到了 lazysizes.js 这个库来做图片懒加载，也用了 size=“auto” 这个属性，于是就导致图片宽高比异常了。 解决办法：既然 FixIt 并没有再使用 lazysizes.js 来做图片懒加载，那么就直接去掉 size=“auto” 这个属性就好了。 好，问题解决了，那么就来看看这个 size=“auto” 到底是什么。 2 简介 在网页开发中，我们通常会遇到需要对网页上的元素，尤其是图片进行布局和尺寸调整的情况。在 HTML 中，我们可以利用一些内置的属性来帮助我们完成这项工作，而 sizes 就是其中之一。sizes 属性定义了用于描述其中 \u003cimg\u003e、\u003csource\u003e 元素 display size，以及 \u003clink\u003e 元素 viewport 的 source 大小。换句话说，它是一种设定网页元素尺寸的机制。 编写、阅读和维护响应式图片的 sizes 属性是最繁琐的部分；对于懒加载的图片，auto-sizes 是对平台的一个很好的补充。据统计，目前已有十分之一的 sizes 属性正在使用 auto，但是是通过 lazysizes.js（一个用于支持图片懒加载的库）。 3 详解 sizes 支持了 “auto” 值，那么情况就会变得稍微有些复杂。所谓的 “auto” 模式，实际上是一种让浏览器自动设定图片尺寸的模式。在这种模式下，浏览器会试图选择最合适的尺寸来显示图片，以获得最佳的用户体验。它的应用场景主要是在网站设计和开发过程中，需要灵活设定元素尺寸，尤其是图片的尺寸，以便于在不同设备和浏览器环境下，都能呈现出良好的布局和视觉效果。 根据 HTML 规范 4.8.4.2.2 Sizes attributes 的提示： 注意 此外，强烈建议使用 width 和 height 属性或使用 CSS 来指定尺寸。如果没有指定尺寸，图像可能会以 300x150 尺寸渲染，因为在渲染部分 sizes==“auto” 中有所暗示。contain-intrinsic-size: 300px 150px Chrome 中打开调试台，可以看到默认样式： img:has([sizes=\"auto\" i], [sizes^=\"auto,\" i]) { contain: size !important; contain-intrinsic-size: 300px 150px; } 这段 CSS 代码使用了属性选择器来选择 img 元素，具体的选择规则如下： [sizes=\"auto\" i]：选择具有 sizes 属性且其值为 auto（不区分大小写）的 img 元素。 [sizes^=\"auto,\" i]：选择具有 sizes 属性且以 auto, 开头（不区分大小写）的 img 元素。 对于匹配上述选择规则的 img 元素，应用以下样式： contain: size !important;：将元素的内容缩放以适合其容器的大小，并禁止其他样式表覆盖此规则（!important 用于提升优先级）。 contain-intrinsic-size: 300px 150px;：指定元素的内在尺寸为宽度 300 像素和高度 150 像素。这可以影响到元素在执行缩放时的最终尺寸。 顺便说一下，CSS 中的伪类 :has 被称为“父选择器”，但目前并没有广泛支持，因此这个选择器可能无法在所有浏览器中正常工作。另外，i 标记表示进行不区分大小写的匹配。 响应式图像自然尺寸的设定可能会让人意想不到的复杂，但实际上： 有许多方式可以让已加载资源的自然尺寸影响其对应的 \u003cimg\u003e 的布局尺寸。 每当 \u003cimg\u003e 标签的布局尺寸发生变化，sizes=“auto” 的值就会进行更新，这可能会触发新的资源加载。 一旦加载新的资源，这个资源就会有新的自然尺寸，这可能会影响 \u003cimg\u003e 的布局尺寸，导致 sizes=“auto” 的值更新，然后可能会触发又一次的资源加载；新加载的资源会有新的自然尺寸，这样以此类推…等等。 关于 sizes=“auto” 的规范讨论其实主要就是：那些能通过这种方式让 srcset 中的每一个资源依次被加载的极端情况。 Simon Pieters，撰写了 auto-sizes 规范的人，曾经巧妙并勇敢地尝试定义可能触发循环依赖的所有情况，同时也采用了一些无法让作者察觉或是感到奇怪的解决方式来避开这些问题。但是，当真正落实到实现的时候，这些权宜之计并没有站住脚。最后，大家都认为唯一的解决方法是做出一个明确的切割：规定加载资源的自然尺寸绝对不能影响其所对应的 \u003cimg\u003e 的布局，这一点在涉及到 sizes=“auto” 时尤为重要。 幸运的是，我们有一个相对较新的特性，它就是“尺寸包含”（size containment），专门用来解决这个问题。 所以，现在 Chrome 的 UA stylesheet 中的内容就变成了上面那段 CSS 代码的样子。 对于为什么选择 300×150，是因为这就是 \u003cvideo\u003e 和 \u003ccanvas\u003e 标签所采取的方式；所有这些元素都会使用这种相对小一些但又不为零的默认尺寸，目的在于鼓励你优化你的布局。 4 参考链接 HTML 规范 4.8.4.2.2 Sizes attributes whatwg/html#9448 Chromium#41495139 ","date":"2024-02-21","objectID":"/posts/auto-sizes/:0:0","tags":["HTML"],"title":"聊聊 Chrome 新增的 sizes=\"auto\" 属性","uri":"/posts/auto-sizes/"},{"categories":["GitHub"],"content":"Lruihao/kityminder core: 强大的脑图可视化工具","date":"2024-01-21","objectID":"/projects/lruihao/kityminder-core/","tags":[],"title":"强大的脑图可视化工具","uri":"/projects/lruihao/kityminder-core/"},{"categories":["GitHub"],"content":"KityMinder Core 注意 由于原项目 KityMinder Core 年久失修，存在一些 bug，所以 fork 了一份，进行了一些修复，并重新发布了 npm 包 @cell-x/kityminder-core。 简介 KityMinder 是一款强大的脑图可视化/编辑工具，由百度 FEX 团队开发并维护。 本仓库是 KityMinder 的核心实现部分： 包括脑图数据的可视化展示（Json 格式） 包括简单的编辑功能（节点创建、编辑、删除）。更加强大编辑功能的 KityMinder 编辑器请移步 kityminder-editor 不包含第三方格式（FreeMind、XMind、MindManager）的支持，可以加载 kityminder-protocol 来扩展第三方格式支持。 不包含文件存储的支持，需要自行实现存储。可参照百度脑图中的开源的 fio + 百度网盘方案进行实现。 使用 可以参考 example.html 进行使用。 \u003cdiv id=\"minder-container\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"kityminder.core.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e var minder = new kityminder.Minder({ renderTo: '#minder-container' }); \u003c/script\u003e 更多详细的开发资料可以参考 wiki 兼容性 KityMinder 基于 SVG 技术实现，支持绝大多数的 HTML5 浏览器，包括： Chrome Firefox Safari Internet Explorer 10 或以上 开发说明 npm install npm run dev 联系我们 问题和建议反馈：Github Issues 邮件组: kity@baidu.com QQ 讨论群: 374918234 ","date":"2024-01-21","objectID":"/projects/lruihao/kityminder-core/:0:0","tags":[],"title":"强大的脑图可视化工具","uri":"/projects/lruihao/kityminder-core/"},{"categories":["Vue.js"],"content":"在完成一个 code diff 需求时，发现所使用的插件不足以完成预期的需求。当然最终还是顺利完成了，详见 code diff demo。 1 需求 使用 v-code-diff 组件，来开发一个接口请求结果比对的功能。 开发过程中，发现虽然它的 1.8.0 版本提供了具名插槽 stat，但是插槽并没有回传值，于是乎，看了一下它的源码，提了一个 PR 加了一个作用域，见 Shimada666/v-code-diff#119，作者很快也就合并了。 这样就简化了原插槽的使用： \u003cCodeDiff :old-string=\"form.oldString\" :new-string=\"form.newString\" :language=\"form.language\" :diff-style=\"form.diffStyle\" \u003e \u003ctemplate #stat=\"{ stat }\"\u003e \u003cspan class=\"diff-stat-added\"\u003e+{{ stat.additionsNum }} 增\u003c/span\u003e \u003cspan class=\"diff-stat-deleted\"\u003e-{{ stat.deletionsNum }} 减\u003c/span\u003e \u003c/template\u003e \u003c/CodeDiff\u003e 但这只是完成需求路上的一个小插曲，真正的难点在于“比对结果时，支持关键词过滤的功能”，也就是如果比对结果中有包含关键词的行，则忽略该行的 diff。 2 师必有名 “赵若献璧，乃惧怕我邦，不难臣服；若是不献，再去征讨，方算出师有名。” 自古战事都讲究师必有名，其实在代码世界也一样，得考虑这个需求是否通用，不然即使提交 PR 给原作者，也大概率不会合并。我自己也有开源，如果遇到定制化很重的需求，往往只会以一个 wontfix 的标签收尾。 所以，我先去查了有没有类似的工具或者产品有过类似的需求。 很快就找到了 Linux 的 diff 指令的 --ignore-matching-lines 参数有类似的功能。 diff file1.json file2.json --ignore-matching-lines=\"time\" 上面的命令在比较两个文件时，会忽略包含 time 的行。 3 出师有名 既然有了参考，那么就可以开始动手了。 多的先不管，先把 v-code-diff 的源码拉下来运行起来。 git clone git@github.com:Shimada666/v-code-diff.git \u0026\u0026 cd v-code-diff 看了一眼是用 TypeScript 和 Vue3 的 Composition API 写的，这个我都不熟，不过没关系，先把它跑起来再说。 它的包管理器是 pnpm，那就先安装一下： npm i -g pnpm 然后安装依赖： pnpm install 然后在 package.json 找一下启动命令： \"scripts\": { \"dev:2\": \"vue-demi-switch 2 vue2 \u0026\u0026 pnpm --filter vue2-playground dev\", \"dev:2.7\": \"vue-demi-switch 2.7 vue2 \u0026\u0026 pnpm --filter vue2.7-playground dev\", \"dev:3\": \"vue-demi-switch 3 vue3 \u0026\u0026 pnpm --filter vue3-playground dev\", \"dev:demo\": \"vue-demi-switch 3 vue3 \u0026\u0026 pnpm --filter demo dev\", } 随便选一个运行： npm run dev:2 ok，顺利启动！ 4 一招制敌 然后开始阅读源码，寻找突破点。 two hours later… 经过一段时间阅读，虽然没有用过 TypeScript 以及 Composition API，但是对于读懂逻辑影响不大，很多就找到了突破口。 既然忽略关键词是为了让有差异的行不显示，那么正常的行就无需处理，只要找到有差异的行处理的阶段，然后加入关键词过滤的逻辑就可以了。 然后给 CodeDiff 组件新增一个 ignoreMatchingLines 属性，用于接收匹配忽略关键词的正则表达式。 最后简单测试一个在 Vue2.x、Vue2.7 以及 Vue3.x 的 demo，然后顺手把文档也完善一下，就可以提交 PR 给原作者了。详见 Shimada666/v-code-diff#121。 在等待了短暂几天后，原作者也是很快合并了 PR，并发布了新的版本 1.9.0，这样我们就可以在自己项目中升级使用了。 5 备用方案 如果作者觉得需求不妥，我们也可以 fork 一份，然后改名发包，或者只是简单的打包成一个 js 文件，然后放到自己的项目中使用。 6 总结 磨刀不误砍柴工，磨刀的过程也是砍柴的过程，找到根本原因，才能事半功倍。 比如，VS Code 的开发团队在使用 Electron 开发 VS Code 时，发现 Electron 的功能并不足以满足 VS Code 的开发需求，他们也是先参与到 Electron 的开发中，完善 Electron 后再使用 Electron 开发 VS Code 的。 经常逛 GitHub，潜移默化中，我也养成了看源码的习惯，遇到 BUG 时先想的是 PR，然后再是 issue，今年还提交了一下其他的 PR。 mdn/translated-content#15859 SchemaStore/schemastore#3411 SchemaStore/schemastore#3420 SchemaStore/schemastore#3463 ","date":"2024-01-17","objectID":"/posts/900d5e4/:0:0","tags":["debug","Vue2","Vue3","TypeScript"],"title":"记一次 Debug 第三方包的过程","uri":"/posts/900d5e4/"},{"categories":["Grocery"],"content":"foo 和 bar 是在编程中常用的元变量（metasyntactic variables），它们是在教程和示例代码中用来代表任意的函数或者变量的名称。类似的元变量还有 baz，qux，quux，corge，grault，garply，waldo，fred，plugh，xyzzy 和 thud 等。 1 foo 和 bar 这些名称起源于 MIT，然后通过 Hacker 文化传播开来。它们主要的用途是作为示例代码的占位符，这样编程教程或者文档可以更专注于解释语法和逻辑，而不需要花费太多的精力去考虑如何命名这些函数或变量。 这就像是在其他文字中使用\"John Doe\" 或 “Jane Doe\"来代表一个非特定的人一样。在编程的世界中，foo 和 bar 就扮演了类似的角色。 例如，如果我们要解释 JavaScript 中函数的使用，我们可能会写出这样的代码： function foo(bar) { return bar + 1; } foo(1); // 2 在这个例子中，foo 是一个函数名，bar 是一个参数名，它们都可以被替换为任何合法的函数名和参数名，而不改变代码逻辑。 2 quick brown fox 另外，还常常看到一个这样的句子： The quick brown fox jumps over the lazy dog 相应中文可简译为“快狐跨懒狗”，完整翻译则是“那只敏捷的棕毛狐狸跃过了那只懒狗”，是一个著名的英语全字母句，常用于测试字体显示效果和键盘是否故障。此句也常以“quick brown fox”做为指代简称。 简而言之，这些都是英文世界里一些约定俗成的用语，类似于中文里的“张三李四”、“甲乙丙丁”等等。 ","date":"2024-01-17","objectID":"/posts/20b75e9/:0:0","tags":null,"title":"为什么很多教程中都有 foo bar？","uri":"/posts/20b75e9/"},{"categories":["Git"],"content":"Git 报错 “git submodule: already exists in the index” 的解决方法。 1 问题 在 hugo-fixit/docs，里我增通过软连接的方式引入了 hugo-fixit/FixIt，位于 themes/FixIt 目录下。 然后为了把主题开发和主题文档分离（#404），我想通过 git submodule 的方式引入主题，于是我先把 themes/FixIt 目录删除，然后执行： git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt 结果报错： fatal: 'themes/FixIt' already exists in the index 2 解决方法 git rm -r --cached themes/FixIt ","date":"2024-01-11","objectID":"/posts/6550187/:0:0","tags":["Git"],"title":"git submodule: already exists in the index","uri":"/posts/6550187/"},{"categories":["Vue.js","JavaScript"],"content":" 出发点 虽然 Element 也有 el-collapse 组件，但是当我只想写一个折叠面板时，它的写法就略显繁琐了，el-card 组件的样式也更符合我的需求，所以我就想着给 el-card 添加折叠功能。 1 效果 在线演示：https://lruihao.github.io/vue-el-demo/#/card-collapse 2 实现过程 一开始想着使用 Vue 的自定义指令功能来实现，但是动手之前还是习惯性地先看 el-card 的源码，如下所示： \u003ctemplate\u003e \u003cdiv class=\"el-card\" :class=\"shadow ? 'is-' + shadow + '-shadow' : 'is-always-shadow'\"\u003e \u003cdiv class=\"el-card__header\" v-if=\"$slots.header || header\"\u003e \u003cslot name=\"header\"\u003e{{ header }}\u003c/slot\u003e \u003c/div\u003e \u003cdiv class=\"el-card__body\" :style=\"bodyStyle\"\u003e \u003cslot\u003e\u003c/slot\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'ElCard', props: { header: {}, bodyStyle: {}, shadow: { type: String } } }; \u003c/script\u003e 这一看源码这么简单，直接改得了，还用啥自定义指令，开干！ 3 实现方式 通过继承 el-card 组件来实现，这样就不用改 el-card 的源码了，也不用担心升级 Element 时会被覆盖掉。 然后在继承的组件中添加一个 isCollapse 属性来控制折叠状态。 继承也很简单，这样简单几行就完整继承了原来 el-card 的所有功能了： \u003cscript\u003e import { Card } from 'element-ui' export default { name: 'ElCardCollapse', extends: Card, } \u003c/script\u003e 然后，把 el-card template 中的代码先原封不动地复制过来，再在需要的地方添加折叠按钮和相关逻辑就行了： \u003ctemplate\u003e \u003cdiv class=\"el-card\" :class=\"shadow ? 'is-' + shadow + '-shadow' : 'is-always-shadow'\"\u003e \u003cdiv v-if=\"$slots.header || header\" class=\"el-card__header\" :class=\"isCollapseSelf ? 'collapse-icon-right' : 'collapse-icon-down'\" @click=\"isCollapseSelf = !isCollapseSelf\" \u003e \u003cslot name=\"header\"\u003e{{ header }}\u003c/slot\u003e \u003c/div\u003e \u003cdiv class=\"el-card__body\" :style=\"bodyStyle\" :class=\"{'is-collapse': isCollapseSelf}\" \u003e \u003cslot /\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { Card } from 'element-ui' export default { name: 'ElCardCollapse', extends: Card, props: { isCollapse: { type: Boolean, default: false, }, }, data() { return { isCollapseSelf: this.isCollapse, } }, } \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e .el-card__header { cursor: pointer; position: relative; \u0026::after { font-family: element-icons !important; speak: none; font-style: normal; font-weight: 400; font-variant: normal; text-transform: none; line-height: 1; vertical-align: baseline; display: inline-block; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; position: absolute; right: 10px; top: 50%; transform: translateY(-50%); } \u0026.collapse-icon-right::after { content: '\\e6e0'; } \u0026.collapse-icon-down::after { content: '\\e6df'; } } .is-collapse { display: none; } \u003c/style\u003e 4 使用方法 在 main.js 中引入： import ElCardCollapse from '@/components/ElCardCollapse.vue' Vue.component('ElCardCollapse', ElCardCollapse) 写法和 el-card 一样，只是多了一个 is-collapse 属性，使用 el-card-collapse 代替 el-card 即可： \u003ctemplate\u003e \u003cdiv\u003e \u003cel-card-collapse class=\"box-card\" :is-collapse=\"isCollapse\"\u003e \u003cdiv slot=\"header\" class=\"flex-between\"\u003e \u003cspan\u003e卡片名称\u003c/span\u003e \u003cel-button style=\"padding: 3px 0; margin-right: 10px;\" type=\"text\"\u003e操作按钮\u003c/el-button\u003e \u003c/div\u003e \u003cdiv v-for=\"o in 4\" :key=\"o\" class=\"text item\"\u003e {{ '列表内容 ' + o }} \u003c/div\u003e \u003c/el-card-collapse\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'CardCollapse', data() { return { isCollapse: true, } }, } \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e .text { font-size: 14px; } .item { margin-bottom: 18px; } .flex-between { display: flex; justify-content: space-between; align-items: center; } .box-card { width: 480px; } \u003c/style\u003e ","date":"2024-01-10","objectID":"/posts/el-card-collapse/:0:0","tags":["Vue2"],"title":"给 el-card 添加折叠功能","uri":"/posts/el-card-collapse/"},{"categories":["Node.js"],"content":"本文将介绍如何用 Node.js 开发一个轻量脚手架，以 fixit-cli 为例。 17 前言 在维护 FixIt 这个项目时，很多新人可能第一次接触 Hugo，第一次使用 FixIt 主题，可能觉得无从下手。在之前的工作中，为了避免这个问题，我新增了两个模板项目： hugo-fixit-blog-go hugo-fixit-blog-git 然并卵哈哈哈🤣，大家似乎都有种惰性，不愿意认真地读一遍 README，即使只需简单几步就能通过 GitHub template 创建一个拥有完整主题配置、自动化部署完善的博客。 懒惰是人类进步的源泉，想到 Vue CLI、Create React App 这些脚手架，我决定开发一个轻量级的脚手架 fixit-cli，让大家能够快速地上手 FixIt 主题。 18 思路 fixit-cli 的思路很简单，就是通过命令行交互，让用户输入一些信息，然后根据这些信息生成一个完整的博客项目。 fixit create my-blog 创建一个名为 my-blog 的项目 fixit check 检查 FixIt 主题的最新版本 19 开发 19.1 初始化项目 mkdir fixit-cli cd fixit-cli npm init -y 然后在 package.json 中写点项目信息。 19.2 安装依赖 npm install commander inquirer chalk simple-git ora --save 主要依赖： 依赖 用途 commander 完整的 Node.js 命令行解决方案 inquirer 常见交互式命令行用户界面的集合 chalk 命令行输出样式 simple-git 用于在任何 Node.js 应用程序中运行 Git 命令的轻量级接口 ora 命令行 loading 效果 如果需要使用简单的 git clone 下载模板，可以使用 download-git-repo 替代 simple-git。 19.3 定义一个 CLI 在 package.json 中添加 bin 字段，指定 CLI 的入口文件。 { \"bin\": { \"fixit\": \"bin/cli.js\" } } 然后在 bin 目录下创建 cli.js 文件，写入以下内容： #!/usr/bin/env node console.log('Hello, FixIt!') 代码顶部的 #!/usr/bin/env node 是告诉终端，这个文件要使用 node 去执行，等同于 node bin/cli.js。 如果我们想要在终端执行 fixit 命令，可以使用 npm link 将 fixit 命令链接到全局。 npm link # 卸载本地包 npm unlink fixit 或者也可以使用 npm install -g 全局安装。 npm install -g fixit-cli /Users/cell/workspace/fixit-cli/ 19.4 命令行交互 先把要实现的命令和选项列出来： #!/usr/bin/env node import { Command } from 'commander' // ... // define commands program .command('create \u003cproject-name\u003e') .description('create a new FixIt project from a template') .action(createAction) program .command('check') .description('check the latest version of FixIt theme') .action(checkAction) program .command('help \u003ccommand\u003e') .description('display help for a specific command') .action(helpAction) // define cli program .usage('\u003ccommand\u003e [options]') .description(description) .version(`${pkg.name} v${pkg.version}`, '-v, --version') .showHelpAfterError() .parse(process.argv) 然后再去实现这些命令所执行的动作：createAction、checkAction、helpAction 和完善一下 logo 和 description 等细节。 Usage: fixit \u003ccommand\u003e [options] ============================================= ▄████ ▄█ ▄ ▄█ ▄▄▄▄▀ █▀ ▀ ██ ▀▄ █ ██ ▀▀▀ █ █▀▀ ██ █ ▀ ██ █ █ ▐█ ▄ █ ▐█ █ █ ▐ █ ▀▄ ▐ ▀ ▀ ▀ fixit-cli v1.0.2 A cli tool for FixIt theme. ============================================= FixIt is a clean, elegant but advanced blog theme for Hugo built with love by Lruihao and his friends. Complete documentation is available at https://fixit.lruihao.cn/. Options: -v, --version output the version number -h, --help display help for command Commands: create \u003cproject-name\u003e create a new FixIt project from a template check check the latest version of FixIt theme help \u003ccommand\u003e display help for a specific command 最后发布到 npm 上就完活了。 npm login npm publish 发布后，就可以通过 npm install -g fixit-cli 全局安装了。 安装后，例如，创建一个名为 my-blog 的站点： fixit create my-blog 20 源码 命令动作的具体实现详见 FixIt CLI 源码。 hugo-fixit/fixit-cli Public 🛠️ A node-based tooling for FixIt site initialization. TypeScript 31 1 ","date":"2023-11-28","objectID":"/projects/fixit-cli/:0:0","tags":["脚手架","FixIt"],"title":"用 Node.js 开发一个轻量脚手架","uri":"/projects/fixit-cli/"},{"categories":["GitHub"],"content":"hugo fixit/fixit cli: 🛠️ A node-based tooling for FixIt site initialization.","date":"2023-11-20","objectID":"/projects/hugo-fixit/fixit-cli/","tags":["fixit-cli","hugo","hugo-fixit","nodejs","scaffolding-tool"],"title":"🛠️ A node-based tooling for FixIt site initialization.","uri":"/projects/hugo-fixit/fixit-cli/"},{"categories":["GitHub"],"content":"FixIt CLI 👉 中文 | English 🛠️ 一个基于 Node.js 开发的用于 FixIt 站点初始化的脚手架工具。 系统依赖 Node.js (\u003e= 18) Git Hugo 扩展版 如果你使用 Hugo 模块 功能加载主题，你还需要安装 Go。 使用 使用 pnpx 或者 npx 直接运行 fixit-cli，创建一个新的 FixIt 项目会非常方便，当然你也可以全局安装 fixit-cli，然后使用 fixit 命令。 例如，创建一个名为 my-blog 的站点： pnpx fixit-cli create my-blog 更多用法请参考下面的帮助信息： pnpx fixit-cli -h Usage: fixit \u003ccommand\u003e [options] ============================================= ▄████ ▄█ ▄ ▄█ ▄▄▄▄▀ █▀ ▀ ██ ▀▄ █ ██ ▀▀▀ █ █▀▀ ██ █ ▀ ██ █ █ ▐█ ▄ █ ▐█ █ █ ▐ █ ▀▄ ▐ ▀ ▀ ▀ fixit-cli v1.2.1 A cli tool for FixIt theme. ============================================= FixIt is a clean, elegant but advanced blog theme for Hugo built with love by Lruihao and his friends. Complete documentation is available at https://fixit.lruihao.cn/. Options: -v, --version output the version number -h, --help display help for command Commands: create|new [project-name] create a new FixIt project/component from a template check check the latest version of FixIt theme help [command] display help for command 开发 安装依赖项： pnpm install 在开发模式下运行 CLI： pnpm start -h 将包链接/取消链接到全局包目录： pnpm link pnpm unlink fixit-cli 从本地路径全局安装/卸载包： pnpm add -g path/to/fixit-cli pnpm remove -g fixit-cli TODO List 检查是否安装 Hugo，没有安装，可通过 Node 包安装 hugo-bin/hugo-extended 执行 fixit check 命令后，获取到新版本后，提示是否更新 新增 fixit add 命令，用于添加新的 FixIt 主题组件（fixit create 命令增加主题组件选项） 相关项目 本 CLI 工具是基于以下项目开发的： FixIt hugo-fixit-starter hugo-fixit-starter1 component-skeleton 作者 Lruihao ","date":"2023-11-20","objectID":"/projects/hugo-fixit/fixit-cli/:0:0","tags":["fixit-cli","hugo","hugo-fixit","nodejs","scaffolding-tool"],"title":"🛠️ A node-based tooling for FixIt site initialization.","uri":"/projects/hugo-fixit/fixit-cli/"},{"categories":["Git"],"content":"Git 支持使用 GPG 来签名提交记录。但 GPG 用起来很复杂，一直赖得搞。Git 从 2.34 开始支持使用 SSH 签名，所以本文将介绍如何使用 SSH 对提交进行签名。 1 操作步骤 可以使用 SSH 通过自己生成的 SSH 密钥对提交进行签名。有关详细信息，请查看 user.Signingkey 的 Git 参考文档。如果已使用 SSH 密钥向 GitHub 进行了身份验证，还可以再次上传该相同密钥以用作签名密钥。可以添加到帐户的签名密钥数没有限制。 GitHub 使用 ssh_data（一种开放源代码 Ruby 库）来确认本地签名的提交和标记是否根据在 GitHub.com 上添加到帐户的公钥进行加密验证。 注意：SSH 签名验证可用于 Git 2.34 或更高版本。若要更新 Git 版本，请参阅 Git 网站。 要使用 SSH 对提交签名并在 GitHub 上验证这些提交，请执行以下步骤： 检查现有 SSH 密钥 生成新的 SSH 密钥 将 SSH 签名密钥添加到 GitHub 帐户 将你的签名密钥告诉 Git 对提交签名 对标记签名 2 检查现有 SSH 密钥 打开终端。 输入 ls -al ~/.ssh 以查看是否存在现有的 SSH 密钥。 # Lists the files in your .ssh directory, if they exist ls -al ~/.ssh 检查目录列表以查看是否已经有 SSH 公钥。默认情况下，GitHub 的一个支持的公钥的文件名是以下之一。 id_rsa.pub id_ecdsa.pub id_ed25519.pub 3 生成新的 SSH 密钥 注意 注意：GitHub 通过在 2022 年 3 月 15 日删除旧的、不安全的密钥类型来提高安全性。 自该日期起，不再支持 DSA 密钥 (ssh-dss)。无法在 GitHub.com 上向个人帐户添加新的 DSA 密钥。 2021 年 11 月 2 日之前带有 valid_after 的 RSA 密钥 (ssh-rsa) 可以继续使用任何签名算法。在该日期之后生成的 RSA 密钥必须使用 SHA-2 签名算法。一些较旧的客户端可能需要升级才能使用 SHA-2 签名。 打开终端。 粘贴下面的文本（替换为你的 GitHub 电子邮件地址）。 ssh-keygen -t ed25519 -C \"your_email@example.com\" 注意：如果你使用的是不支持 Ed25519 算法的旧系统，请使用以下命令： ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 这将以提供的电子邮件地址为标签创建新 SSH 密钥。 \u003e Generating public/private ALGORITHM key pair. 当系统提示你“Enter a file in which to save the key（输入要保存密钥的文件）”时，可以按 Enter 键接受默认文件位置。请注意，如果以前创建了 SSH 密钥，则 ssh-keygen 可能会要求重写另一个密钥，在这种情况下，我们建议创建自定义命名的 SSH 密钥。为此，请键入默认文件位置，并将 id_ssh_keyname 替换为自定义密钥名称。 \u003e Enter a file in which to save the key (/Users/YOU/.ssh/id_ALGORITHM): [Press enter] 在提示符下，键入安全密码。有关详细信息，请参阅“使用 SSH 密钥密码”。 \u003e Enter passphrase (empty for no passphrase): [Type a passphrase] \u003e Enter same passphrase again: [Type passphrase again] 更多请查看 生成新的 SSH 密钥。 4 新增 SSH 密钥到 GitHub 帐户 注意：添加 SSH 密钥的类型选择 Signing Key，细节略，详见 将 SSH 签名密钥添加到 GitHub 帐户。 5 将 SSH 密钥告知 Git 打开终端。 配置 Git 使用 SSH 对提交和标记签名： git config --global gpg.format ssh 若要在 Git 中设置 SSH 签名密钥，请粘贴下面的文本，将 /PATH/TO/KEY.PUB 替换为要使用的公钥路径（例如：~/.ssh/id_ed25519.pub）。 git config --global user.signingkey /PATH/TO/.SSH/KEY.PUB 6 对提交签名 当本地分支中的提交更改时，可以将 -S 添加到 git commit 命令： # Creates a signed commit git commit -S -m \"YOUR_COMMIT_MESSAGE\" 若要将 Git 客户端配置为默认对本地存储库的提交进行签名，请在 Git 版本 2.0.0 及更高版本中，运行： git config commit.gpgsign true 要在计算机上的任何本地存储库中默认对所有提交进行签名，请运行： git config --global commit.gpgsign true 在本地完成创建提交后，将其推送到 GitHub 上的远程仓库，在 GitHub 上查看提交记录就能看到 Verified 的标志了。 7 对标记签名 若要对标记进行签名，请将 -s 添加到 git tag 命令。 # Creates a signed tag git tag -s MYTAG 通过运行 git tag -v [tag-name] 验证已签名的标记。 # Verifies the signed tag git tag -v MYTAG 或者，可以将 gpgsign 设置为 true，以便在创建标记时自动对其进行签名： git config tag.gpgsign true # 或者 git config --global tag.gpgsign true 8 其他 创建可信公钥列表文件： mkdir -p ~/.config/git touch ~/.config/git/allowed_signers 可信公钥列表文件内容格式如下，每个公钥占一行： 公钥的身份 公钥内容 例如，可以将 ~/.ssh/id_ed25519.pub 公钥复制然后粘贴： pbcopy \u003c ~/.ssh/id_ed25519.pub open ~/.config/git/allowed_signers Cell ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIE5bRSsXZ5HnUkMMEWS5/jxEQaqbLb+i6xjMyC6qiXsb xxx@xxx.com 将可信公钥列表文件路径添加到 Git 配置中： git config --global gpg.ssh.allowedSignersFile \"~/.config/git/allowed_signers\" 本地查看提交日志签名状况： git log --show-signature ","date":"2023-10-22","objectID":"/posts/ssh-sign/:0:0","tags":["Git","SSH"],"title":"SSH 提交签名验证","uri":"/posts/ssh-sign/"},{"categories":["Node.js"],"content":"1 背景 今天鬼事神差想起去年写的一段 dirty hack 代码，当时是在 vue-minder-editor-extended 这个项目为了解决百度开源的 @7polo/kityminder-core npm 包的 bug，但是百度早在 17-18 年就停止更新了，我又不想自己 fork 一份源码然后重新发包，于是当时直接从 node_modules 里面复制出了打包后的源码进行修改，然后放到了项目中 src/script/patch/kityminder.core.js，并因修改了引入： - require('@7polo/kityminder-core'); + require('./script/patch/kityminder.core'); 但是今天刷抖音看到类似的问题，回想起来这种做法真的是太蠢了，于是就想着有没有更好的办法，于是就一番搜索有了这篇文章。 2 安装 patch-package npm i patch-package --save-dev 3 修改源码 在 node_modules 目录下找到需要打补丁的包，然后修改源码，比如我这里修改了 node_modules/@7polo/kityminder-core/dist/kityminder.core.js，修改后直接保存。 4 生成补丁 npx patch-package @7polo/kityminder-core 此时在根目录下会得到如下文件： ├── patches │ └── @7polo-kityminder-core+1.4.53.patch └── package.json 想看看这个补丁文件里面是什么东西，打开 patches/@7polo-kityminder-core+1.4.53.patch，内容如下： diff --git a/node_modules/@7polo/kityminder-core/.DS_Store b/node_modules/@7polo/kityminder-core/.DS_Store new file mode 100644 index 0000000..c88a062 Binary files /dev/null and b/node_modules/@7polo/kityminder-core/.DS_Store differ diff --git a/node_modules/@7polo/kityminder-core/dist/kityminder.core.js b/node_modules/@7polo/kityminder-core/dist/kityminder.core.js index 78dfbaf..32f276d 100644 --- a/node_modules/@7polo/kityminder-core/dist/kityminder.core.js +++ b/node_modules/@7polo/kityminder-core/dist/kityminder.core.js @@ -513,6 +513,8 @@ _p[9] = { * * @param {string} name 要执行的命令名称 * @param {argument} args 要传递给命令的其它参数 + * + * @patch 2022.10.19 @Lruihao 修复缺少 afterExecCommand hook */ execCommand: function(name) { if (!name) return null; @@ -547,6 +549,8 @@ _p[9] = { this._interactChange(); } } + // Fix: afterExecCommand hook + this._fire(new MinderEvent(\"afterExecCommand\", eventParams, false)); return result === undefined ? null : result; } }); @@ -1254,6 +1258,22 @@ _p[13] = { }); return this; }, + /** + * @patch 2022.10.26 @Lruihao 修复缺少 once 侦听指定事件一次 + * @param {String} name + * @param {Function} callback + */ + once: function(name, callback) { + var km = this; + name.split(/\\s+/).forEach(function(n) { + const tmpCallback = (e) =\u003e { + callback(e); + km.off(n.toLowerCase(), tmpCallback) + }; + km._listen(n.toLowerCase(), tmpCallback); + }); + return this; + }, off: function(name, callback) { var types = name.split(/\\s+/); var i, j, callbacks, removeIndex; 发现其实就是一个 diff 文件，这个文件里面记录了修改的内容，以及修改的位置，这样就可以在安装依赖的时候自动执行补丁了。 5 使用补丁 在 package.json 中添加如下内容： { \"scripts\": { \"postinstall\": \"patch-package\" } } 6 提交补丁 git add . git commit -m \"Chore: patch @7polo/kityminder-core\" git push 7 测试 执行一次完整的依赖安装 =\u003e 构建发布，一切符合预期，大功告成~ ","date":"2023-10-12","objectID":"/posts/patch-package/:0:0","tags":["debug","npm","JavaScript"],"title":"如何给 npm 包打补丁？","uri":"/posts/patch-package/"},{"categories":["Vue.js"],"content":"当今，仪表盘已成为许多应用程序和软件界面中常见的设计元素。它们提供了一种直观且用户友好的方式来呈现和操作数据。无论是在数据分析、业务管理还是可视化报告等领域，拖拽式仪表盘都能为用户提供灵活性和个性化的体验。 1 特点和功能 拖拽式仪表盘的主要特点是使用拖拽和放置操作来构建和定制用户界面。具体功能包括： 拖拽元素：用户可以从预定义的元素列表中选择并将其拖拽到仪表盘上。这些元素可以是图表、指标、过滤器、小部件等。 放置和调整：拖拽后，用户可以将元素放置到所需的位置，并调整它们的大小和布局，以满足个人需求。 数据关联：用户可以将数据源与仪表盘上的元素关联起来，以显示实时或静态数据。这使用户能够轻松地创建可视化报表和图表。 交互性：拖拽式仪表盘通常支持用户与元素进行交互，如数据筛选、排序、聚合等操作，以便更深入地分析数据。 2 优势和益处 拖拽式仪表盘具有多个优势，使其成为用户和开发者的首选选择： 用户友好：拖拽式操作使得构建和定制仪表盘变得直观和简单，无需复杂的编码或技术知识。 灵活性：用户可以根据自己的需求和偏好自定义仪表盘布局、样式和内容，使其适应不同的工作场景和数据展示要求。 实时更新：通过数据关联和实时更新功能，拖拽式仪表盘可以显示最新的数据，帮助用户做出准确的决策。 可视化效果：仪表盘上的图表、指标和图形化元素可以提供直观和易于理解的数据展示，帮助用户快速洞察关键信息和趋势。 可扩展性：拖拽式仪表盘通常具有可扩展性，可以集成其他功能和插件，以满足特定的业务需求。 3 应用领域 拖拽式仪表盘在许多领域中都得到广泛应用，包括但不限于： 数据分析和报告：拖拽式仪表盘使数据分析师和业务用户能够轻松构建个性化的数据报表和仪表盘，以实时监控和分析关键指标。 业务管理和监控：企业管理者可以使用拖拽式仪表盘来跟踪业务绩效、销售数据、供应链指标等，以便做出战略决策。 项目管理和协作：拖拽式仪表盘可用于项目管理和团队协作，帮助团队成员追踪任务、进度和资源分配情况。 客户关系管理：在销售和客户服务领域，拖拽式仪表盘可以显示客户数据、销售漏斗、客户满意度等信息，以支持客户关系管理和提高客户体验。 运营监控和故障排除：拖拽式仪表盘可用于监控系统运行状况、网络流量、服务器负载等，帮助运维团队及时发现和解决问题。 市场营销和广告分析：拖拽式仪表盘可以用于跟踪市场营销活动、广告效果和用户行为数据，以优化营销策略和广告投放。 4 未来发展 拖拽式仪表盘是一种强大而灵活的工具，为用户提供了以直观和个性化的方式展示和操作数据的能力。它们在各个领域中都发挥着重要作用，帮助用户快速洞察数据、做出决策并优化业务流程。随着技术的不断发展，拖拽式仪表盘的功能和性能将进一步增强，为用户提供更多可能性和创新的数据可视化体验。 5 收获与总结 在开发拖拽式仪表盘的过程中，我学到了很多东西，包括但不限于：更加深入 Vue.js 的使用，包括组件、插槽、指令、混入、依赖注入等。 独立设计和开发一个完整的功能、思考的过程比最终的结果更加有趣。比如以前没尝试过的自定义 HooK、Provide/Inject 等。还有，相比于以前的工作，大多是由后端主导逻辑，这次的工作是从设计到开发完全由前端主导，逻辑可控，之后维护起来也会更加简单。 并且未来方便之后不同的同事开发不同的仪表盘组件，我写了完整详细的文档，包括方法参数、属性配置、事件钩子等，方便他们快速上手。 一步步完善每个小功能的过程中，也写下了几篇前驱文章： CSS 实现网格背景效果 在 Vue 项目中更优雅地使用 icon 封装 Vue FullScreenToggler 组件 另外，我还收集了一些拖拽式相关的库： react-grid-layout，用于 React 的拖拽式布局系统，比 Vue 版的更完善 vue-draggable-resizable 总的来说，拖拽式仪表盘这个功能还是很有趣的，这也使得我孜孜不倦地去开发完善。 ","date":"2023-10-12","objectID":"/posts/dashboard-summary/:0:0","tags":["拖拽式仪表盘","dashboard","widget","Vue2","总结"],"title":"拖拽式仪表盘系列总结","uri":"/posts/dashboard-summary/"},{"categories":["Vue.js"],"content":"本文介绍将如何开发一个仪表盘组件，以及组件开发的灵感来源。 1 第一个组件 先通过一个简单的便利贴组件为例，介绍如何开发一个仪表盘组件。 Talk is cheap. Show you the code. \u003ctemplate\u003e \u003cel-card\u003e \u003cspan class=\"note-content\"\u003e{{ params.content }}\u003c/span\u003e \u003cel-popover v-model=\"formVisible\" trigger=\"manual\" popper-class=\"form-popover\" \u003e \u003cel-form ref=\"form\" label-width=\"80px\" label-position=\"top\" :model=\"form\" :rules=\"rules\" \u003e \u003cel-form-item label=\"便利贴\" prop=\"content\"\u003e \u003cel-input v-model=\"form.content\" type=\"textarea\" :autosize=\"{ minRows: 2, maxRows: 4 }\" /\u003e \u003c/el-form-item\u003e \u003c/el-form\u003e \u003cdiv class=\"text-right\"\u003e \u003cel-button type=\"text\" size=\"mini\" @click=\"formVisible = false\"\u003e取消\u003c/el-button\u003e \u003cel-button type=\"primary\" size=\"mini\" @click=\"save\"\u003e保存\u003c/el-button\u003e \u003c/div\u003e \u003c/el-popover\u003e \u003c/el-card\u003e \u003c/template\u003e \u003cscript\u003e export default { /** * 组件名称，必须且唯一 */ name: 'ExampleWidget', /** * 组件配置对象 * @property {String} name 组件名称，用于在组件列表中显示组件名称 * @property {String} [icon='el-icon-postcard'] 组件图标，用于在组件列表中显示组件图标，支持 el-icon、iconfont 和 svg-icon * @property {Object} [params] 组件参数，一般搭配 setting 钩子函数使用 * @property {Boolean} [disabled] 是否禁用组件，设置为 true 则不会被注册（组件弃用时可设置为 true） * @property {Boolean} [hidden] 是否隐藏组件，设置为 true 则不会在组件列表中显示（组件即将弃用时可设置为 true） * 以下参数参考 https://jbaysolutions.github.io/vue-grid-layout/zh/guide/properties.html#griditem * @property {Number} w 组件宽度 * @property {Number} h 组件高度 * @property {Number} [minW] 组件最小宽度 * @property {Number} [minH] 组件最小高度 * @property {Number} [maxW] 组件最大宽度 * @property {Number} [maxH] 组件最大高度 * @property {Boolean} [isResizable=false] 是否可调整大小 */ widget: { name: '便利贴', icon: 'el-icon-postcard', params: { content: '', }, disabled: false, hidden: false, w: 8, h: 3, minW: 8, minH: 3, maxW: 24, maxH: 6, isResizable: true, }, inject: ['$dashboard'], props: { /** * 组件实例数据 */ item: { type: Object, default: () =\u003e ({}), }, /** * 组件参数，用于接收用户已配置的参数，支持 `.sync` 修饰符 */ params: { type: Object, default: () =\u003e ({}), }, }, data() { return { formVisible: false, form: { content: '', }, rules: { content: [{ required: true, message: '请输入便利贴内容', trigger: 'change' }], }, } }, watch: { '$dashboard.isCollapse'(val) { // 当侧栏组件列表折叠时，关闭配置弹窗 if (val) { this.formVisible = false } }, 'params.content'(val) { // 当用户修改了参数，更新表单中对应的参数 this.form.content = val }, }, mounted() { this.form = { ...this.params } }, /** * hook for refresh widget item * 点击刷新组件按钮时触发，一般用于刷新组件数据 * @param {Object} item 组件实例数据 */ refresh(item) { // to refresh widget data }, /** * hook for setting widget item * 点击配置组件按钮时触发，一般搭配 widget.params 使用 * @param {Object} item 组件实例数据 */ setting(item) { this.formVisible = true }, /** * hook for moving widget item * @param {Object} item item config data * @param {Number} i the item id/index * @param {Number} newX new x position in grid rows * @param {Number} newY new y position in grid columns */ move(item, i, newX, newY) { // to do something when widget item moving }, /** * hook for moved widget item * @param {Object} item item config data * @param {Number} i the item id/index * @param {Number} newX new x position in grid rows * @param {Number} newY new y position in grid columns */ moved(item, i, newX, newY) { // to do something when widget item moved }, /** * hook for resizing widget item * @param {Object} item item config data * @param {Number} i the item id/index * @param {Number} newH new height in grid rows * @param {Number} newW new width in grid columns * @param {String} newHPx new height in pixels * @param {String} newWPx new width in pixels */ resize(item, i, newH, newW, newHPx, newWPx) { // to do something when widget item resizing }, /** * hook for resized widget item * @param {Object} item item config data * @param {Number} i the item id/index * @param {Number} newH new height in grid rows * @param {Number} newW new width in grid columns * @param {String} newHPx new height in pixels * @param {String} newWPx new width in pixels */ resized(item, i, newH, newW, newHPx, newWPx) { // to do something when widget item resized }, /** * hook for container resized * @param {Object} item item config data * @param {Number} i the","date":"2023-10-12","objectID":"/posts/dashborad-widget-usage/:0:0","tags":["拖拽式仪表盘","dashboard","widget","Vue2"],"title":"拖拽式仪表盘 - 组件开发","uri":"/posts/dashborad-widget-usage/"},{"categories":["Vue.js"],"content":"本文将通过一个简单的例子，介绍如何使用仪表盘模板。 Talk is cheap. Show you the code. 1 代码 \u003c!-- 首页 dashboard 页面布局 --\u003e \u003cscript\u003e import Dashboard, { registerComponents } from '@/components/Dashboard' // 加载测试跟踪 widgets 目录下所有组件 const requireTrackingComponents = require.context('@/views/tracking/dashboard/widgets', true, /\\.vue$/) const trackingComponents = registerComponents(requireTrackingComponents) // 加载接口测试 widgets 目录下所有组件 const requireInterfaceComponents = require.context('@/views/interface/dashboard/widgets', true, /\\.vue$/) const interfaceComponents = registerComponents(requireInterfaceComponents) // 加载 WebUI 测试 widgets 目录下所有组件 const requireWebUIComponents = require.context('@/views/webui/dashboard/widgets', true, /\\.vue$/) const webuiComponents = registerComponents(requireWebUIComponents) // 加载 App 测试 widgets 目录下所有组件 const requireAppComponents = require.context('@/views/app/dashboard/widgets', true, /\\.vue$/) const appComponents = registerComponents(requireAppComponents) export default { name: 'HomeDashboard', extends: Dashboard, data() { return { // 设置默认布局 defaultLayout: [ { i: 1, component: 'TrackingCountsWidget', name: '总数统计', x: 0, y: 0, w: 6, h: 2, params: { type: 'product' }}, { i: 2, component: 'TrackingCountsWidget', name: '总数统计', x: 6, y: 0, w: 6, h: 2, params: { type: 'case' }}, { i: 3, component: 'TrackingCountsWidget', name: '总数统计', x: 12, y: 0, w: 6, h: 2, params: { type: 'testplan' }}, { i: 4, component: 'TrackingCountsWidget', name: '总数统计', x: 18, y: 0, w: 6, h: 2, params: { type: 'report' }}, { i: 5, component: 'InterfaceCountsWidget', name: '总数统计', x: 0, y: 2, w: 6, h: 2, params: { type: 'task' }}, { i: 6, component: 'InterfaceCountsWidget', name: '总数统计', x: 6, y: 2, w: 6, h: 2, params: { type: 'api' }}, { i: 7, component: 'InterfaceCountsWidget', name: '总数统计', x: 12, y: 2, w: 6, h: 2, params: { type: 'case' }}, { i: 8, component: 'InterfaceCountsWidget', name: '总数统计', x: 18, y: 2, w: 6, h: 2, params: { type: 'device' }}, { i: 9, component: 'MyTestplan', name: '我的测试计划', x: 0, y: 4, w: 12, h: 6, minW: 8, minH: 6, maxW: 24, maxH: 6, isResizable: true, params: { type: 'myAttend' }}, { i: 10, component: 'MyInterfaceTask', name: '我创建的测试', x: 12, y: 4, w: 12, h: 6, minW: 12, minH: 6, maxW: 24, maxH: 6, isResizable: true }, ], } }, created() { // 加载组件列表 this.addComponents('测试跟踪', trackingComponents) this.addComponents('接口测试', interfaceComponents) this.addComponents('WebUI 测试', webuiComponents) this.addComponents('App 测试', appComponents) // 设置权限 this.hasEditPermission = this.checkPermission(['admin']) || !this.dashboard.isDefault }, } \u003c/script\u003e 2 效果 画质感人，将就看吧～ ","date":"2023-10-12","objectID":"/posts/dashborad-template-usage/:0:0","tags":["拖拽式仪表盘","dashboard","Vue2"],"title":"拖拽式仪表盘 - 模板使用","uri":"/posts/dashborad-template-usage/"},{"categories":["Vue.js"],"content":"本文将对 Dashboard 组件的使用方法进行介绍。 33 A note on terminology “Widget（小部件）”和“Component（组件）”都是计算机科学中常见的术语，用于描述可重复使用的用户界面元素。Widget 通常更简单，具有预定义的样式和功能，而 Component 可以更灵活、可定制，并具有更丰富的行为和交互性。Widget 更倾向于描述独立的、自包含的小型组件，而 Component 则更倾向于描述较大规模的、可组合的用户界面元素。 Vue 项目通常选用 Component，与之相比仪表盘组件功能更加局限，使用 Widget 来描述显然更符合实际情况。 34 Widget Example 完整例子详见 @/components/Dashboard/widgets/example.vue 组件。 35 Inject dashboard 组件及其后代组件可以通过注入 $dashboard 访问容器中的属性或方法。 $dashboard (Object): 当前 dashboard 容器实例 例如： \u003cscript\u003e export default { name: 'ExampleWidget', widget: { /* ... */ }, inject: ['$dashboard'], mounted() { // 组件通过 this.$dashboard 访问容器中的属性或方法 this.$dashboard.notify('example widget mounted') }, /* ... */ } \u003c/script\u003e 36 Props 容器中的组件可以接收一些上层传递的参数，如下： 参数 类型 说明 item Object 组件实例数据 params Object 组件参数，用于接收用户已配置的参数，支持 .sync 修饰符 37 Widget Properties 属性 类型 必填 说明 name String Y 组件名称，必须且唯一（同 Vue 组件 name 属性） widget Object Y 组件配置信息，参考文档 widget 配置如下： 属性 类型 必填 说明 name String Y 组件名称，用于在组件列表中显示组件名称 icon String Y 组件图标，用于在组件列表中显示组件图标，支持 el-icon、iconfont 和 svg-icon params Object N 组件参数，一般搭配 setting 钩子函数使用 disabled Boolean N 是否禁用组件，设置为 true 则不会被注册（组件弃用时可设置为 true） hidden Boolean N 是否隐藏组件，设置为 true 则不会在组件列表中显示（组件即将弃用时可设置为 true） w Number Y 组件宽度 h Number Y 组件高度 minW Number N 组件最小宽度 minH Number N 组件最小高度 maxW Number N 组件最大宽度 maxH Number N 组件最大高度 isResizable Boolean N 是否可调整大小 38 Widget Events 事件名 类型 说明 回调参数 refresh Function hook for refresh widget item item setting Function hook for setting widget item item move Function hook for moving widget item item, …args moved Function hook for moved widget item item, …args resize Function hook for resizing widget item item, …args resized Function hook for resized widget item item, …args containerResized Function hook for resized grid container item, …args 参数说明： item：Object，组件实例数据，参考文档 args：Array，传递给事件的其他参数，参考文档 39 Widget Styles 组件默认含有 box-shadow、background-color 等样式，可在组件根节点通过以下样式调整或根据实际情况自行覆盖。 名称 类型 说明 shadow prop 组件阴影，可选值：always、hover、never，默认值：always .bg-transparent class 组件背景透明 40 Widget Directory dashboard 组件统一存放目录： 通用组件：@/components/Dashboard/widgets/ 模块组件：@/views/{module_name}/widgets/ ","date":"2023-10-12","objectID":"/posts/dashborad-widget-docs/:0:0","tags":["拖拽式仪表盘","dashboard","widget","Vue2"],"title":"拖拽式仪表盘 - 组件配置文档","uri":"/posts/dashborad-widget-docs/"},{"categories":["Vue.js"],"content":"Dashboard 组件 1 是一个公共模板组件，用于快速创建 Dashboard 页面。 33 Basic Usage 每个模块的 dashboard 页面可继承 Dashboard 组件，如： \u003cscript\u003e import Dashboard from '@/components/Dashboard' export default { name: 'Dashboard', extends: Dashboard, } \u003c/script\u003e 使用 registerComponents 函数注册组件，通用组件模板中默认已导入，模块组件需要自行导入，如： \u003cscript\u003e import Dashboard, { registerComponents } from '@/components/Dashboard' // 加载 widgets 目录下所有组件 const requireComponents = require.context('./widgets', true, /\\.vue$/) const components = registerComponents(requireComponents) export default { name: 'Dashboard', extends: Dashboard, created() { // 加载组件列表 this.addComponents('组件分类', components) }, } \u003c/script\u003e 设置默认布局 \u003cscript\u003e import Dashboard, { registerComponents } from '@/components/Dashboard' // ... export default { name: 'Dashboard', extends: Dashboard, data() { return { // 设置默认布局 defaultLayout: [ { i: 1, component: 'ExampleWidget', name: '便利贴', x: 0, y: 0, w: 8, h: 8, params: { content: 'hello world!' }}, // ... ], } }, // ... } \u003c/script\u003e 完整例子详见 @/views/dashboard/index.vue 页面。 34 Export registerComponents (Function): 注册组件（widget.disabled 为 true 的组件不注册） param requireComponents (Function): require.context 函数 return (Array) 已注册的组件列表 35 Provide 提供当前 dashboard 实例给后代组件注入，用于后代组件访问容器内的属性或方法。 $dashboard (Object): 当前 dashboard 容器实例 36 Data Properties componentsList (Array): 组件列表 e.g. [{ category: ‘分类名称’, components: [组件列表] }] isCollapse (Boolean): 是否折叠侧边栏 colNum (Number): 栅格列数 rowHeight (Number): 栅格行高 gaps (Array): 栅格间隙 [水平间隙，垂直间隙] e.g. [8, 8] dashboardGrid (Element): 可接收拖放的栅格容器 dashboardList (Array): 仪表盘列表 dashboard (Object): 仪表盘数据 id (Number): 仪表盘 ID route (String): 路由名称 name (String): 仪表盘名称 layout (Array): 组件布局数据 aside (String): 侧边栏位置（left 或 right） compact (Boolean): 是否垂直压缩布局 isDefault (Boolean): 是否默认布局 responsive (Boolean): 是否响应式布局 loading (Boolean): 是否正在加载/保存布局数据 defaultLayout (Array): 默认布局组件数据 hasEditPermission (Boolean): 是否有编辑权限 selectedCategory (String): 已选中的组件分类 menuCollapse (Boolean): 是否折叠组件分类菜单 37 Computed Properties selectedDashboardId (Number): 已选中的仪表盘 ID components (Array): 所有已注册组件，用于 dashboard 布局中的组件渲染，包含 hidden 为 true 的组件 componentsListAvailable (Array): 过滤后的组件列表，用于组件列表显示，过滤 hidden 为 true 的组件，过滤组件列表为空的分类 componentsByCategory (Array): 根据 selectedCategory 获取对应的组件列表 38 Methods 38.1 notify(message, type = ‘success’) dashboard 显示通知 参数 类型 说明 message String 通知内容 type String 通知类型，可选值：success、warning、info、error 38.2 addComponents(category, components, isPrepend = false) 添加组件列表及分类 参数 类型 说明 category String 组件分类 components Array 组件列表 isPrepend Boolean 是否追加到组件列表开头 38.3 selectCategory(category) 选中组件分类时显示对应的组件列表 参数 类型 说明 category String 组件分类 38.4 switchDashboard(id) 切换仪表盘 参数 类型 说明 id Number/String 仪表盘 ID 或者 ’new’ 38.5 handleCommand(type) 处理仪表盘操作 参数 类型 说明 type String 操作类型，可选值：copy、edit、delete 38.6 guide() 打开新手引导 38.7 refreshAllItems() 刷新容器内所有组件的数据 38.8 clearLayout() 清空布局 38.9 idIncrement() 生成一个自增的 id，用于组件的唯一标识 i 38.10 sortItems() 对 layout 数据进行排序，按照 y 坐标从小到大，x 坐标从小到大的顺序 38.11 addItem(component, widget) 添加组件到 layout 中 参数 类型 说明 component String 组件名称，对应组件的 name 属性 widget Object 组件配置对象，对应组件的 widget 属性 38.12 removeItem(i, save = true) 从 layout 中移除组件 参数 类型 说明 i String 组件的唯一标识 save Boolean 是否立即保存布局数据 38.13 confirmRemoveItem(i) 用户删除组件双重确认 参数 类型 说明 i String 组件的唯一标识 38.14 hasHook(component, hook) 判断组件是否有配置对应的 hook 参数 类型 说明 component String 组件名称，对应组件的 name 属性 hook String 需要判断的 hook 名称 38.15 triggerHook(item, hook, args = [], save = false) 容器内的组件触发对应的 hook 参数 类型 说明 item Object 组件实例数据，参考文档 hook String 需要触发的 hook 名称 args Array 传递给 hook 的其他参数 save Boolean 触发 hook 后是否立即保存布局数据 38.16 mouseInGrid(x, y) 判断鼠标是否在容器内 参数 类型 说明 x Number 鼠标 x 坐标 y Number 鼠标 y 坐标 38.17 removeUnExistItems(fromLayout) 移除 layout 中不存在于所有已注册组件的组件 参数 类型 说明 fromLayout Object layout 数据 38.18 dragStart(e) 开始拖动 组件/侧栏 时，设置拖动来源 参数 类型 说明 e Event event 38.19 dragEnd(e) 结束拖动 组件/侧栏 时，清空拖动来源 参数 类型 说明 e Event event 38.20 drag(component, widget, e) 拖动组件时，记录拖动的组件信息和显示拖动轨迹 参数 类型 说明 component String 组件名称，对应组件的 name 属性 widget Object 组件配置对象，对应组件的 widget 属性 e Event event 38.21 ","date":"2023-10-12","objectID":"/posts/dashborad-template-docs/:0:0","tags":["拖拽式仪表盘","dashboard","Vue2"],"title":"拖拽式仪表盘 - 布局模板文档","uri":"/posts/dashborad-template-docs/"},{"categories":["Vue.js"],"content":"1 仪表盘简介 仪表盘（dashboard）作为一种直观、灵活的数据可视化工具，正在越来越多地应用于各种领域，帮助用户实时监控和分析数据。常见于各类数据分析平台、数据可视化平台、数据大屏等场景。 传统的仪表盘往往是开发者固定好的，用户只能使用，无法自定义。而拖拽式仪表盘则可以让用户自由地选择、拖拽、调整仪表盘中的各种组件，从而实现自定义的仪表盘。 2 功能需求 由于本系列文章写作在设计和开发之后，所以先一睹为快，看看最终的效果：在线 Demo 技术背景是基于 Vue2 实现，功能需求大致如下： 2.1 布局需求 仪表盘布局是拖拽式仪表盘的核心功能之一。布局应该是一个可复用的模板，因为对于一个中后台系统，往往会有多个仪表盘，所有基础功能应该提炼出来，以便于快速复用。 组件拖放到布局容器中时，用户应能够自由拖拽、调整组件的大小和位置，也可以对组件进行排序、刷新、删除等操作 允许创建、删除、复制布局，每个布局可以有不同的组件排列 2.2 组件需求 统一的配置项（宽高、是否可调整大小、各种事件钩子等） 组件分类 自动加载组件列表 组件独立（每个组件有自己完整的生命周期） 每个组件应该拥有相同的配置项，以便于按照相同的规范限制进行后续的组件开发。 组件统一存放在一个文件夹中，仪表盘模板自动加载这个文件夹中的所有组件到组件列表。 组件列表中的组件可以通过拖拽或者点击添加到布局容器中。 组件需要有分类，例如：模块 A 的组件、模块 B 的组件等。因为虽然系统中的每个模块的仪表盘只需要显示当前模块相关的图表组件，但是整个系统的仪表盘需要显示各个模块的图表统计数据，所以需要对组件进行分类。 另外，应该有一个通用分类，用于存放所有模块都可以使用的组件。例如：便签、天气组件、时间组件等。 2.3 布局和组件交互 仪表盘布局内通常有多个组件，布局和组件之间可能需要进行交互，例如： 点击总的刷新按钮，所有组件都刷新；点击某个组件的刷新按钮，只刷新当前组件 点击某个组件的设置按钮，弹出设置框，设置当前组件的配置项保存到当前布局数据中 点击某个组件的删除按钮，从当前布局数据中删除当前组件 …… 2.4 用户角色和权限管理需求 在拖拽式仪表盘中，不同用户角色可能具有不同的访问权限和操作权限。 管理员拥有完整的权限： 可以查看所有仪表盘 可以编辑所有仪表盘 可以删除除默认仪表盘之外的所有仪表盘 可以拖拽、调整所有组件在仪表盘中的位置和大小 普通用户只能永远部分权限： 可以查看所有仪表盘 工作台仪表盘可以新增、删除、编辑组织内可见的仪表盘布局 工作台仪表盘可以拖拽、调整组件在非默认仪表盘布局中的位置和大小 其他模块的仪表盘只能查看和刷新，不能编辑 3 总结 通过分析，简单来说，拖拽式仪表盘的功能需求主要包括： 布局需求 组件需求 布局和组件交互 用户角色和权限管理需求 了解清楚需求后，下一篇文章将探讨拖拽式仪表盘的布局模板设计。 ","date":"2023-10-12","objectID":"/posts/dashboard-analysis/:0:0","tags":["拖拽式仪表盘","dashboard","Vue2","需求分析"],"title":"拖拽式仪表盘 - 功能需求分析","uri":"/posts/dashboard-analysis/"},{"categories":["Spec"],"content":"会写 Markdown 的人很多，但写得好 Markdown 的人却很少。有没有什么工具能充当「秘书」，检查文件中的 Markdown 语法和风格，并且提出解决方案、自动修复问题，甚至自动补齐中英文之间的「盘古之白」呢？本文介绍的 Markdown 语法检查器就能做到。 21 引言 会写 Markdown 的人很多，但写得好 Markdown 的人却很少。这一方面是 Markdown 生态系统自身的问题：语法变种和实现方式 五花八门，互不兼容甚至相互矛盾。 另一方面，也鲜有人愿意花时间去仔细阅读 Markdown 的技术规范；大多数人都只是读了一两篇「速成」，就自我批准出师了，对于一些细节问题并未关注；如果在写作中遇到，也是凭想象和直觉随意判断。 由此，就产生了大量语法天马行空、版面张牙舞爪，让读者和排版软件都困惑不已的 Markdown 文件。 既然 JavaScript 有 ESLint，Python 有 PyLint，是不是 Markdown 也有 markdownlint 呢？答案是肯定的！ 22 示例 本博客源码已引入 markdownlint 规范，可下载本博客源码查看配置。 Lruihao/hugo-blog http://github.com/Lruihao/hugo-blog 23 引入 markdownlint markdownlint 是一个 Markdown 语法检查工具，它可以检查 Markdown 文件中的语法错误，以及一些不规范的写法，让 Markdown 干净又卫生。 markdownlint 有两个版本，分别是 Mark Harrison 基于 Ruby 的 原版 和 David Anson 基于 Node.js 的 移植版。Node.js 版在人气和活跃程度上后来居上，本文也以 Node.js 版为例。 markdownlint 可以在多个场景下使用，包括： 在线版 VSCode 扩展 markdownlint-cli 和 markdownlint-cli2 本文主要的目的是介绍 markdownlint-cli2 的使用，因为它可以在项目中集成，方便团队协作。 23.1 markdownlint cli 历史 根据 David 的博客1，在大约 2015 年左右 Igor Shubovych 和他探讨了开发 CLI 工具的想法，当时，David 还没做好准备，所以 Igor 独自开发了 markdownlint-cli 这个 CLI 工具。 经过两年的发展，越来越多的人开始使用 markdownlint-cli，于是 David 开始给 markdownlint-cli 项目贡献代码，添加新功能，并在之后三年里成为了主要的维护人员。直到 2020 年，David 觉得在别人的项目中，很难改变一些事情（可能涉及向后兼容性的问题），因此他重新建立了一个名叫 markdownlint-cli2 的项目，在 markdownlint-cli 的基础上进行了改进，使其具有更快的执行速度、更灵活的配置和更少的依赖等优点。 目前，这两个工具仍然随着 markdownlint 的更新而更新。如果已经在使用 markdownlint-cli 的旧项目，可以继续使用它，以避免出现未知的问题。而对于新引入的项目，可以考虑使用更强大的 markdownlint-cli2。 23.2 安装 markdownlint-cli2 npm install markdownlint-cli2 --save-dev 配置快捷命令： { \"scripts\": { \"lint:md\": \"markdownlint-cli2 \\\"content/**/*.md\\\"\", \"fix:md\": \"npm run lint:md -- --fix\" } } 安装 markdownlint-rule-search-replace 插件2： npm install markdownlint-rule-search-replace --save-dev 在项目根目录下创建 .markdownlint.jsonc 文件，配置规则： // This file defines our configuration for Markdownlint. See // https://github.com/DavidAnson/markdownlint/blob/main/doc/Rules.md // for more details on each rule. { \"default\": true, \"ul-style\": { \"style\": \"dash\" }, \"ul-indent\": { \"indent\": 2 }, \"no-hard-tabs\": { \"spaces_per_tab\": 2 }, \"line-length\": false, \"no-duplicate-header\": { \"allow_different_nesting\": true }, \"single-title\": { \"front_matter_title\": \"^\\\\s*title\\\\s*[:=]\" }, \"no-trailing-punctuation\": { \"punctuation\": \".,;:\" }, // Consecutive Notes/Callouts currently don't conform with this rule \"no-blanks-blockquote\": false, // Force ordered numbering to catch accidental list ending from indenting \"ol-prefix\": { \"style\": \"ordered\" }, \"no-inline-html\": { \"allowed_elements\": [ \"br\", \"code\", \"details\", \"div\", \"img\", \"kbd\", \"p\", \"pre\", \"sub\", \"summary\", \"sup\", \"table\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\", \"ul\", \"ol\", \"var\", \"ruby\", \"rp\", \"rt\", \"i\" ] }, \"no-bare-urls\": false, // Produces too many false positives \"fenced-code-language\": false, \"code-block-style\": { \"style\": \"fenced\" }, \"no-space-in-code\": false, \"emphasis-style\": { \"style\": \"underscore\" }, \"strong-style\": { \"style\": \"asterisk\" }, // https://github.com/OnkarRuikar/markdownlint-rule-search-replace \"search-replace\": { \"rules\": [ { \"name\": \"nbsp\", \"message\": \"Don't use no-break spaces\", \"searchPattern\": \"/ /g\", \"replace\": \" \", \"searchScope\": \"all\" }, { // zh-cn/zh-tw prefers double em-dash instead \"name\": \"em-dash\", \"message\": \"Don't use '--'. Use em-dash (—) instead\", \"search\": \" -- \", \"replace\": \" — \", \"searchScope\": \"text\" }, { \"name\": \"trailing-spaces\", \"message\": \"Avoid trailing spaces\", \"searchPattern\": \"/ +$/gm\", \"replace\": \"\", \"searchScope\": \"all\" }, { \"name\": \"double-spaces\", \"message\": \"Avoid double spaces\", \"searchPattern\": \"/([^\\\\s\u003e]) ([^\\\\s|])/g\", \"replace\": \"$1 $2\", \"searchScope\": \"text\" }, { \"name\": \"stuck-definition\", \"message\": \"Character is stuck to definition description marker\", \"searchPattern\": \"/- :(\\\\w)/g\", \"replace\": \"- : $1\", \"searchScope\": \"text\" }, { \"name\": \"localhost-links\", \"message\": \"Don't use localhost for links\", \"searchPattern\": \"/\\\\]\\\\(https?:\\\\/\\\\/localhost:\\\\d+\\\\//g\", \"replace\": \"](/\", \"searchScope\": \"text\" }, // zh-cn prefers rules { \"name\": \"double-em-dash\", \"mess","date":"2023-10-11","objectID":"/posts/markdownlint/:0:0","tags":["Markdown","markdownlint","pangu.js","AutoCorrect"],"title":"给你的 Markdown 挑挑刺","uri":"/posts/markdownlint/"},{"categories":["Spec","翻译"],"content":"1 摘要 循环复杂度（Cyclomatic Complexity）最初被制定为衡量模块控制流的“可测试性和可维护性”的一种度量标准。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。 1.1 术语说明 虽然认知复杂度（Cognitive Complexity）是一种语言中立的度量标准，同样适用于文件和类，以及方法、过程、函数等等，但为了方便起见，本文中使用面向对象的术语“类”和“方法”。 2 引言 循环复杂度（Cyclomatic Complexity）是一种用于衡量代码中控制流的度量标准，它最初是由 Thomas J. McCabe 在 1976 年提出的。1 该度量标准的目的是衡量代码的“可测试性和可维护性”。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。 与此同时，循环复杂度已经不再全面。它于 1976 年在 Fortran 环境中制定，不包括像 try/catch 和 lambda 这样的现代语言结构。 最后，由于每个方法的最小循环复杂度分数为 1，我们无法知道具有高聚合循环复杂度的任何给定类是一个大型、易于维护的域类，还是一个具有复杂控制流的小型类。除了类级别之外，广泛认可的观点是应用程序的循环复杂度得分与其代码行数总和相关。换句话说，循环复杂度在方法级别以上几乎没有用处。 为了解决这些问题，认知复杂度（Cognitive Complexity）已经被制定出来，以解决现代语言结构的问题，并产生在类和应用程序级别上有意义的值。更重要的是，它摒弃了基于数学模型评估代码的做法，以便能够提供与程序员对理解流程所需的心智或认知努力的直觉相符的控制流评估。 3 问题示例 从一个示例开始讨论认知复杂度可以帮助理解它的应用对象。下面的两个方法具有相同的循环复杂度，但在可理解性方面却存在明显的差异。 循环复杂度的数学模型给予这两个方法相同的权重，然而直观上很明显，sumOfPrimes 方法的控制流比 getWords 方法更难理解。这就是为什么认知复杂度放弃了使用数学模型评估控制流的做法，而采用了一组简单的规则，将程序员的直觉转化为数字。 4 基本准则和方法 根据三个基本规则来评估认知复杂度得分： 忽略允许多个语句可读性缩写成一个的结构 每次中断代码的线性流程时增加一个（加一） 嵌套时进行增量计算 此外，复杂度得分由四种不同类型的增量组成： A. 嵌套（Nesting）— 对嵌套控制流结构进行评估 B. 结构（Structural）— 对受嵌套增量影响并增加嵌套计数的控制流结构进行评估 C. 基础（Fundamental）— 对不受嵌套增量影响的语句进行评估 D. 混合（Hybrid）— 对不受嵌套增量影响的控制流结构进行评估 虽然在数学上，增量的类型没有影响，每个增量都会将最终得分增加一点，但对被计数的特征类别进行区分可以更容易地理解嵌套增量适用和不适用的地方。 这些规则及其背后的原则在以下章节中进一步详细介绍。 5 忽略简写 在制定认知复杂度的过程中，一个指导原则是它应该激励良好的编码实践。也就是说，它应该忽略或减少使代码更易读的特性。 方法的结构本身就是一个很好的例子。将代码分解为方法可以将多个语句压缩为一个具有描述性名称的调用，即“简写（shorthand）”。因此，认知复杂度不会针对方法进行增量计算。 认知复杂度还忽略许多编程语言中常见的空合并运算符，因为它们允许将多行代码缩减为一行。例如，下面两个代码示例执行相同的操作： 左侧版本的含义需要一些时间来理解，而一旦理解了空合并语法，右侧版本就立即清晰明了。因此，认知复杂度忽略了空合并运算符。 6 中断线性流程 在制定认知复杂度的过程中，另一个指导原则是打破代码从上到下、从左到右的正常线性流程的结构会使维护者在理解代码时需要付出更多的努力。为了认可这种额外的努力，认知复杂度对以下结构进行结构增量评估： 循环结构：for、while、do while、… 条件判断：三元运算符、if、#if、#ifdef、… 它对混合增量进行评估： else if、elif、else、… 对于这些结构，不会评估嵌套增量，因为在阅读条件语句时已经承担了心理成本。 这些增量目标对于那些习惯于圈复杂度的人来说可能会很熟悉。此外，认知复杂度还会增加以下方面的复杂度： 6.1 捕获（Catches） catch 语句与 if 语句一样，代表了控制流程中的一种分支。因此，每个 catch 子句都会对认知复杂度进行结构增量评估。请注意，无论捕获了多少种异常类型，每个 catch 子句只会给认知复杂度得分增加一个点。try 和 finally 块则完全被忽略。 6.2 开关（Switches） 一个 switch 语句及其所有的 case 合并会导致一个单独的结构增量。 在圈复杂度中，switch 语句被视为类似于 if-else if 链的模拟。也就是说，switch 语句中的每个 case 都会导致增量，因为它在控制流的数学模型中引起了一个分支。 但是从维护者的角度来看，一个 switch 语句，它将一个变量与一组明确命名的字面值进行比较，比一个 if-else if 链容易理解得多，因为后者可能进行任意数量的比较，使用任意数量的变量和值。 简而言之，必须仔细阅读 if-else if 链，而 switch 语句通常可以一目了然地理解。 6.3 逻辑运算符序列（Sequences of logical operators） 出于类似的原因，认知复杂度不会对每个二进制逻辑运算符进行增量计算。相反，它对每个二进制逻辑运算符序列进行基本增量评估。例如，考虑以下几对示例： a \u0026\u0026 b a \u0026\u0026 b \u0026\u0026 c \u0026\u0026 d a || b a || b || c || d 理解每对示例中的第二行并不比理解第一行困难太多。然而，对于理解下面两行的努力确实存在明显的差异： a \u0026\u0026 b \u0026\u0026 c \u0026\u0026 d a || b \u0026\u0026 c || d 因为混合运算符的布尔表达式变得更难理解，所以认知复杂度会对每个新的相同运算符序列进行增量计算。例如： if (a // +1 for `if` \u0026\u0026 b \u0026\u0026 c // +1 || d || e // +1 \u0026\u0026 f) // +1 if (a // +1 for `if` \u0026\u0026 // +1 !(b \u0026\u0026 c)) // +1 虽然相对于圈复杂度，认知复杂度对相同的运算符提供了一种“折扣”，但它会对所有的二元布尔运算符序列进行增量计算，例如变量赋值、方法调用和返回语句中的序列。 6.4 递归（Recursion） 与圈复杂度不同，认知复杂度对递归循环中的每个方法（无论是直接递归还是间接递归）都会增加一个基本增量。 这个决定有两个动机。首先，递归代表了一种“元循环（meta-loop）”，而认知复杂度对循环进行增量计算。其次，认知复杂度旨在估计理解方法控制流的相对难度，即使对一些经验丰富的程序员来说，递归也很难理解。 6.5 跳转到标签（Jumps to labels） 使用 goto 语句会给认知复杂度增加一个基本增量，同样的，使用带有标签的 break 或 continue 语句以及其他多级跳转（如某些语言中的带有数字的 break 或 continue 语句）也会增加增量。但是，因为提前返回通常可以使代码更清晰，其他跳转或提前退出不会增加增量。 7 嵌套流程中的增量 直观上很明显，一系列线性的五个 if 和 for 结构比相同的五个结构连续嵌套更容易理解，而不管每个系列中的执行路径数量如何。因为这样的嵌套增加了理解代码的心理需求，认知复杂度对其进行了嵌套增量的评估。 具体来说，每当一个导致结构增量或混合增量的结构嵌套在另一个这样的结构内部时，每个嵌套级别都会增加一个嵌套增量。例如，在下面的示例中，对于方法本身或 try 语句，都没有嵌套增量，因为这两个结构都不会导致结构增量或混合增量： 然而，if、for、while和catch结构都会受到结构增量和嵌套增量的影响。 此外，顶层方法会被忽略，并且 lambda 表达式、嵌套方法和类似特性不会导致结构增量，但当这些方法嵌套在其他类似方法的结构内部时，会增加嵌套级别： 8 影响 认知复杂度的主要目标是计算方法分数，以更准确地反映方法的相对可理解性，并且其次目标是处理现代语言结构并生成在方法级别以上有价值的度量标准。可以证明，处理现代语言结构的目标已经实现。下面将对另外两个目标进行详细讨论。 8.1 直观地“正确”的复杂性分数 这次讨论始于一对具有相等圈复杂度但明显不同可理解性的方法。现在是重新审视这些方法并计算它们的认知复杂度分数的时候了。 认知复杂度算法给出了这两个方法明显不同的分数，这些分数更能反映它们相对可理解性的差异。 8.2 高于方法级别的有价值的指标 此外，由于认知复杂度不会针对方法结构增加增量，聚合的数值变得有用起来。现在，通过比较它们的度量值，你可以轻松区分一个包含大量简单的 getter 和 setter 的领域类和一个包含复杂控制流的类。因此，认知复杂度成为衡量类和应用程序相对可理解性的工具。 9 结论 编写和维护代码是人类过程，它们的输出必须符合数学模型，但它们本身并不适合数学模型。","date":"2023-10-08","objectID":"/posts/cognitive-complexity/:0:0","tags":null,"title":"认知复杂度（Cognitive Complexity）","uri":"/posts/cognitive-complexity/"},{"categories":["Memo"],"content":"最近读了张鑫旭大佬的掘金小册《技术写作指南》，学到了很多写作技巧，其中感触最深的就是“技巧：如何搭建文章的框架结构”这一小节，这篇文章就来分享一下。 17 方法论的作用 所谓方法论，通俗点讲就是套路，虽然限制了天才的火花，但是保证了合格的下限。 这个不难理解，拿武侠举例，每个门派都有剑招或者拳法，招式都是固定的，这个固定的招式就可以看成是方法论，而武功的最高境界是无招胜有招，讲求见招拆招，是不希望有固定的套路的。 但是，这些固定的招数你又不能不学，因为天才总是少数，而学习固定的招式，至少可以保证门派弟子比路人强一截。 学习如何说话，学习如何写作也是类似的，对于那些天生会说话，天生会写作的人而言，方法论反而是个桎梏，会限制他们的发挥。 但是对于原本不是这块料的人而言，方法论可以让你迅速进入学习的正轨，保证了实践结果不至于太差。 张鑫旭大佬结合自己的写作经验，总结出了一套核心思想，并抽象出了若干写作方法论。 18 核心思想 文章书写的核心思想无非这两个： 文字前后连贯； 内容重点突出。 这些核心思想和人类的认知特点正好是相匹配的。 … 19 具体的写作套路 这里按照文章类型的不同讲下可以拿来套用的写作路数。 正所谓一图胜千言，每一种写作结构都做了示意图。 19.1 1. 技术科普 技术科普是人人都可以创作的一种文章类型，这类文章适合新人阅读，受众广泛。 这类文章结构可以如下图这般搭建： graph LR A[\"作用是什么？ （亮点前置）\"] B((\"效果演示 (如果有)\")) C[\"语法和参数\"] D[\"具体使用说明 （主要篇幅）\"] E{\"案例\"} F[\"细节知识（包括兼容性）\"] G[\"点评总结 （稀缺内容）\"] A---B---C---D---F---G D-.-\u003eE graph LR A[\"作用是什么？ （亮点前置）\"] B((\"效果演示 (如果有)\")) C[\"语法和参数\"] D[\"具体使用说明 （主要篇幅）\"] E{\"案例\"} F[\"细节知识（包括兼容性）\"] G[\"点评总结 （稀缺内容）\"] A---B---C---D---F---G D-.-\u003eE 很多在线文档也是按照这个结构撰写的。 19.2 2. 原理剖析 原理剖析类的文章对于创作者加深对当前技术的理解很有帮助，虽然受众不一定广泛，但是对于自身的学习却很有帮助。 通常，这类文章可以遵循由表及里，层层深入的架构策略，方便他人的学习与理解。 graph LR A[现象描述] B((\"想象演示 （视频或图片）\")) C[解释说明] D[基本概念] E[浅层原因] F[\"更深入解释 （体现专业深度）\"] G[\"启示与拓展 （稀缺内容）\"] D-.-\u003eC A---B---C---F---G E-.-\u003eC graph LR A[现象描述] B((\"想象演示 （视频或图片）\")) C[解释说明] D[基本概念] E[浅层原因] F[\"更深入解释 （体现专业深度）\"] G[\"启示与拓展 （稀缺内容）\"] D-.-\u003eC A---B---C---F---G E-.-\u003eC19.3 3. 功能实现 我们所有的互联网产品都是通过一个又一个的功能实现的，比方说“鼠标经过按钮变色”就属于一个功能，点击按钮复制内容也属于功能。 所有这些功能的实现都可以创作成文章，而这些文章会成为搜索引擎流量来源大户。 因为很多开发者在实现某一个功能的时候，都习惯先去找找有没有现成的代码可以直接拿来使用。 这就要求我们在文章中一定要放代码，最后配上演示页面，然后为了吸引用户继续阅读，通常会把实现好的效果放在最前面，即上面提到的亮点前置。 所以，可以尝试使用下图所示的文章结构： graph LR A[功能或效果说明] B((效果演示)) C[在线 demo] D[视频或截图] E[实现思路] F[\"实现代码 （读者最关心）\"] G[实现原理] H[总结与拓展] C-.-\u003eB E-. 你也可以在这个位置 .-\u003eG A---B---E---F---G---H D-.-\u003eB graph LR A[功能或效果说明] B((效果演示)) C[在线 demo] D[视频或截图] E[实现思路] F[\"实现代码 （读者最关心）\"] G[实现原理] H[总结与拓展] C-.-\u003eB E-. 你也可以在这个位置 .-\u003eG A---B---E---F---G---H D-.-\u003eB19.4 4. 使用教程 每个人对教程的理解不一样，在我的写作认知中，教程专指针对小白的那种奶妈式的教学文章，会非常详细与具体，会有大量的配图与案例，生怕对方走错一步就不知道接下来该怎么办。 这类文章其实按部就班呈现就可以了： graph LR A[\"背景说明 （如果有）\"] B[\"步骤1/操作1 （注意事项或示意图）\"] C[\"步骤2/操作2 （注意事项或示意图）\"] D[\"步骤3/操作3 （注意事项或示意图）\"] E[其他说明] A---B---C---D-- ... ---E graph LR A[\"背景说明 （如果有）\"] B[\"步骤1/操作1 （注意事项或示意图）\"] C[\"步骤2/操作2 （注意事项或示意图）\"] D[\"步骤3/操作3 （注意事项或示意图）\"] E[其他说明] A---B---C---D-- ... ---E19.5 5. 问题解决 如果问题解决的过程是写给公司内部的人（尤其是领导）看的，或者说写作的目的是炫一把自己解决问题的能力，则自己的思考过程一定要重点阐述。 如果你写作的目的很单纯，就是希望帮助外面遇到同样问题的人，那就可以多讲讲问题产生的原因，以及如何解决即可，别人对你的思考过程并不在意。 下面这个文章结构示意图是按照内部创作的背景设计的，强调个人在整个过程中的能动性。 graph LR A[\"背景描述 （如果有）\"] B[问题描述] C((\"问题演示 （视频或图片）\")) D[\"我的思考 再次思考 ...\"] E[\"初次尝试 再次尝试 ...\"] F{结果} G[结语] A---B---C---D==\u003eE==\u003eF-- YES --\u003eG F== NO ==\u003eD graph LR A[\"背景描述 （如果有）\"] B[问题描述] C((\"问题演示 （视频或图片）\")) D[\"我的思考 再次思考 ...\"] E[\"初次尝试 再次尝试 ...\"] F{结果} G[结语] A---B---C---D==\u003eE==\u003eF-- YES --\u003eG F== NO ==\u003eD如果你是对外创作，则可以根据侧重点不同，微调写作结构。 19.6 6. 项目总结 项目总结一定是对内的，即使我们在外网看到一些大公司团队发的项目总结类的文章，也是内销转出口。 这类文章一般看起来都很高大上，但读完一阵空虚，啥也没学到。 这是正常且理所当然的，因为项目总结的目的本质上就是一种职场邀功炫技手段，而不是技术传道。 所以，这类文章的难点不在于结构设计，而是如何通过不会让人反感的朴实无华的语言透露出项目牛逼、项目人员牛逼的信息。 graph LR A[项目背景] B[取得的成绩] C((漂亮数据\\n或最终效果)) E[贡献] F[困难与解决] G[成长] H[主体可以是个人一可以是团队] I[总结] J[感谢] C-.-\u003eB A---B---D---I---J subgraph D[\"项目详情（根据实际情况调整）\"] direction BT E \u0026 F \u0026 G---H end graph LR A[项目背景] B[取得的成绩] C((漂亮数据\\n或最终效果)) E[贡献] F[困难与解决] G[成长] H[主体可以是个人一可以是团队] I[总结] J[感谢] C-.-\u003eB A---B---D---I---J subgraph D[\"项目详情（根据实际情况调整）\"] direction BT E \u0026 F \u0026 G---H end19.7 7. 会议记录 国内每年都会有很多技术峰会，当然，这几年因为口罩原因，多以线上为主了。 然后各个城市还有不少免费的技术沙龙，各个技术社区也会有一些免费的线上活动，一些知名行业从业者也会不定期直播，因此，只要你有兴趣，都可以作为观众参与其中。 参加完了，是不是可以写篇文章记录下呢？ 跟大家讲，这种文章不需要技术含量，但是访问量相当的高，因为人都是懒惰的，总希望以最低的成本收获最多的东西。 一看，嘿，这个不错，我只要花几分钟看一下，就能学到别人花好几个小时学到的东西，何乐而不为呢？哪怕什么都没学到，至少满足了自己的好奇心，怎么看都不亏。 而这类文章的内容结构也比较固定，就按照时间进行组织就好了，会议的按会议时间，直播的按直播时间。 graph LR A[\"会议简介 （时间、与会人等）\"] B((\"现场照片 （如果有）\")) C[\"过程1 点评（如果有）\"] D[\"过程2 点评（如果有）\"] E[\"过程3 点评（如果有）\"] F[自己的感受] A---B--\u003eC-- 时间 --\u003eD-- 顺序 --\u003eE-- ... ---F graph LR A[\"会议简介 （时间、与会人等）\"] B((\"现场照片 （如果有）\")) C[\"过程1 点评（如果有）\"] D[\"过程2 点评（如果有）\"] E[\"过程3 点评（如果有）\"] F[自己的感受] A---B--\u003eC-- 时间 --\u003eD-- 顺序 --\u003eE-- ... ---F19.8 8. 工具测评 这类文章也非常适合新手创作，大家应该也都见过，比方说某某框架初体验、A 框架和 B 框架我该使用哪个？ 这类文章的核心价值就在于评测，你以一个过来人的身份，是否建议读者使用这个工具之类的。 但评测是否中肯可信，还需要一些证明，这些证明就","date":"2023-09-26","objectID":"/posts/article-structure/:0:0","tags":null,"title":"写作技巧：如何搭建文章的框架结构？","uri":"/posts/article-structure/"},{"categories":["Vue.js"],"content":"一个用于实现 Element UI (Vue 2) 表格的表头吸顶、表尾吸底、滚动条吸底以及高度自适应功能的指令集插件。","date":"2023-09-25","objectID":"/projects/el-table-sticky/","tags":["Vue2"],"title":"如何让 Element UI 表头、表尾、横向滚动条吸顶吸底固定？","uri":"/projects/el-table-sticky/"},{"categories":["Vue.js"],"content":"本文将介绍如何通过自定义指令的方式实现 Element UI 表格的表头吸顶、表尾吸底、滚动条吸底以及高度自适应功能。 1 背景 Element UI 的表格组件在使用时，如果表格内容过多，表格会出现滚动条，但是表头不会吸顶，表尾合计行也不会吸底，这样在表格内容过多时，表头和表尾合计行就会被遮挡，如果有横向滚动条，每次想滚动必须滑动到最底下，这一系列痛点，非常影响用户体验。 Element UI 的解决办法：通过设置 max-height 或者 height 属性来实现上述需求。 Element UI 的解决不足点：高度值只支持设置数字型，在实际开发中往往需要借助 JS 来计算。 为了解决以上痛点/需求，减少开发和维护成本，于是我开发了 el-table-sticky 插件，在线示例。 el-table-stick https://github.com/Lruihao/el-table-sticky 如果你觉得这个插件还不错，赏个 star 吧 😛，如果你有更好的实现方案，欢迎提 issue 或者 PR。 2 解决思路 el-table-sticky 插件从两个不同的角度解决问题： 通过 position: sticky 属性，让 el-table 的表头等元素固定 沿用 Element UI 的 max-height 和 height 属性，通过自定义指令的方式，让 el-table 的表格内容高度自适应 插件包含 4 个指令： v-sticky-header：表头吸顶 v-sticky-footer：表尾吸底 v-sticky-scroller：横向滚动条吸底 v-height-adaptive：高度自适应 目前 4 个指令在 1.x 版本都已开发完成，已发布到 npm 上，可通过以下命令安装： npm install @cell-x/el-table-sticky 具体使用方式，本文不做赘述，详见 README.md。 接下来，我们来看看如何实现这些功能。 2.1 表头吸顶\u0026表尾吸底 表头吸顶是我最迫切想要解决的问题，所以在 0.x 版本开发完，我就马上发布并在公司老项目中引入了。 思路拆解： 找到 el-table__header 并赋予 sticky top 特性 Debug 发现如果 el-table-column 设置了 fixed 值，Element UI 使用的是 fixed 定位，并将 el-table__header 对应的栏位隐藏 el-table__header sticky 后为了让固定栏位保持和 Element UI 一样的效果，需要找到这些栏位，设置为 sticky，然后按左右方向堆叠位置 实现表头吸顶后，再看表尾合并行吸底效果也就是依葫芦画瓢，思路一样，于是为了复用代码，我抽离出来一个 Sticky Class。 2.2 高度自适应 沿用 Element UI 的 max-height 和 height 属性，所以 el-table 初始化时必须设置高度。 这个就比较简单了，监听 el-table 元素的 resize，然后 JS 计算出表格的可用高度，最后调用 $table.layout.setHeight 设置高度即可。 2.3 横向滚动条吸底 这个指令的实现我放在最后，主要的难点在于如何创建自定义滚动条代替原生滚动条的问题，以下是我的开发过程： 最开始看到了一个插件 el-table-horizontal-scroll，它的做法是手动给 el-table 加上一个 el-scrollbar 并绑定事件处理，于是决定使用它的方案，但是看了源码，它使用的 fixed 定位和我预想有差距，而且手动绑定事件，可能有很多细节遗漏，维护起来或有诸多不便。 然后，我想能不能通过 render 函数直接渲染一个 el-scrollbar，我就去看 el-scrollbar 的源码，打开源码有惊喜，第一行注释找到了gemini-scrollbar 这个插件，打开 Github 看了一下，能够实现预期效果。 开造思路： 在 el-table 中创建一个空元素当作 scroller，宽度保持和表格内容宽度一致 为 scroller 创建自定义滚动条，并赋予 sticky bottom 特性 同步 el-table 横向滚动的行为到 scroller 同步 scroller 横向滚动的行为到 el-table A few moments later… 经过一番 code，实现了横向滚动条的吸底固定效果，但是基于 gemini-scrollbar 实现，存在以下已知问题： safari 浏览器存在兼容性1 当禁用原生滚动条时，gemini-scrollbar 计算滑块偏移距离时存在误差，详见 最后为了简化使用，将 v-sticky-scroller 的功能内置到了 v-sticky-header 和 v-sticky-footer 指令中，使用时无需重复使用。 3 总结 一念对开源蠢蠢欲动，一念对维护犹豫不决，一念成就开源，一念成就自己。 Non sunt multiplicanda entia sine necessitate 若无必要，勿增实体 不到迫不得已，不要轻易造轮子，要善于发现和利用已有的轮子、最理想的状态就是永远站在巨人的肩膀上。 但是通过造轮子，可以更好的学习和理解技术，也能体会到很多写业务代码不能感受到的快乐。 学而不思则罔，思而不学则殆。 如有必要，以后版本需要替换 gemini-scrollbar 实现自定义滚动条的功能。 ↩︎ ","date":"2023-09-25","objectID":"/projects/el-table-sticky/:0:0","tags":["Vue2"],"title":"如何让 Element UI 表头、表尾、横向滚动条吸顶吸底固定？","uri":"/projects/el-table-sticky/"},{"categories":["Vue.js"],"content":"基于 vue-fullscreen 封装一个的 Vue 全屏/退出全屏切换组件。 1 简介 vue-fullscreen 是一个用于将任意页面元素进行全屏切换的 Vue 插件，基于 screenfull。这个插件本身提供了组件、指令以及 API 三种使用方式，具体的使用方法请参考 vue-fullscreen。 2 在线演示 3 安装 npm install vue-fullscreen@^2.6.1 # 或者 yarn add vue-fullscreen@^2.6.1 4 封装组件 vue-fullscreen 有 Vue2 和 Vue3 两个版本，本文将基于其 Vue2 版本的指令使用方式再封装一层。 这个组件会显示为一个切换按钮，通过绑定 target 属性来指定全屏的目标元素，通过 bodyAgent 属性来指定是否使用 document.body 代理全屏元素，目标元素则改为网页全屏，避免弹窗等元素在全屏模式下不可见的问题。 信息 vue-fullscreen 插件处理弹窗等元素在全屏模式下不可见问题的方案是通过 teleport 修饰符将目标元素移动到 document.body 下，从而避免层级遮挡问题。个人不太喜欢这种改变 DOM 结构的方式，所以封装的插件新增一个参数 bodyAgent，当设置为 true 时，会使用 document.body 代理全屏元素，目标元素则改为网页全屏，此时 document.fullscreenElement 为 document.body 而不是真实设置的 target 元素。 \u003c!-- 全屏/退出全屏切换组件，浏览器不支持时，打开网页内全屏 --\u003e \u003cscript\u003e import { directive as fullscreen } from 'vue-fullscreen' export default { name: 'FullScreenToggler', directives: { fullscreen, }, props: { target: { type: String, default: 'document.body', }, /** * 是否使用 document.body 代理全屏元素，目标元素则改为网页全屏 * 避免弹窗等元素在全屏模式下不可见的问题（推荐） */ bodyAgent: { type: Boolean, default: true, }, fullscreenClass: { type: String, default: 'is-fullscreen', }, /** * 不调用全屏 API，而是将当前元素撑满网页 */ pageOnly: { type: Boolean, default: false, }, /** * v-fullscreen 指令修饰符 teleport 进入全屏时目标元素会被移动到 document.body 下 * vue-fullscreen 插件处理弹窗等元素在全屏模式下不可见问题的方案（不推荐） */ teleport: { type: Boolean, default: false, }, }, data() { return { isFullscreen: false, } }, computed: { options() { return { target: this.bodyAgent ? 'document.body' : this.target, callback: (isFullscreen) =\u003e { this.isFullscreen = isFullscreen // 网页全屏 if (this.bodyAgent \u0026\u0026 this.target !== 'document.body') { document.querySelector(this.target).classList.toggle('is-fullscreen-fullpage', isFullscreen) } // 触发事件传递给父组件 this.$emit('change', isFullscreen) }, fullscreenClass: this.fullscreenClass, } }, }, render(h) { return h('span', { class: 'full-screen-toggler', attrs: { title: this.isFullscreen ? '退出全屏' : '全屏', }, directives: [ { name: 'fullscreen', value: this.options, modifiers: { pageOnly: this.pageOnly, teleport: this.teleport, }, }, ], }, [ h('svg-icon', { props: { iconClass: this.isFullscreen ? 'exit-fullscreen' : 'fullscreen', } }), ]) }, } \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e .full-screen-toggler { cursor: pointer; } \u003c/style\u003e \u003cstyle\u003e .is-fullscreen-fullpage { position: fixed !important; top: 0px; left: 0px; width: 100% !important; height: 100% !important; background: white; z-index: 2000; box-sizing: border-box; } \u003c/style\u003e 使用方式如下： \u003ctemplate\u003e \u003cdiv class=\"page-container\"\u003e \u003cfull-screen-toggler target=\".page-container\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import FullScreenToggler from '@/components/FullScreenToggler' export default { components: { FullScreenToggler, }, } \u003c/script\u003e ","date":"2023-09-17","objectID":"/posts/vue-fullscreen-toggler/:0:0","tags":["Vue2","JavaScript"],"title":"封装 Vue FullScreenToggler 组件","uri":"/posts/vue-fullscreen-toggler/"},{"categories":["JavaScript"],"content":"1 背景 在 Web 开发中，全屏模式可以提供更沉浸式的体验，特别适用于视频播放、游戏展示和演示等场景。通过 JavaScript 的 Fullscreen API，我们可以以编程方式控制元素的全屏状态。 Fullscreen API 是一组用于控制全屏显示的方法和属性，它们允许我们将网页内容以全屏的方式展示给用户，并提供了相应的事件来监听全屏模式的变化。 在本文中，我们将介绍如何判断浏览器是否支持全屏功能，如何实现进入全屏和退出全屏的功能，以及如何获取当前全屏元素和监听全屏模式的变化。 注意：Fullscreen API 在不同浏览器之间可能存在差异，请在使用时进行兼容性测试和处理。 2 全屏是否可用 在使用 Fullscreen API 之前，我们需要先判断当前浏览器是否支持全屏功能。可以通过 document.fullscreenEnabled 属性来检查。 以下是一个示例： if (document.fullscreenEnabled || document.mozFullScreenEnabled || document.webkitFullscreenEnabled || document.msFullscreenEnabled) { console.log('浏览器支持全屏功能'); } else { console.log('浏览器不支持全屏功能'); } 详细的 API 说明可以参考 Fullscreen API - MDN Web Docs。 3 实现全屏 要实现全屏，我们可以使用 requestFullscreen() 方法。该方法可用于 DOM 元素，使其进入全屏模式。 以下是一个示例： const element = document.getElementById('my-element'); if (element.requestFullscreen) { element.requestFullscreen(); } else if (element.mozRequestFullScreen) { // Firefox element.mozRequestFullScreen(); } else if (element.webkitRequestFullscreen) { // Chrome, Safari and Opera element.webkitRequestFullscreen(); } else if (element.msRequestFullscreen) { // Internet Explorer and Edge element.msRequestFullscreen(); } 详细的 API 说明可以参考 Element.requestFullscreen() - MDN Web Docs。 4 退出全屏 当我们需要退出全屏时，可以使用 exitFullscreen() 方法。该方法可用于当前处于全屏状态的元素。 以下是一个示例： if (document.exitFullscreen) { document.exitFullscreen(); } else if (document.mozCancelFullScreen) { // Firefox document.mozCancelFullScreen(); } else if (document.webkitExitFullscreen) { // Chrome, Safari and Opera document.webkitExitFullscreen(); } else if (document.msExitFullscreen) { // Internet Explorer and Edge document.msExitFullscreen(); } 详细的 API 说明可以参考 Document.exitFullscreen() - MDN Web Docs。 5 获取全屏元素 在全屏模式下，我们可能需要获取当前处于全屏状态的元素。可以使用document.fullscreenElement属性来获取。 以下是一个示例： const fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement; if (fullscreenElement) { console.log('当前全屏元素：', fullscreenElement); } else { console.log('没有全屏元素'); } 详细的 API 说明可以参考 Document.fullscreenElement - MDN Web Docs。 6 监听全屏模式变化 如果我们希望在全屏模式发生变化时得到通知，可以使用 Fullscreen API 提供的事件。 以下是一个示例： document.addEventListener('fullscreenchange', handleFullscreenChange); document.addEventListener('mozfullscreenchange', handleFullscreenChange); // Firefox document.addEventListener('webkitfullscreenchange', handleFullscreenChange); // Chrome, Safari and Opera document.addEventListener('MSFullscreenChange', handleFullscreenChange); // Internet Explorer and Edge function handleFullscreenChange() { if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) { console.log('进入全屏模式'); } else { console.log('退出全屏模式'); } } 通过添加相应的事件监听器，可以在全屏模式变化时执行自定义的处理函数。 7 相关插件 了解以上 API 后本来已经准备开始写插件了，不过秉承不重复造轮子的思想，找到了以下两个库，基本满足开发需求了。 screenfull vue-fullscreen 8 小插曲 document.fullscreen、document.fullscreenElement、document.fullscreenEnabled 的 MDN 文档中文翻译已过时，然后顺手提了一个 PR mdn/translated-content#15859 9 参考链接 Fullscreen API - MDN Web Docs Element.requestFullscreen() - MDN Web Docs Document.exitFullscreen() - MDN Web Docs Document.fullscreenElement - MDN Web Docs ","date":"2023-09-15","objectID":"/posts/js-fullscreen/:0:0","tags":["JavaScript"],"title":"JS 实现全屏和退出全屏","uri":"/posts/js-fullscreen/"},{"categories":["Spec","翻译"],"content":" 以下内容截取自 针对 MDN 文档的本地化指南 的中文翻译的常见问题小节。 其中翻译的规范也是中文写作的规范，更多详见之前写的 中文技术文档的写作规范。 为保证简体中文文档格式的一致性，翻译指南列出了部分规范。 33 标点符号 除了代码中使用的符号以及一些特殊情况外，请将英文（半角）符号替换成中文（大部分为全角）符号。 但请注意，请不要使用全角数字（特殊情况除外）。 示例如下： 正确：我们可以学习 JavaScript——一种很酷的语言 错误：我们可以学习 JavaScript--一种很酷的语言 正确：以下示例是“可交互的” 错误：以下示例是\"可交互的\" 另外，请注意并列的词语间应使用顿号而非逗号： 原文：a, b, and c 宜：a、b 和 c 不宜：a，b，和 c 33.1 常见中/英文标点 名称 中文 英文 括号 （） () 冒号 ： : 引号 “” \"\" 破折号 —— – 、 — 简体中文标点符号参考资源： 教育部《标点符号用法》 维基百科：标点符号 34 中文和拉丁语系文字间加空格 对于简体中文文档，请在中文和拉丁语系文字之间保留一个空格，但在拉丁语系文字和中文标点之间，则无需保留空格。 示例如下： 正确：学习 Web 开发 错误：学习Web开发 正确：学习 JavaScript、HTML、CSS 等 错误：学习 JavaScript、 HTML、 CSS 等 正确：应用程序接口（API） 错误：应用程序接口（ API ） 对于链接文字和非链接文字部分，同样适用此规则： 正确：它指向一个[示例](#示例) 错误：它指向一个 [示例](#示例) 正确：指向 [MDN 开发者文档](https://developer.mozilla.org/)的链接 错误：指向[MDN开发者文档](https://developer.mozilla.org/)的链接 请注意，数字与中文之间也请保留空格： 正确：需 10 个小时完成 错误：需10个小时完成 35 排版 英文文档中，对于较长的段落，会通过断行的形式截断，以方便维护文档。但在 Markdown 中，断行会引入空格，在简体中文翻译中，我们有如下约定： 在段落不是特别长的情况下（200 个字符以内），请不要断行。 若段落过长，也请在中文与拉丁语系文字、数字之间，或是句子末尾断行。 例如： This is an example. We usually write a paragraph into multiple lines. Like this. 而在中文文档中，应该使它们在同一行内： 这是一个示例。我们不应该断行写这一段话。就像这样。 36 词语翻译 37 代名词 我们无需将“you”翻译为“您”，在文档正文部分的翻译中，请统一使用“你”。 38 复数形式 英文文档中，为了使语句的语法正确，会使用大量的复数形式。在中文翻译中，则无需保留这些复数的形式（未翻译的英文名词也同理）。 原文：Application Programming Interfaces (APIs) 宜：应用程序接口（API） 不宜：应用程序接口（APIs） 不宜：应用程序接口们（APIs） 39 术语表 我们在仓库中维护了一个术语表，旨在统一目前还未有明确中文翻译的术语。在翻译文档时，请尽量使用术语表中的术语，以保证文档的一致性。 40 常用标题 英文文档中使用了一些常见标题，为了保持简体中文文档的一致性，请在翻译时参考术语表中的标题和表格的翻译。 ","date":"2023-09-15","objectID":"/posts/translation-guide/:0:0","tags":["他山之石"],"title":"中文翻译的常见问题","uri":"/posts/translation-guide/"},{"categories":["Vue.js"],"content":"1 前言 在 Web 开发中，我们经常会用到 icon，icon 的使用经历了从图片到字体，再到 svg 的演变过程，也产生出相应的 icon 库，如雪碧图、Font Awesome、Iconfont 等等。 随着前端的发展，icon 使用方案落在了 svg 上，svg 有着矢量图的优势，可以无限放大而不失真，而且 svg 本身就是一种 XML 文件，可以直接在 HTML 中使用，也可以通过 CSS 进行样式控制，但是在 Vue 项目中使用 svg 时，我们会遇到一些问题，本文将介绍如何在 Vue 项目中更优雅的使用 svg icon。 2 工具 svg-sprite-loader svgo-loader svg-sprite-loader用来打包 svg 图标，svgo-loader 来精简我们的 svg 内容。 3 封装组件 在 src/components 目录下新建 SvgIcon.vue 组件： \u003ctemplate\u003e \u003cdiv v-if=\"isExternal\" :style=\"styleExternalIcon\" class=\"svg-external-icon svg-icon\" v-on=\"$listeners\" /\u003e \u003csvg v-else class=\"svg-icon\" aria-hidden=\"true\" v-on=\"$listeners\"\u003e \u003cuse :href=\"iconName\" /\u003e \u003c/svg\u003e \u003c/template\u003e \u003cscript\u003e export default { name: 'SvgIcon', props: { iconClass: { type: String, required: true }, className: { type: String, default: '' } }, computed: { isExternal() { return /^(https?:\\/\\/|data:image)/.test(this.iconClass) }, iconName() { return `#icon-${this.iconClass}` }, styleExternalIcon() { return { mask: `url(${this.iconClass}) no-repeat 50% 50%`, '-webkit-mask': `url(${this.iconClass}) no-repeat 50% 50%` } } } } \u003c/script\u003e \u003cstyle scoped\u003e .svg-icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } .svg-external-icon { background-color: currentColor; mask-size: cover!important; display: inline-block; } \u003c/style\u003e 4 安装 npm install svg-sprite-loader svgo-loader -D # 或 yarn add svg-sprite-loader svgo-loader -D 5 配置 统一将所有的 icon 都以 svg 的形式都放在 src/assets/icons 目录中。 然后在 vue.config.js 中添加如下配置： const { defineConfig } = require('@vue/cli-service') const path = require('path') function resolve(dir) { return path.join(__dirname, dir) } module.exports = defineConfig({ // ... chainWebpack: (config) =\u003e { // set svg-sprite-loader const svgPath = resolve('src/assets/icons') config.module .rule('svg') .exclude.add(svgPath) .end() config.module .rule('svg-icon') .test(/.svg$/) .include.add(svgPath) .end() .use('svg-sprite-loader') .loader('svg-sprite-loader') .options({ symbolId: 'icon-[name]', }) .end() // remove origin svg fill attr .use('svgo-loader') .loader('svgo-loader') .tap((options) =\u003e ({ ...options, // 删除 svg 中 fill 和 fill-rule plugins: [{ name: 'removeAttrs', params: { attrs: 'fill|fill-rule' } }], })) .end() }, // ... }) 6 自动引入 自动引入 src/assets/icons 中的 icon，需要用到 webpack 中的 require.context。 在 src/main.js 中引入所有的 svg 图标，之后可在文件夹自行添加或者删除图标，所以图标都会被自动导入，无需手动操作： import Vue from 'vue' import SvgIcon from '@/components/SvgIcon' // register svg component globally Vue.component('SvgIcon', SvgIcon) // require all svg const requireAll = (requireContext) =\u003e requireContext.keys().map(requireContext) const req = require.context('@/assets/icons', false, /\\.svg$/) requireAll(req) 7 使用 icon \u003csvg-icon icon-class=\"fullscreen\" class='custom-class' /\u003e 7.1 颜色 svg-icon 默认会读取其父级的 color fill: currentColor; 你可以改变父级的 color 或者直接改变 fill 的颜色即可。 7.2 大小 图标可从 iconfont 项目中下载或者由 UI 切图，同一个项目中使用的 Svg Icon 图标建议统一大小规格，比如 128*128。 8 示例 本文 示例 代码已上传至 vue-el-demo 项目中，可自行下载查看。 9 参考资料 手摸手，带你优雅的使用 icon 未来必热：SVG Sprites 技术介绍 SVG 精简压缩工具 svgo 简介和初体验 svg-sprite-loader svgo svgo-loader ","date":"2023-09-14","objectID":"/posts/vue-svg-icon/:0:0","tags":["SVG","Vue2"],"title":"在 Vue 项目中更优雅地使用 icon","uri":"/posts/vue-svg-icon/"},{"categories":["Memo"],"content":"在使用 VScode 开发中经常会有一些重复使用的代码块，复制粘贴也很麻烦，这时可以在 VScode 中添加用户代码片段，输入简写即可快捷输入。 1 新建代码片段 在 VScode 主界面-\u003e点击左下角设置图标-\u003e点击用户代码片段，可以建立全局代码片段，也可以建立单个项目的代码片段，也可以设置语言类型的代码片段。 2 代码片段格式 代码片段格式如下： { // Example: // 在这里放置你的 JavaScript 代码片段。每个代码片段都有一个名称、前缀、代码块和描述。前缀用于触发代码片段，代码块将被展开并插入。可能使用的变量有： // $1、$2 表示标签停止点，$0 表示最终光标位置，${1:label}、${2:another} 表示占位符。具有相同 id 的占位符是相互关联的。 // 示例： // \"Print to console\": { // \"prefix\": \"log\", // \"body\": [ // \"console.log('$1');\", // \"$2\" // ], // \"description\": \"Log output to console\" // } } 可以使用工具 snippet-generator 生成代码片段。 3 常用代码片段 3.1 JavaScript { \"Print to console\": { \"prefix\": \"cl\", \"body\": [ \"console.log('$1');\", ], \"description\": \"Log output to console\" } } 3.2 Markdown { \"Font Matter\": { \"prefix\": \"fm\", \"body\": [ \"---\", \"title: $1\", \"date: $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE$T$CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND+08:00\", \"draft: true\", \"categories: $2\", \"tags: $3\", \"description: $4\", \"keywords: $5\", \"---\" ], \"description\": \"Font Matter\" }, \"Markdown Table\": { \"prefix\": \"table\", \"body\": [ \"| $1 | $2 |\", \"| --- | --- |\", \"| $3 | $4 |\" ], \"description\": \"Markdown Table\" }, \"FixIt Shortcode TypeIt\": { \"prefix\": \"typeit\", \"body\": [ \"{{\u003c typeit \u003e}}\", \"$1\", \"{{\u003c /typeit \u003e}}\" ], \"description\": \"FixIt Shortcode TypeIt\" }, } ","date":"2023-09-14","objectID":"/posts/vscode-snippets/:0:0","tags":["Shortcodes"],"title":"VSCode 添加用户代码片段，自定义用户代码片段","uri":"/posts/vscode-snippets/"},{"categories":["CSS"],"content":"本文将介绍如何使用 linear-gradient 、background-size 等属性来实现网格背景效果。 1 前言 最近在开发一个拖拽式仪表盘时，需要在拖拽组件时添加网格辅助标线来帮助布局和对齐元素。 最先想到的是使用 CSS 来实现这个效果，经过一番尝试，发现可以通过使用 CSS 的一些技术点，轻松实现不同类型的网格背景效果，包括实线网格和虚线网格。 2 前驱知识 在开始之前，我们需要了解一些必要的 CSS 属性和知识点。 linear-gradient：CSS linear-gradient() 函数用于创建一个表示两种或多种颜色线性渐变的图片。其结果属于\u003cgradient\u003e数据类型，是一种特别的\u003cimage\u003e数据类型。 radial-gradient：radial-gradient() CSS 函数创建一个图像，该图像由从原点辐射的两种或多种颜色之间的渐进过渡组成。它的形状可以是圆形或椭圆形。函数的结果是 \u003cgradient\u003e 数据类型的对象。这是一种特别的 \u003cimage\u003e。 background-size background-repeat background-position ::before 和 ::after 伪元素 3 实线网格 这个效果，我最初是在刷掘金的时候发现的，掘金文章内容区的背景一个实线网格，呈现出的效果类似一页学生时代的记事本，当时觉得很有意思，于是扒下来当作了现在博客文章内容的背景。 实线网格的实现思路是使用 linear-gradient 来绘制横向和纵向的网格线，然后通过 background-size 来控制网格线的间距。 具体代码如下： .grid { background-image: linear-gradient(to right, rgba(60, 10, 30, 0.04) 1px, transparent 0), linear-gradient(to bottom, rgba(60, 10, 30, 0.04) 1px, transparent 0); background-size: 20px 20px; } 上面的代码中，background-image 属性使用了两个 linear-gradient，通过渐变颜色从 rgba(60, 10, 30, 0.04) 到 transparent 实现了横向和纵向的网格线。通过指定 background-size 为 20px 20px，设置了背景大小为 20px，由于 background-repeat 默认为 repeat，所以就实现了 20px 间距的网格线。 4 虚线网格 虚线网格的实现思路需要借助 ::before 和 ::after 伪元素，然后还是通过类似实线的思路实现网格线，然后两个伪元素叠加在一起，从而实现虚线网格。 未做实例 5 点阵网格 这里把渐变修改为径向渐变就实现点点背景了，原理和前面说的都是一样的。 .grid { background-image: radial-gradient(circle , #5a5a5a .5px, transparent .5px); background-size: 20px 20px; } 6 总结 最后为了实现我在实际开发中的需求，我还需要控制网格宽度为容器的 1/24，这里就需要使用 calc() 函数来计算了。 /* 背景显示网格辅助线（宽：1/24 高：40+8px） */ background-image: linear-gradient(90deg, rgba(60, 10, 30, 0.04) 1px, transparent 0), linear-gradient(1turn, rgba(60, 10, 30, 0.04) 1px, transparent 0); background-size: calc((100% - 8px) / 24) 48px; background-position: 4px 4px; /* 或者点阵网格辅助线（宽：1/24 高：40+8px） */ background-image: radial-gradient(circle , #5a5a5a .5px, transparent .5px); background-size: calc((100% - 8px) / 24) 48px; background-position: 24px 24px; 7 参考 CSS+HTML\u003c网格背景效果\u003e ","date":"2023-09-02","objectID":"/posts/grid-bg-image/:0:0","tags":["CSS"],"title":"CSS 如何实现网格背景效果？","uri":"/posts/grid-bg-image/"},{"categories":["GitHub"],"content":"Lruihao/vue el demo: Vue2 and element-ui related demos","date":"2023-08-08","objectID":"/projects/lruihao/vue-el-demo/","tags":["element-ui","vue","vue2"],"title":"Vue2 and element-ui related demos","uri":"/projects/lruihao/vue-el-demo/"},{"categories":["GitHub"],"content":"vue-el-demo Vue and element-ui related demos. Project setup yarn install # Compiles and hot-reloads for development yarn serve # Compiles and minifies for production yarn build # Lints and fixes files yarn lint Customize configuration see Configuration Reference. ","date":"2023-08-08","objectID":"/projects/lruihao/vue-el-demo/:0:0","tags":["element-ui","vue","vue2"],"title":"Vue2 and element-ui related demos","uri":"/projects/lruihao/vue-el-demo/"},{"categories":["Vue.js","JavaScript"],"content":"这篇文章主要是记录一下继承 ElBacktop 组件并修复了一些 bug 的过程。 1 前言 由于某些原因，我希望在路由切换时给每个页面的总容器都加上一个共同的 class page-container，然后我就在布局中里面加了这么一段代码： \u003ctemplate\u003e \u003cdiv :class=\"classObj\" class=\"app-wrapper\"\u003e \u003cdiv class=\"app-container\"\u003e \u003ctopbar class=\"header-container\" /\u003e \u003cel-container class=\"main-container\"\u003e \u003csidebar class=\"aside-container\" /\u003e \u003cel-container class=\"is-vertical minor-container\"\u003e \u003cbreadcrumb class=\"breadcrumb-container\" /\u003e \u003c!-- 这一行 --\u003e \u003cpage-container class=\"page-container\" /\u003e \u003c/el-container\u003e \u003c/el-container\u003e \u003c/div\u003e \u003cel-backtop class=\"app-b2t\" target=\".page-container\" :visibility-height=\"50\" /\u003e \u003c!-- \u003cback-to-top class=\"app-b2t\" target=\".page-container\" :visibility-height=\"50\" /\u003e --\u003e \u003c/div\u003e \u003c/template\u003e \u003ctemplate\u003e \u003ctransition name=\"fade-transform\" mode=\"out-in\"\u003e \u003ckeep-alive :include=\"cachedViews\"\u003e \u003crouter-view /\u003e \u003c/keep-alive\u003e \u003c/transition\u003e \u003c/template\u003e 没错，相当于在 router-view 上直接加了一个 class page-container。 2 问题 那么问题就来了，此时 el-backtop 的 target 设置为 .page-container，但是当我切换路由时，.page-container 会被移除再添加为新的页面，此时 el-backtop 就会失效。 原意是想让 el-backtop 指向每一个包含 .page-container 的页面。 3 解决 RTFSC，发现 el-backtop 的 target 属性只会在 mounted 时初始化一次，所以想办法在每次路由切换时重新初始化一下 el-backtop 的 target 属性就行了。 创建 MutationObserver 实例来观察 target 的父元素的子元素变化已解决上述 bug 增加 target 的 data-target 属性，用于指定 target 的子元素作为滚动容器 最后代码如下： \u003cscript\u003e /** * BackToTop 继承 el-backtop * 1. 修复 el-backtop 在 target 被移除后，无法重新初始化的问题 * 2. 增加 target 的 data-target 属性，用于指定 target 的子元素作为滚动容器。例如：\u003cdiv data-target=\".list-pane\"\u003e\u003c/div\u003e */ import { Backtop } from 'element-ui' import throttle from 'throttle-debounce/throttle' export default { name: 'BackToTop', extends: Backtop, data() { return { el: null, container: null, visible: false, observer: null, } }, mounted() { this.init() this.observeTarget() }, beforeDestroy() { // 清除事件监听 this.container.removeEventListener('scroll', this.throttledScrollHandler) // 停止观察 this.observer.disconnect() }, methods: { init() { this.container = document this.el = document.documentElement if (this.target) { this.el = document.querySelector(this.target) if (!this.el) { throw new Error(`target is not existed: ${this.target}`) } // 如果 this.el 有 data-target 属性，就使用 data-target 属性的值作为 target if (this.el.dataset.target) { const subEl = this.el.querySelector(this.el.dataset.target) subEl \u0026\u0026 (this.el = subEl) } this.container = this.el } this.throttledScrollHandler = throttle(300, this.onScroll) this.container.addEventListener('scroll', this.throttledScrollHandler) }, /** * 观察 this.container 是否被移除或者新增 * 注意 router-view 切换页面步骤：1. 新增 router-view -\u003e 2. 删除旧 router-view */ observeTarget() { // 创建 MutationObserver 实例并传入回调函数 this.observer = new MutationObserver((mutationsList) =\u003e { for (const mutation of mutationsList) { if (mutation.type === 'childList') { // 检测到删除节点 if (mutation.removedNodes.length \u003e 0) { for (const node of mutation.removedNodes) { if (node === this.container) { // 观察如果 this.container 从页面中被移除了，就清除事件监听 this.container.removeEventListener('scroll', this.throttledScrollHandler) this.visible = false break } } // 检测删除前是否有新增节点 if (document.querySelector(this.target) === mutation.nextSibling) { // 观察如果 this.container 被删除前的下一个兄弟节点是 this.target，就重新初始化 this.init() } } } } }) // 观察 this.container 父元素的子元素变化 this.observer.observe(document.querySelector(this.target).parentNode, { childList: true, }) }, }, } \u003c/script\u003e ","date":"2023-07-20","objectID":"/posts/el-backtop-fix/:0:0","tags":["Vue2"],"title":"用魔法打败魔法 - ElBacktop Fix","uri":"/posts/el-backtop-fix/"},{"categories":["GitHub"],"content":"Lruihao/el table sticky: A plugin includes a set of directives to make the header, footer and horizontal scrollbar sticky or make highly adaptive of Element UI (Vue 2) tables.","date":"2023-06-14","objectID":"/projects/lruihao/el-table-sticky/","tags":["el-table","el-table-sticky","element-ui","v-height-adaptive","v-sticky-footer","v-sticky-h-scroll","v-sticky-header","vue","vue-directive","vue2"],"title":"A plugin includes a set of directives to make the header, footer and horizontal scrollbar sticky or make highly adaptive of Element UI (Vue 2) tables.","uri":"/projects/lruihao/el-table-sticky/"},{"categories":["GitHub"],"content":"el-table-sticky 一个用于实现 Element UI (Vue 2) 表格的表头吸顶、表尾吸底、滚动条吸底以及高度自适应功能的指令集插件。 背景 Element UI 的表格组件在使用时，如果表格内容过多，表格会出现滚动条，但是表头不会吸顶，表尾合计行也不会吸底，这样在表格内容过多时，表头和表尾合计行就会被遮挡，如果有横向滚动条，每次想滚动必须滑动到最底下，这一系列痛点，非常影响用户体验。 Element UI 的解决办法：通过设置 max-height 或者 height 属性来实现上述需求。 Element UI 的解决不足点：高度值只支持设置数字型，在实际开发中往往需要借助 JS 来计算。 为了解决以上痛点/需求，减少开发和维护成本，于是就有了这个插件，详见 思路分析。 特性 部分指令依赖于 position: sticky 属性，所以只支持现代浏览器，在线示例。 支持表头吸顶 (v-sticky-header) 支持表尾合计行吸底 (v-sticky-footer) 支持横向滚动条吸底 (v-sticky-scroller) 支持高度自适应 (v-height-adaptive) 安装 npm install @cell-x/el-table-sticky 注册指令 全局注册指令： import elTableSticky from '@cell-x/el-table-sticky' Vue.use(elTableSticky) // 或者 Vue.use(elTableSticky, { StickyHeader: { // 吸顶偏移量，可以是 CSS 支持的距离值，如 `0px`、`10%`、`calc(100vh - 1rem)` 等 offsetTop: 0, // 滚动条吸底偏移量，可以是 CSS 支持的距离值，如 `0px`、`10%`、`calc(100vh - 1rem)` 等 offsetBottom: 0, }, StickyFooter: { // 吸底偏移量，可以是 CSS 支持的距离值，如 `0px`、`10%`、`calc(100vh - 1rem)` 等 offsetBottom: 0, }, StickyScroller: { // 吸底偏移量，可以是 CSS 支持的距离值，如 `0px`、`10%`、`calc(100vh - 1rem)` 等 offsetBottom: 0, }, HeightAdaptive: { // 底部偏移量，只能是数字型 offsetBottom: 0, } }) 局部注册指令： import { StickyHeader, StickyFooter, StickyScroller, HeightAdaptive, } from '@cell-x/el-table-sticky' export default { directives: { StickyHeader: new StickyHeader({ offsetTop: 0, offsetBottom: 0 }).init(), StickyFooter: new StickyFooter({ offsetBottom: 0 }).init(), StickyScroller: new StickyScroller({ offsetBottom: 0 }).init(), HeightAdaptive: new HeightAdaptive({ offsetBottom: 0 }).init(), } } 使用 \u003cel-table v-sticky-header\u003e...\u003c/el-table\u003e \u003cel-table v-sticky-footer\u003e...\u003c/el-table\u003e \u003cel-table v-sticky-scroller\u003e...\u003c/el-table\u003e \u003cel-table v-height-adaptive\u003e...\u003c/el-table\u003e 指令参数 指令 说明 修饰符 类型 默认值 v-sticky-header 表头吸顶指令 .always Object{Number, String} offsetTop: 0, offsetBottom: 0 v-sticky-footer 表尾合计行吸底指令 .always Object{Number, String} offsetBottom: 0 v-sticky-scroller 横向滚动条吸底指令 .always Object{Number, String} offsetBottom: 0 v-height-adaptive 高度自适应指令 - Object{Number} offsetBottom: 0 注意事项 v-sticky-header 和 v-sticky-footer 已内置滚动条吸底功能，无需重复使用 v-sticky-scroller 指令 当 v-sticky-header 和 v-sticky-footer 同时使用时，滚动条 offsetBottom 以 v-sticky-footer 为准 横向滚动条默认显示方式为 hover，可通过设置修饰符 .always 改为一直显示 v-height-adaptive 指令不依赖于 position: sticky 属性，可单独使用 Project setup yarn install # Compiles and hot-reloads for development yarn serve # Compiles and minifies for production yarn build # Compiles and minifies for production with demo yarn build:demo # Lints and fixes files yarn lint Customize configuration see Configuration Reference. ","date":"2023-06-14","objectID":"/projects/lruihao/el-table-sticky/:0:0","tags":["el-table","el-table-sticky","element-ui","v-height-adaptive","v-sticky-footer","v-sticky-h-scroll","v-sticky-header","vue","vue-directive","vue2"],"title":"A plugin includes a set of directives to make the header, footer and horizontal scrollbar sticky or make highly adaptive of Element UI (Vue 2) tables.","uri":"/projects/lruihao/el-table-sticky/"},{"categories":["Node.js"],"content":"最近在写一个 Vue 插件，需要在项目中创建一些测试页面，由于都是些静态路由，就想到之前看到过的一个项目就是用 Node.js 来自动生成路由的，于是就借鉴过来改了一下。 1 源码 Gist: https://gist.github.com/Lruihao/d8f2984525dc9e78dd6a49e15f49cf38 const fs = require('fs') const os = require('os') const vueDir = './src/views/' const routerFile = './src/router.js' fs.readdir(vueDir, function (err, files) { if (err) { console.error('❌ Could not list the directory.', err) return } const routes = [] for (const filename of files) { if (filename.indexOf('.') \u003c 0) { continue } const [name, ext] = filename.split('.') if (ext !== 'vue') { continue } const routeName = name.replace(/-([a-z])/g, (_, match) =\u003e match.toUpperCase()) let routeDescription = '' const contentFull = fs.readFileSync(`${vueDir}${filename}`, 'utf-8') // get route description from first line comment const match = /\u003c!--\\s*(.*)\\s*--\u003e/g.exec(contentFull.split(os.EOL)[0]) if (match) { routeDescription = match[1].trim() } routes.push(` { path: '/${name === 'home' ? '' : name}', name: '${routeName}',${routeDescription ? `\\n meta: { description: '${routeDescription}' },` : ''} component: () =\u003e import(/* webpackChunkName: \"${routeName}\" */ '@/views/${filename}'), },`) } const result = `// This file is automatically generated by gen-router.js, please do not modify it manually！ import VueRouter from 'vue-router' import Vue from 'vue' Vue.use(VueRouter) const routes = [ ${routes.join(os.EOL)} ] const router = new VueRouter({ mode: 'hash', routes, }) export default router ` fs.writeFile(routerFile, result, 'utf-8', (err) =\u003e { if (err) throw err console.log(`✅ Router generated successfully in ${routerFile}`) }) }) 生成效果如下： // This file is automatically generated by gen-router.js, please do not modify it manually！ import VueRouter from 'vue-router' import Vue from 'vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'home', meta: { description: 'Home' }, component: () =\u003e import(/* webpackChunkName: \"home\" */ '@/views/home.vue'), }, ] const router = new VueRouter({ mode: 'hash', routes, }) export default router 2 参考 sunzsh/vue-el-demo ","date":"2023-06-14","objectID":"/posts/gen-router/:0:0","tags":["JavaScript","Node.js","Vue2"],"title":"使用 Node.js 自动创建 Vue 的路由","uri":"/posts/gen-router/"},{"categories":["Node.js"],"content":"1 问题描述 在使用 SourceTree 提交代码的时候，会出现 husky 命令失败的问题（通过命令行提交代码没有问题），如下图所示： 看错误，是一个 catch 参数的问题，在新版本的 Node 中，catch 参数是可以省略的，但是在旧版本中，catch 参数是必须的。 由于使用了 nvm 管理 Node 版本，项目中的 Node 是正常的，但是 SourceTree 使用的是系统的 Node，所以会出现这个问题。 2 解决方案 知道了问题的原因，解决起来就很简单了，只需要将 SourceTree husky hook 阶段的 Node 版本切换到项目中的 Node 版本即可。 配置 .huskyrc 文件，内容如下： export PATH=\\\"$(dirname $(which node)):\\$PATH\\\" 如果你使用了 zsh 和 nvm, 建议在 $ZSH_CUSTOM 目录下添加一个自定义 zsh 脚本。 这个脚本会在你进入包含了 .nvmrc 文件目录中自动切换 node 版本，切换版本后修正 ~/.huskyrc 的 path 内容。 vim $ZSH_CUSTOM/nvm_custom.zsh # https://github.com/nvm-sh/nvm#manual-install export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] \u0026\u0026 \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion # https://github.com/nvm-sh/nvm#deeper-shell-integration autoload -U add-zsh-hook load-nvmrc() { local node_version=\"$(nvm version)\" local nvmrc_path=\"$(nvm_find_nvmrc)\" if [ -n \"$nvmrc_path\" ]; then local nvmrc_node_version=$(nvm version \"$(cat \"${nvmrc_path}\")\") if [ \"$nvmrc_node_version\" = \"N/A\" ]; then nvm install elif [ \"$nvmrc_node_version\" != \"$node_version\" ]; then nvm use fi elif [ \"$node_version\" != \"$(nvm version default)\" ]; then echo \"Reverting to nvm default version\" nvm use default fi # fix husky hook # ref: https://github.com/typicode/husky/issues/390#issuecomment-762213421 # for husky 8 ~/.huskyrc, for husky 9 ~/.config/husky/init.sh echo \"export PATH=\\\"$(dirname $(which node)):\\$PATH\\\"\" \u003e ~/.config/husky/init.sh } add-zsh-hook chpwd load-nvmrc load-nvmrc # https://github.com/nvm-sh/nvm#use-a-mirror-of-node-binaries export NVM_NODEJS_ORG_MIRROR=https://mirrors.ustc.edu.cn/node/ 如果你使用的是 husky 9 之后的版本，需要将 ~/.huskyrc 替换为 ~/.config/husky/init.sh。 3 参考 解决 SourceTree 提交时候 husky 命令失败问题 https://github.com/typicode/husky/issues/390#issuecomment-762213421 https://github.com/typicode/husky/issues/904#issuecomment-862184954 https://github.com/nvm-sh/nvm#deeper-shell-integration ","date":"2023-06-12","objectID":"/posts/sourcetree-husky/:0:0","tags":["Git","husky","Mac","nvm"],"title":"解决 SourceTree 提交时候 husky 命令失败问题","uri":"/posts/sourcetree-husky/"},{"categories":["Vue.js"],"content":"1 新建 Vue2 项目 通过 vue-cli 创建一个叫 v2-tailwind 的项目： vue create vue2-tailwind 根据需要选择其他的功能插件，例如：Babel, Router, Vuex, CSS Pre-processors, Linter。 关于 ESLint 当在 Vue 创建项目时，你可以根据自己的需求选择不同的 ESLint 配置。以下是一些常见的选项及其优缺点和注意事项： ESLint with error prevention only: 优点：这个配置只会帮助你防止代码中的错误，它的规则相对宽松。适用于刚开始使用 ESLint 或者希望避免太多约束的开发者。 缺点：由于规则相对宽松，可能无法完全确保代码风格的一致性。 注意事项：如果你想要更严格的代码检查，可以考虑其他配置。 ESLint + Airbnb config: 优点：Airbnb 的配置非常严格，能够帮助你遵循最佳实践和编写高质量的代码。此外，它也包含了许多 ES6+ 的规则。 缺点：由于其严格性，初学者可能需要花费更多时间来解决 ESLint 报告的问题。 注意事项：在使用此配置时，请确保你理解并接受 Airbnb 的代码规范。 ESLint + Standard config: 优点：Standard 的配置旨在提供一个相对简单、一致的代码风格，适合那些喜欢“零配置”的开发者。 缺点：这个配置可能不适用于所有项目，因为它有自己的代码风格要求。 注意事项：如果你的团队或项目已经有自己的编码规范，使用 Standard 配置可能会导致不一致。 ESLint + Prettier: 优点：Prettier 是一个自动格式化工具，可以与 ESLint 结合使用，以确保代码风格的一致性。这可以提高代码可读性，并减少在代码审查过程中关注格式问题的时间。 缺点：Prettier 可能会覆盖某些 ESLint 规则，所以需要花一些时间确保配置正确。 注意事项：为了避免冲突，请确保 ESLint 和 Prettier 的规则正确配置。 总之，在选择 ESLint 配置时，需要根据你的团队、项目需求和个人偏好来权衡。选择适当的配置可以帮助你提高代码质量并保持一致的代码风格。 2 安装 tailwindcss 打开项目，安装 tailwindcss： cd vue2-tailwind # 安装 tailwindcss 低版本及相关插件 npm install tailwindcss@npm:@tailwindcss/postcss7-compat @tailwindcss/postcss7-compat postcss@^7 autoprefixer@^9 然后创建配置文件： # 创建 postcss.config.js, tailwind.config.js npx tailwindcss init -p module.exports = { plugins: { tailwindcss: {}, autoprefixer: {}, } } module.exports = { purge: [ \"./src/App.vue\", \"./src/views/**/*.{vue,js,ts,jsx,tsx}\", \"./src/components/**/*.{vue,js,ts,jsx,tsx}\", ], darkMode: 'class', // or 'media' or 'class' mode: 'jit', // 是否开启 jit 模式，开启以后编译会更快，当然，tailwindcss 版本需要在 2.1 以上 theme: { extend: {}, }, variants: { extend: {}, }, plugins: [], } 最后在 main.js 中引入 tailwindcss import \"tailwindcss/tailwind.css\" 3 启动项目 启动项目，修改模板中的 class 进行测试。 npm run serve \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv class=\"bg-gray-100\"\u003e \u003cdiv class=\"container mx-auto\"\u003e \u003cdiv class=\"flex justify-center items-center h-screen\"\u003e \u003cdiv class=\"text-4xl text-gray-700\"\u003eHello Vue2 + tailwindcss\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/template\u003e ","date":"2023-06-03","objectID":"/posts/v2-tailwind/:0:0","tags":["tailwindcss","Vue2","CSS","eslint"],"title":"Vue2 + tailwindcss 初始化","uri":"/posts/v2-tailwind/"},{"categories":["Vue.js"],"content":" 注：2.0 已经有中文文档 。如果对自己英文有信心，也可以直接阅读英文文档。 此指南仅供参考，请根据自身实际情况灵活调整。 转载自： 尤雨溪，新手向：Vue 2.0 的建议学习顺序，2017-08-04 14:51 1 起步 扎实的 JavaScript / HTML / CSS 基本功。这是前置条件。 通读官方教程 (guide) 的基础篇。不要用任何构建工具，就只用最简单的 \u003cscript\u003e，把教程里的例子模仿一遍，理解用法。不推荐上来就直接用 vue-cli 构建项目，尤其是如果没有 Node/Webpack 基础。 照着官网上的示例，自己想一些类似的例子，模仿着实现来练手，加深理解。 阅读官方教程进阶篇的前半部分，到『自定义指令 (Custom Directive) 』为止。着重理解 Vue 的响应式机制和组件生命周期。『渲染函数（Render Function)』如果理解吃力可以先跳过。 阅读教程里关于路由和状态管理的章节，然后根据需要学习 vue-router 和 vuex。同样的，先不要管构建工具，以跟着文档里的例子理解用法为主。 走完基础文档后，如果你对于基于 Node 的前端工程化不熟悉，就需要补课了。下面这些严格来说并不是 Vue 本身的内容，也不涵盖所有的前端工程化知识，但对于大型的 Vue 工程是前置条件，也是合格的『前端工程师』应当具备的知识。 2 前端生态/工程化 了解 JavaScript 背后的规范，ECMAScript 的历史和目前的规范制定方式。学习 ES2015/16 的新特性，理解 ES2015 modules，适当关注还未成为标准的提案。 学习命令行的使用。建议用 Mac。 学习 Node.js 基础。建议使用 nvm 这样的工具来管理机器上的 Node 版本，并且将 npm 的 registry 注册表配置为淘宝的镜像源。 至少要了解 npm 的常用命令，npm scripts 如何使用，语义化版本号规则，CommonJS 模块规范（了解它和 ES2015 Modules 的异同），Node 包的解析规则，以及 Node 的常用 API。应当做到可以自己写一些基本的命令行程序。注意最新版本的 Node (6+) 已经支持绝大部分 ES2015 的特性，可以借此巩固 ES2015。 了解如何使用 / 配置 Babel 来将 ES2015 编译到 ES5 用于浏览器环境。 学习 Webpack。Webpack 是一个极其强大同时也复杂的工具，作为起步，理解它的『一切皆模块』的思想，并基本了解其常用配置选项和 loader 的概念/使用方法即可，比如如何搭配 Webpack 使用 Babel。学习 Webpack 的一个挑战在于其本身文档的混乱，建议多搜索搜索，应该还是有质量不错的第三方教程的。英文好的建议阅读 Webpack 2.0 的文档，比起 1.0 有极大的改善，但需要注意和 1.0 的不兼容之处。 3 Vue 进阶 有了 Node 和 Webpack 的基础，可以通过 vue-cli 来搭建基于 Webpack，并且支持单文件组件的项目了。建议用 webpack-simple 这个模板开始，并阅读官方教程进阶篇剩余的内容以及 vue-loader 的文档，了解一些进阶配置。有兴趣的可以自己亲手从零开始搭一个项目加深理解。 根据 例子 尝试在 Webpack 模板基础上整合 vue-router 和 vuex 深入理解 Virtual DOM 和『渲染函数 (Render Functions)』这一章节（可选择性使用 JSX)，理解模板和渲染函数之间的对应关系，了解其使用方法和适用场景。 （可选）根据需求，了解服务端渲染的使用（需要配合 Node 服务器开发的知识）。其实更重要的是理解它所解决的问题并搞清楚你是否需要它。 阅读开源的 Vue 应用、组件、插件源码，自己尝试编写开源的 Vue 组件、插件。 参考 贡献指南 阅读 Vue 的源码，理解内部实现细节。（需要了解 Flow） 参与 Vue GitHub issue 的定位 -\u003e 贡献 PR -\u003e 加入核心团队 -\u003e 升任 CTO -\u003e 迎娶白富美…（误 注：目前 Vue3 已经发布并广泛使用，文章 Vue 相关文档链接可能重定向至 Vue3，请自行甄别。 ","date":"2023-03-14","objectID":"/posts/vue2-guid/:0:0","tags":["Vue2","他山之石"],"title":"新手向：Vue 2.0 的建议学习顺序","uri":"/posts/vue2-guid/"},{"categories":["GitHub"],"content":"hugo fixit/shortcode mmt netease: 🎶 A Hugo theme component with a NetEase Cloud random comment shortcode.","date":"2023-02-28","objectID":"/projects/hugo-fixit/shortcode-mmt-netease/","tags":["hugo","hugo-fixit","netease-cloud-music","shortcodes","theme-component"],"title":"🎶 A Hugo theme component with a NetEase Cloud random comment shortcode.","uri":"/projects/hugo-fixit/shortcode-mmt-netease/"},{"categories":["GitHub"],"content":"shortcode-mmt-netease 一个含有网易云随机评论 shortcode 的 Hugo 主题组件。 Demo https://lruihao.cn/guestbook/ 安装 提示 本组件适用于所有 Hugo 主题，但你必须有一个主体主题来使用它，以下以 FixIt 主题为例。 安装方法与 安装主题 相同。有几种安装方法，请选择一种。 安装为 Hugo 模块 首先确保你的项目本身是一个 Hugo 模块。 然后将此主题组件添加到你的 hugo.toml 配置文件中： [module] [[module.imports]] path = \"github.com/hugo-fixit/FixIt\" [[module.imports]] path = \"github.com/hugo-fixit/shortcode-mmt-netease\" 在第一次启动 Hugo 时，它将下载所需的文件。 要更新到模块的最新版本，请运行： hugo mod get -u hugo mod tidy 安装为 Git 子模块 将 FixIt 和此 git 存储库克隆到你的主题文件夹中，并将其添加为网站目录的子模块。 git submodule add https://github.com/hugo-fixit/FixIt.git themes/FixIt git submodule add https://github.com/hugo-fixit/shortcode-mmt-netease.git themes/shortcode-mmt-netease 接下来编辑项目的 hugo.toml 并将此主题组件添加到你的主题中： theme = [\"FixIt\", \"shortcode-mmt-netease\"] 使用 mmt-netease shortcode 有以下命名参数： mid [必需]（第一个位置参数）网易云歌单 ID autoplay [可选]（第二个位置参数）是否自动播放，默认：false fixed [可选]（第三个位置参数）是否启用固定模式，默认：false mini [可选]（第四个位置参数）是否启用迷你模式，默认：false volume [可选]（第五个位置参数）默认音量，注意播放器会记住用户设置，用户自己设置音量后默认音量将不起作用，默认：0.7 current [可选]（第六个位置参数）是否播放当前评论的音乐，默认：false 这是一个用法示例： {{\u003c mmt-netease mid=\"2280569152\" autoplay=\"false\" \u003e}} \u003c!-- OR --\u003e {{\u003c mmt-netease \"2280569152\" false \u003e}} Dependencies APlayer MetingJS mmt-webfont vercel-proxy ","date":"2023-02-28","objectID":"/projects/hugo-fixit/shortcode-mmt-netease/:0:0","tags":["hugo","hugo-fixit","netease-cloud-music","shortcodes","theme-component"],"title":"🎶 A Hugo theme component with a NetEase Cloud random comment shortcode.","uri":"/projects/hugo-fixit/shortcode-mmt-netease/"},{"categories":["HTML"],"content":"记录使用 HTML 原生方案实现图片的懒加载。 17 语法规范 HTML loading 属性适用于 img 和 iframe，语法规范见 HTML Standard - Lazy loading attributes。 关键词 状态 描述 lazy 懒惰的 用于延迟获取资源，直到满足某些条件。 eager 渴望的 用于立即获取资源；默认状态。 属性的 缺失值默认值 和 无效值默认值 都是 Eager状态。 18 实际应用 基于 FixIt 主题 版本大于 v0.2.18 的博客网站使用就是原生的懒加载方案，大致如下： \u003cimg loading=\"lazy\" src=\"./example.jpg\" data-title=\"title text\" data-alt=\"alt text\" onload=\"this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['data-title','data-alt','onerror','onload']){this.removeAttribute(a);}this.dataset.lazyloaded='';\" onerror=\"this.title=this.dataset.title;this.alt=this.dataset.alt;for(const a of ['data-title','data-alt','onerror','onload']){this.removeAttribute(a);}\" /\u003e 为了达到 loading 的效果，以上代码中在 onload 后会给图片加上一个 data-lazyloaded 属性，所以我们可以这样来写 css 以达到显示 loading 图标的效果： img[loading='lazy']:not([data-lazyloaded]) { background: url(loading.svg) no-repeat center; } 设置 data-title 和 data-alt 是因为移动浏览器大多数只要有 title 或 alt 就会显示图片的替代字符，所以等到图片加载完或加载失败后再回填。 19 懒加载特性的研究 以下结论来自 浏览器 IMG 图片原生懒加载 loading=”lazy”实践指南 « 张鑫旭 - 鑫空间 - 鑫生活 总结部分。 Lazy loading 加载数量与屏幕高度有关，高度越小加载数量越少，但并不是线性关系。 Lazy loading 加载数量与网速有关，网速越慢，加载数量越多，但并不是线性关系。 Lazy loading 加载没有缓冲，滚动即会触发新的图片资源加载。 Lazy loading 加载在窗口 resize 尺寸变化时候也会触发，例如屏幕高度从小变大的时候。 Lazy loading 加载也有可能会先加载后面的图片资源，例如页面加载时滚动高度很高的时候。 20 参考链接 Lazy loading - Web 性能 | MDN Lazy loading via attribute for images \u0026 iframes 兼容性 ","date":"2023-02-12","objectID":"/posts/native-img-loading-lazy/:0:0","tags":["HTML","eager","lazy","loading"],"title":"浏览器 IMG 图片原生懒加载 loading=\"lazy\"","uri":"/posts/native-img-loading-lazy/"},{"categories":["Browser"],"content":" 1 浏览器是如何渲染页面的？ 当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画 每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 渲染的第一步是解析 HTML。 解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。 如果主线程解析到link位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 如果主线程解析到script位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 渲染的下一步是样式计算。 主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。 在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0)；相对单位会变成绝对单位，比如em会变成px 这一步完成后，会得到一棵带有样式的 DOM 树。 接下来是布局，布局完成后会得到布局树。 布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。 大部分时候，DOM 树和布局树并非一一对应。 比如display:none的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 下一步是分层 主线程会使用一套复杂的策略对整个布局树中进行分层。 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过will-change属性更大程度的影响分层结果。 再下一步是绘制 主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。 合成线程首先对每个图层进行分块，将其划分为更多的小区域。 它会从线程池中拿取多个线程来完成分块工作。 分块完成后，进入光栅化阶段。 合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。 光栅化的结果，就是一块一块的位图 最后一个阶段就是画了 合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。 指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。 变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因。 合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 2 什么是 reflow？ reflow 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。 浏览器在反复权衡下，最终决定获取属性立即 reflow。 3 什么是 repaint？ repaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。 4 为什么 transform 的效率高？ 因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段 由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。 ","date":"2023-02-05","objectID":"/posts/browser-rendering/:0:0","tags":["Browser","JavaScript","HTML","CSS"],"title":"浏览器渲染原理","uri":"/posts/browser-rendering/"},{"categories":["Spec"],"content":" 以下参考来源：阮一峰的 中文技术文档的写作规范 英语世界里，文档非常受重视，许多公司和组织都有自己的文档规范，清楚地规定写作要求，比如微软、MailChimp、Apple、Yahoo、docker、Struts 等等（维基百科有一份完整的清单）。中文的也有不少，但都不令人满意，要么太简单，要么不太适用。 对于开发者来说，在工作中也需要适当地产出一些技术文档，但是很多人都不知道怎么写文档，都是凭着感觉写。 对于开发的系统、软件而言，系统用词的准确性和统一性也显得十分重要。 参考上面的规范，于是有了下面一份中文技术文档的写作规范。 29 标题 29.1 层级 标题分为四级。 一级标题：文章的标题 二级标题：文章主要部分的大标题 三级标题：二级标题下面一级的小标题 四级标题：三级标题下面某一方面的小标题 下面是示例。 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 注：最多支持六级，但是同论文写作一样，层级太深，会使得整体显得杂乱无章，当确实需要更深层级时，应另起新篇单独论述。 29.2 原则 （1）一级标题下，不能直接出现三级标题。 示例：下面的文章结构，缺少二级标题。 # 一级标题 ### 三级标题 （2）标题要避免孤立编号（即同级标题只有一个）。 示例：下面的文章结构，二级标题 A只包含一个三级标题，完全可以省略三级标题 A。 ## 二级标题 A ### 三级标题 A ## 二级标题 B （3）下级标题不重复上一级标题的名字。 示例：下面的文章结构，二级标题与下属的三级标题同名，建议避免。 ## 概述 ### 概述 （4）谨慎使用四级标题，尽量避免出现，保持层级的简单，防止出现过于复杂的章节。 如果三级标题下有并列性的内容，建议只使用项目列表（Item list）。 示例：下面的结构二要好于结构一。结构一适用的场景，主要是较长篇幅的内容。 结构一 ### 三级标题 #### 四级标题 A #### 四级标题 B #### 四级标题 C 结构二 ### 三级标题 **（1）A** **（2）B** **（3）C** 30 文本 30.1 字间距 （1）全角中文字符与半角英文字符之间，应有一个半角空格。 错误：本文介绍如何快速启动Windows系统。 正确：本文介绍如何快速启动 Windows 系统。 （2）全角中文字符与半角阿拉伯数字之间，有没有半角空格都可，但必须保证风格统一，不能两种风格混杂。 正确：2011年5月15日，我订购了5台笔记本电脑与10台平板电脑。 正确：2011 年 5 月 15 日，我订购了 5 台笔记本电脑与 10 台平板电脑。 半角的百分号，视同阿拉伯数字。 正确：今年我国经济增长率是6.5%。 正确：今年我国经济增长率是 6.5%。 （3）英文单位若不翻译，单位前的阿拉伯数字与单位符号之间，应留出适当的空隙。 例1：一部容量为 16 GB 的智能手机 例2：1 h = 60 min = 3,600 s （4）半角英文字符和半角阿拉伯数字，与全角标点符号之间不留空格。 错误：他的电脑是 MacBook Air 。 正确：他的电脑是 MacBook Air。 30.2 句子 （1）避免使用长句。 不包含任何标点符号的单个句子，或者以逗号分隔的句子构件，长度尽量保持在 20 个字以内；20 ～ 29 个字的句子，可以接受；30 ～ 39 个字的句子，语义必须明确，才能接受；多于 40 个字的句子，任何情况下都不能接受。 错误：本产品适用于从由一台服务器进行动作控制的单一节点结构到由多台服务器进行动作控制的并行处理程序结构等多种体系结构。 正确：本产品适用于多种体系结构。无论是由一台服务器（单一节点结构），还是由多台服务器（并行处理结构）进行动作控制，均可以使用本产品。 逗号分割的长句，总长度不应该超过 100 字或者正文的 3 行。 （2）尽量使用简单句和并列句，避免使用复合句。 并列句：他昨天生病了，没有参加会议。 复合句：那个昨天生病的人没有参加会议。 （3）同样一个意思，尽量使用肯定句表达，不使用否定句表达。 错误：请确认没有接通装置的电源。 正确：请确认装置的电源已关闭。 （4）避免使用双重否定句。 错误：没有删除权限的用户，不能删除此文件。 正确：用户必须拥有删除权限，才能删除此文件。 30.3 写作风格 （1）尽量不使用被动语态，改为使用主动语态。 错误：假如此软件尚未被安装， 正确：假如尚未安装这个软件， （2）不使用非正式的语言风格。 错误：Lady Gaga 的演唱会真是酷毙了，从没看过这么给力的表演！！！ 正确：无法参加本次活动，我深感遗憾。 （3）不使用冷僻、生造或者文言文的词语，而要使用现代汉语的常用表达方式。 错误：这是唯二的快速启动的方法。 正确：这是仅有的两种快速启动的方法。 （4）用对“的”、“地”、“得”。 她露出了开心的笑容。 （形容词＋的＋名词） 她开心地笑了。 （副词＋地＋动词） 她笑得很开心。 （动词＋得＋副词） （5）使用代词时（比如“其”、“该”、“此”、“这”等词），必须明确指代的内容，保证只有一个含义。 错误：从管理系统可以监视中继系统和受其直接控制的分配系统。 正确：从管理系统可以监视两个系统：中继系统和受中继系统直接控制的分配系统。 （6）名词前不要使用过多的形容词。 错误：此设备的使用必须在接受过本公司举办的正式的设备培训的技师的指导下进行。 正确：此设备必须在技师的指导下使用，且指导技师必须接受过由本公司举办的正式设备培训。 30.4 英文处理 （1）英文原文如果使用了复数形式，翻译成中文时，应该将其还原为单数形式。 英文：...information stored in random access memory (RAMs)... 中文：⋯⋯存储在随机存取存储器（RAM）里的信息⋯⋯ （2）外文缩写可以使用半角圆点 (.) 表示缩写。 U.S.A. Apple, Inc. （3）表示中文时，英文省略号（...）应改为中文省略号（⋯⋯）。 英文：5 minutes later... 中文：5 分钟过去了⋯⋯ （4）英文书名或电影名改用中文表达时，双引号应改为书名号。 英文：He published an article entitled \"The Future of the Aviation\". 中文：他发表了一篇名为《航空业的未来》的文章。 （5）第一次出现英文词汇时，在括号中给出中文标注。此后再次出现时，直接使用英文缩写即可。 IOC（International Olympic Committee，国际奥林匹克委员会）。这样定义后，便可以直接使用“IOC”了。 （6）专有名词中每个词第一个字母均应大写，非专有名词则不需要大写。 “American Association of Physicists in Medicine”（美国医学物理学家协会）是专有名词，需要大写。 “online transaction processing”（在线事务处理）不是专有名词，不应大写。 31 段落 31.1 原则 一个段落只能有一个主题，或一个中心句子。 段落的中心句子放在段首，对全段内容进行概述。后面陈述的句子为中心句子服务。 一个段落的长度不能超过七行，最佳段落长度小于等于四行。 段落的句子语气要使用陈述和肯定语气，避免使用感叹语气。 段落之间使用一个空行隔开。 段落开头不要留出空白字符。 31.2 引用 引用第三方内容时，应注明出处。 One man’s constant is another man’s variable. — Alan Perlis 如果是全篇转载，请在全文开头显著位置注明作者和出处，并链接至原文。 本文转载自 WikiQuote 使用外部图片时，必须在图片下方或文末标明来源。 本文部分图片来自 Wikipedia 32 数值 32.1 半角数字 阿拉伯数字一律使用半角形式，不得使用全角形式。 错误：这件商品的价格是１０００元。 正确：这件商品的价格是 1000 元。 32.2 千分号 数值为千位以上，应添加千分号（半角逗号）。 XXX 公司的实收资本为 ￥1,258,000 人民币。 对于 4 位的数值，千分号是选用的，比如1000和1,000都可以接受。对于 4 位以上的数值，应添加千分号。 32.3 货币 货币应为阿拉伯数字，并在数字前写出货币符号，或在数字后写出货币中文名称。 $1,000 1,000 美元 英文的货币名称，建议参考国际标准 ISO 4217。 32.4 数值范围 表示数值范围时，用波浪线（～）或一字线（—）连接。参见《标点符号》一节的“连接号”部分。 带有单位或百分号时，两个数字建议都要加上单位或百分号。 132 kg～234 kg 67%～89% 32.5 变化程度的表示法 数字的增加要使用“增加了”、“增加到”。“了”表示增量，“到”表示定量。 增加到过去的两倍 （过去为一，现在为二） 增加了两倍 （过去为一，现在为三） 数字的减少要使用“降低了”、“降低到”。“了”表示增量，“到”表示定量。 降低到百分之八十 （定额是一百，现在是八十） 降低了百分之八十 （原来是一百，现在是二十） 不能用“降低 N 倍”或“减少 N 倍”的表示法，要用“降低百分之几”或“减少百分之几”。因为减少（或降低）一倍表示数值原来为一百，现在等于零。 33 标点符号 33.1 原则 （1）中文语句的标点符号，均应该采取全角符号，这样可以与全角文字保持视觉的一致。 （2）如果整句为英文，则该句使用英文/半角标点。 （3）句号、问号、","date":"2023-02-04","objectID":"/posts/document-style-guide/:0:0","tags":null,"title":"中文技术文档的写作规范","uri":"/posts/document-style-guide/"},{"categories":["Browser"],"content":"最近在抖音上刷到很多次 袁进老师 的前端视频，然后就听了一下他的前端大师课，感觉了解一些浏览器原理后，原来工作中的一些疑问也自然解开了。 1 浏览器的进程模型 1.1 何为进程？ 程序运行需要有它自己专属的内存空间，可以把这块内存空间简单的理解为进程 进程可以简单理解为单独的内存空间 每个应用至少有一个进程，进程之间相互独立，即使要通信，也需要双方同意。 1.2 何为线程？ 有了进程后，就可以运行程序的代码了。 运行代码的「人」称之为「线程」。 一个进程至少有一个线程，所以在进程开启后会自动创建一个线程来运行代码，该线程称之为主线程。 如果程序需要同时执行多块代码，主线程就会启动更多的线程来执行代码，所以一个进程中可以包含多个线程。 一个进程可以有 N 个线程 1.3 浏览器有哪些进程和线程？ 浏览器是一个多进程多线程的应用程序，浏览器内部工作极其复杂。 为了避免相互影响，为了减少连环崩溃的几率，当启动浏览器后，它会自动启动多个进程。 浏览器进程 可以在浏览器的任务管理器中查看当前的所有进程 其中，最主要的进程有： 浏览器进程 主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务。 网络进程 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务。 渲染进程（本篇重点讲解的进程） 渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。 默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同的标签页之间不相互影响。 将来该默认模式可能会有所改变，有兴趣的同学可参见 chrome 官方说明文档 2 渲染主线程是如何工作的？ 渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于： 解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把页面画 60 次 执行全局 JS 代码 执行事件处理函数 执行计时器的回调函数 …… 思考题：为什么渲染进程不适用多个线程来处理这些事情？ 要处理这么多的任务，主线程遇到了一个前所未有的难题：如何调度任务？ 比如： 我正在执行一个 JS 函数，执行到一半的时候用户点击了按钮，我该立即去执行点击事件的处理函数吗？ 我正在执行一个 JS 函数，执行到一半的时候某个计时器到达了时间，我该立即去执行它的回调吗？ 浏览器进程通知我“用户点击了按钮”，与此同时，某个计时器也到达了时间，我应该处理哪一个呢？ …… 渲染主线程想出了一个绝妙的主意来处理这个问题：排队 所有要执行的任务都要排队，FIFO 在最开始的时候，渲染主线程会进入一个无限循环 每一次循环会检查消息队列中是否有任务存在。如果有，就取出第一个任务执行，执行完一个后进入下一次循环；如果没有，则进入休眠状态。 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会加到消息队列的末尾。在添加新任务时，如果主线程是休眠状态，则会将其唤醒以继续循环拿取任务 这样一来，就可以让每个任务有条不紊的、持续的进行下去了。整个过程，被称之为事件循环（消息循环）。 3 若干解释 3.1 何为异步？ 代码在执行过程中，会遇到一些无法立即处理的任务，比如： 计时完成后需要执行的任务 —— setTimeout、setInterval 网络通信完成后需要执行的任务 — XHR、Fetch 用户操作后需要执行的任务 — addEventListener 如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于「阻塞」的状态，从而导致浏览器「卡死」 同步策略会导致卡死 渲染主线程承担着极其重要的工作，无论如何都不能阻塞！ 因此，浏览器选择异步来解决这个问题 异步策略，渲染主线程永不阻塞 使用异步的方式，渲染主线程永不阻塞 面试题：如何理解 JS 的异步？ 参考答案： JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。 而渲染主线程承担着诸多的工作，渲染页面、执行 JS 都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中的很多其他任务无法得到执行。这样一来，一方面会导致繁忙的主线程白白的消耗时间，另一方面导致页面无法及时更新，给用户造成卡死现象。 所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续代码。当其他线程完成时，将事先传递的回调函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行。 在这种异步模式下，浏览器永不阻塞，从而最大限度的保证了单线程的流畅运行。 3.2 JS 为何会阻碍渲染？ 先看代码 \u003ch1\u003eMr.Yuan is awesome!\u003c/h1\u003e \u003cbutton\u003echange\u003c/button\u003e \u003cscript\u003e var h1 = document.querySelector('h1'); var btn = document.querySelector('button'); // 死循环指定的时间 function delay(duration) { var start = Date.now(); while (Date.now() - start \u003c duration) {} } btn.onclick = function () { h1.textContent = '袁老师很帅！'; delay(3000); }; \u003c/script\u003e 点击按钮后，会发生什么呢？ \u003c复制代码自行演示\u003e 3.3 任务有优先级吗？ 任务没有优先级，在消息队列中先进先出 但消息队列是有优先级的 根据 W3C 的最新解释： 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列。 在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行。 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint 随着浏览器的复杂度急剧提升，W3C 不再使用宏队列的说法 在目前 chrome 的实现中，至少包含了下面的队列： 微队列：用户存放需要最快执行的任务，优先级「最高」 延时队列：用于存放计时器到达后的回调任务，优先级「中」 交互队列：用于存放用户操作后产生的事件处理任务，优先级「高」 微队列、延时队列、交互队列 添加任务到微队列的主要方式主要是使用 Promise、MutationObserver，例如： // 立即把一个函数添加到微队列 Promise.resolve().then(() =\u003e {}); 浏览器还有很多其他的队列，由于和我们开发关系不大，不作考虑。 面试题：阐述一下 JS 的事件循环 参考答案： 事件循环又叫做消息循环，是浏览器渲染主线程的工作方式。 在 Chrome 的源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务加入到队列末尾即可。 过去把消息队列简单分为宏队列和微队列，这种说法目前已无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，微队列的任务一定具有最高的优先级，必须优先调度执行。 面试题：JS 中的计时器能做到精确计时吗？为什么？ 参考答案： 不行，因为： 计算机硬件没有原子钟，无法做到精确计时 操作系统的计时函数本身就有少量偏差，由于 JS 的计时器最终调用的是操作系统的函数，也就携带了这些偏差 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4 毫秒的最少时间，这样在计时时间少于 4 毫秒时又带来了偏差 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，因此又带来了偏差 ","date":"2023-01-11","objectID":"/posts/event-loop/:0:0","tags":["Browser","JavaScript"],"title":"浏览器原理 - 事件循环","uri":"/posts/event-loop/"},{"categories":["Grocery"],"content":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效的解决办法","date":"2022-12-15","objectID":"/posts/homebrew-npm/","tags":["Homebrew","npm","npx","Mac","nvm","debug"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["Grocery"],"content":" 问题 前面一段时间，安装了 Homebrew, 但是今天切换 node 版本到 system version (8.10.0) 后，发现虽然 node 版本切换成功，但是 node 版本对应的 npm 和 npx 版本不相符，下面记录一下问题排查过程。 1 罪魁祸首 首先定位到这次问题的根本原因是安装 Homebrew 导致的，这点可以很快也很明确地定位到，因为以前安装 Homebrew 也遇到了这个问题，但是当时的做法是卸载 Homebrew 避免冲突。 2 Why 分析为啥会冲突，Homebrew 安装的工程中也会默认一部分依赖的二进制文件，npm 和 npx 也在其中，所以这导致了 Homebrew 的安装 npm 和 npx 覆盖了系统中 node 的 npm 和 npx 进而导致 node 和 npm 版本不一致，无法使用 npm 启动项目。 3 Where 找一下目前 npm 和 npx 的二进制文件在哪。 nvm use system node -v # 8.10.0 which npm # /opt/homebrew/bin/npm which npx # /opt/homebrew/bin/npx 4 How 很明显前面的猜测是对的，那就打开这个目录看看： open /opt/homebrew/bin 找到 npm 和 npx，把他们重命名为 npm-brew 和 npx-brew, 这样通过别名也保留 Homebrew 的 npm 和 npx. 修改完后，重启终端，再看看 npm 和 npx 是否生效： nvm use system node -v # 8.10.0 which npm # /usr/local/bin/npm which npx # /usr/local/bin/npx npm -v npx -v 一切正常了，可以用 npm 继续启动原来的项目了。 ","date":"2022-12-15","objectID":"/posts/homebrew-npm/:0:0","tags":["Homebrew","npm","npx","Mac","nvm","debug"],"title":"安装 Homebrew 后导致系统中原有的 npm 和 npx 失效","uri":"/posts/homebrew-npm/"},{"categories":["GitHub"],"content":"Lruihao/cell tooltip: 基于 Bootstrap 5 + Font Awesome 6 的消息提示插件","date":"2022-12-09","objectID":"/projects/lruihao/cell-tooltip/","tags":[],"title":"基于 Bootstrap 5 + Font Awesome 6 的消息提示插件","uri":"/projects/lruihao/cell-tooltip/"},{"categories":["GitHub"],"content":"Cell Tooltip 基于 Bootstrap 5 + Font Awesome 6 的消息提示插件 (Base on Bootstrap#Alerts) Documentation 文档更新命令： npm run docs Usage this.tooltip = new CellTooltip({ position: 'top-center', offset: document.querySelector('.container-header').offsetHeight }); this.tooltip.show({ type: 'info', content: 'hello world!' }); /* Or */ this.tooltip.info({ content: 'hello world!' }); ","date":"2022-12-09","objectID":"/projects/lruihao/cell-tooltip/:0:0","tags":[],"title":"基于 Bootstrap 5 + Font Awesome 6 的消息提示插件","uri":"/projects/lruihao/cell-tooltip/"},{"categories":["GitHub"],"content":"Lruihao/vue minder editor extended: 基于 fex-team/kityminder-core 和 Vue2 封装的在线脑图编辑组件","date":"2022-10-10","objectID":"/projects/lruihao/vue-minder-editor-extended/","tags":["editor","minder","vue"],"title":"基于 fex-team/kityminder-core 和 Vue2 封装的在线脑图编辑组件","uri":"/projects/lruihao/vue-minder-editor-extended/"},{"categories":["GitHub"],"content":"Vue Minder Editor 基于 kityminder-core 实现的 Vue2 脑图编辑器组件。 Install npm install vue-minder-editor-extended --save Usage 注册组件： import vueMinderEditor from 'vue-minder-editor-extended' import Vue from 'vue' Vue.use(vueMinderEditor) 使用组件： \u003ctemplate\u003e \u003cdiv\u003e \u003cminder-editor :progress-enable=\"false\" :import-json=\"importJson\"/\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import minderEditor from '../../dist/static/vue-minder-editor-extended' import vue from 'vue' vue.use(minderEditor); export default { name: 'test-plugin', data() { return { importJson: { // 节点数据 root: { data: { // 文本内容 text: 'vue-minder-editor-extended', // 标签 resource: ['模块1'], // 是否禁止修改 disable: true, // 默认展开或折叠，默认是展开的，collapse 可设为折叠 // expandState: 'collapse', // 在 disable 为 true 的情况下，允许添加标签 tagEnable: true, // 在 disable 为 true 的情况下，允许删除节点 allowDelete: true, // 在 disable 为 true 的情况下，允许添加标签，优先级比 tagEnable 高 allowDisabledTag: true, }, // 子节点 children: [ { data: { text: 'child1', disable: true, expandState: 'collapse', resource: ['模块2'] }, children: [ { data: { text: 'child11', disable: true, resource: ['模块2'] }, }, { data: { text: 'child12', } } ] }, { data: { text: 'child2', } } ] }, }, tags: ['模块1','模块2'] } } } \u003c/script\u003e 国际化 // 方式一 import locale from '/src/locale/lang/en-US' Vue.use(vueMinderEditorExtended, { locale }); // 方式二 import lang from '/src/locale/lang/en-US' import locale from '/src/locale' locale.use(lang) Vue.use(vueMinderEditorExtended); // 方式三 import Vue from 'vue'; import VueI18n from 'vue-i18n'; import enLocale from 'vue-minder-editor-extended/src/locale/lang/en-US'; import zhLocale from 'vue-minder-editor-extended/src/locale/lang/zh-CN'; import vueMinderEditor from 'vue-minder-editor-extended'; const messages = { en: { message: 'hello', ...enLocale }, zh: { message: '你好', ...zhLocale } } Vue.use(VueI18n); const i18n = new VueI18n({ locale: 'en', // set locale messages, // set locale messages }) Vue.use(vueMinderEditor, { i18n: (key, value) =\u003e i18n.t(key, value) }); 主题 Vue Minder Editor 组件已支持初始化时设置主题及注册主题，默认主题为 fresh-blue。 如需手动注册设置主题，允许使用的主题及其配置项可以使用 window.kityminder.Minder.getThemeList() 查询。 // 注册主题 window.kityminder.Theme.register('my-minder-theme', minderThemeItems) // 设置主题 window.minder.useTheme('my-minder-theme') // 或者 window.minder.execCommand('theme', 'my-minder-theme') Props 以下配置部分为 kityminder-core 扩展的功能，kityminder-core 本身的 minder 对象提供了丰富的功能，使用该组件时可通过 window.minder 对象获取 minder 对象具体的使用方法，可以参考它的文档扩展 kityminder-core wiki 以及 #API 章节补充。 基础配置 Name Description Type Default importJson 需要脑图解析的 js 对象，参数详情可参考上文 demo，或者调用 minder.exportJson() 查看具体参数 Object null height 显示高度，默认 500px Number 500 theme 设置初始化主题，可选值使用 window.kityminder.Minder.getThemeList() 查询 String fresh-blue registerTheme 注册主题，参数为主题配置项，如 registerTheme: { ...minderThemeItems } Object null disabled 是否禁止编辑 Boolean null defaultMold 外观设置中样式的默认值 Number 3 启用配置 Name Description Type Default sequenceEnable 是否启用优先级功能 Boolean true tagEnable 是否启用标签功能 Boolean true progressEnable 是否启用完成进度功能 Boolean true moveEnable 是否启用上移下移功能 Boolean true 优先级配置 Name Description Type Default priorities 优先级选项，当该参数不为空时 priorityCount, priorityStartWithZero, priorityPrefix 不生效 Array [] priorityCount 优先级最大显示数量，最多支持显示 9 个级别 Number 4 priorityStartWithZero 优先级是否从 0 开始 Boolean true priorityPrefix 优先级显示的前缀 String ‘P’ priorityDisableCheck 优先级设置的回调函数，如果返回 true 则无法设置优先级 Function null 标签配置 Name Description Type Default tags 标签选项 Array [] distinctTags 定义排他标签，比如 [’tag1’,’tag2’], 则 tag1 不能和 tag2 共存 Array [] tagDisableCheck 菜单栏是否允许打标签的回调函数，返回 true 则不允许打标签 Function null tagEditCheck 打标签时的回调函数，返回 false 则打标签不成功，参数为当前节点的标签数组 Function null Slots Name Description - 在脑图区域自定义额外内容 edit-menu 在思维导图 tab 最后自定义额外内容 view-menu 在外观样式 tab 最后自定义额外内容 API 补充 kityminder-core wiki 中未说明的 API 文档。 minder 更多请查看 window.minder 对象或者 window.km 对象 window.minder.setTheme() 设置主题 window.minder.useTheme() 设置主题 (同 setTheme) window.minder.getTheme() 获取当前主题 window.minder.getThemeItems() 获取当前主题的所有样式 window.minder.execCommand(command, params) 执行命令 kityminder 更多请查看 window.kityminder 对象 window.kityminde","date":"2022-10-10","objectID":"/projects/lruihao/vue-minder-editor-extended/:0:0","tags":["editor","minder","vue"],"title":"基于 fex-team/kityminder-core 和 Vue2 封装的在线脑图编辑组件","uri":"/projects/lruihao/vue-minder-editor-extended/"},{"categories":["GitHub"],"content":"hugo fixit/hugo fixit starter: 🆕 A quick-start template base on Hugo Modules to create a Hugo FixIt site.","date":"2022-09-30","objectID":"/projects/hugo-fixit/hugo-fixit-starter/","tags":["blog","hugo-blog","hugo-blog-template","hugo-fixit","hugo-fixit-starter"],"title":"🆕 A quick-start template base on Hugo Modules to create a Hugo FixIt site.","uri":"/projects/hugo-fixit/hugo-fixit-starter/"},{"categories":["GitHub"],"content":"Hugo FixIt 博客模板（Go） 👉 中文 | English 这是 Hugo 主题 FixIt 的快速启动模板。它使用 Hugo 模块 功能加载主题。如果你更熟悉 Git，可以 查看这个模板。 它提供了基本的主题结构和配置。已经设置了 GitHub Actions，可以自动部署博客到 GitHub Pages。此外，还有一个定时任务，每天自动更新主题。 目录结构 ▸ .github/ # GitHub configuration ▸ archetypes/ # page archetypes (like scaffolds of archetypes) ▸ assets/ # css, js, third-party libraries etc. ▸ config/ # configuration files ▸ content/ # markdown files for hugo project ▸ data/ # blog data (allow: yaml, json, toml), e.g. friends.yml ▸ public/ # build directory ▸ static/ # static files, e.g. favicon.ico ▸ themes/ # theme submodules ▸ go.mod ▸ go.sum 快速入门 完整的快速入门，请参阅此 页面。 准备 Go Hugo (extended version) 使用模板 CLI npx fixit-cli create my-blog 手动 点击 Use this template，在 GitHub 上创建你的存储库。 存储库创建后，只需克隆并享受吧！ # 使用你自己的存储库 URL 进行克隆 git clone --recursive https://github.com/\u003cyour_name\u003e/\u003cyour_blog_repo\u003e.git 提示 仓库名决定了你的 GitHub Pages URL，例如： 仓库名 GitHub Pages \u003cyour_name\u003e.github.io https://\u003cyour_name\u003e.github.io/ blog https://\u003cyour_name\u003e.github.io/blog/ 启动站点 # 开发环境 hugo server # 生产环境 hugo server -e production 构建站点 当你的站点准备部署时，运行以下命令： hugo 部署到 GitHub Pages 注意 聪明的你可能已经注意到，模板初始化后的第一次 GitHub Actions 自动部署失败了。这是因为你还没有配置 Workflow 权限和 GitHub Pages。 转到 Setting =\u003e Actions =\u003e General =\u003e Workflow permissions =\u003e 选中 “Read and write permissions”。 GitHub Pages 设置：Setting =\u003e Pages =\u003e Source: GitHub Actions。 修改 config/_default/hugo.toml 文件中的 baseURL 为你的站点 URL。 提交上一步的修改到 main 分支，GitHub Actions 将自动打包并部署站点到 GitHub Pages。 更新主题 之后，你可以使用以下命令升级主题： # 手动更新主题 hugo mod get -u github.com/hugo-fixit/FixIt@latest hugo mod tidy 通过 NPM 脚本启动 # 构建博客 npm run build # 运行带有监视的本地调试服务器 npm run server # 在生产环境中运行本地调试服务器 npm run server:production # 更新主题子模块 npm run update:theme 故障排除 remote: Permission to git denied to github-actions[bot]. 转到 Setting =\u003e Actions =\u003e General =\u003e Workflow permissions =\u003e 选中 \"Read and write permissions\"。 ","date":"2022-09-30","objectID":"/projects/hugo-fixit/hugo-fixit-starter/:0:0","tags":["blog","hugo-blog","hugo-blog-template","hugo-fixit","hugo-fixit-starter"],"title":"🆕 A quick-start template base on Hugo Modules to create a Hugo FixIt site.","uri":"/projects/hugo-fixit/hugo-fixit-starter/"},{"categories":["GitHub"],"content":"hugo fixit/hugo fixit starter1: 🆕 A quick-start template base on Git submodule to create a Hugo FixIt site.","date":"2022-09-27","objectID":"/projects/hugo-fixit/hugo-fixit-starter1/","tags":["blog","hugo-blog","hugo-blog-template","hugo-fixit","hugo-fixit-starter"],"title":"🆕 A quick-start template base on Git submodule to create a Hugo FixIt site.","uri":"/projects/hugo-fixit/hugo-fixit-starter1/"},{"categories":["GitHub"],"content":"Hugo FixIt 博客模板（Git） 👉 中文 | English 这是 Hugo 主题 FixIt 的快速启动模板。它使用 Git 子模块 功能来加载主题。如果你更熟悉 Go，可以 查看这个模板。 它提供了基本的主题结构和配置。已经设置了 GitHub Actions，可以自动部署博客到 GitHub Pages。此外，还有一个定时任务，每天自动更新主题。 目录结构 ▸ .github/ # GitHub configuration ▸ archetypes/ # page archetypes (like scaffolds of archetypes) ▸ assets/ # css, js, third-party libraries etc. ▸ config/ # configuration files ▸ content/ # markdown files for hugo project ▸ data/ # blog data (allow: yaml, json, toml), e.g. friends.yml ▸ public/ # build directory ▸ static/ # static files, e.g. favicon.ico ▸ themes/ # theme submodules 快速入门 完整的快速入门请参阅此 页面。 准备 Hugo: \u003e= 0.132.0 (extended version) 使用此模板 CLI npx fixit-cli create my-blog 手动 点击 Use this template，在 GitHub 上创建你的仓库。 仓库创建后，只需克隆并开始使用！ # 使用你自己的仓库 URL 进行克隆 git clone --recursive https://github.com/\u003cyour_name\u003e/\u003cyour_blog_repo\u003e.git 提示 仓库名决定了你的 GitHub Pages URL，例如： 仓库名 GitHub Pages \u003cyour_name\u003e.github.io https://\u003cyour_name\u003e.github.io/ blog https://\u003cyour_name\u003e.github.io/blog/ 启动站点 # 开发环境 hugo server # 生产环境 hugo server -e production 构建站点 当你的站点准备部署时，运行以下命令： hugo 部署到 GitHub Pages 注意 聪明的你可能已经注意到，模板初始化后的第一次 GitHub Actions 自动部署失败了。这是因为你还没有配置 Workflow 权限和 GitHub Pages。 转到 Setting =\u003e Actions =\u003e General =\u003e Workflow permissions =\u003e 选中 “Read and write permissions”。 GitHub Pages 设置：Setting =\u003e Pages =\u003e Source: GitHub Actions。 修改 config/_default/hugo.toml 文件中的 baseURL 为你的站点 URL。 提交上一步的修改到 main 分支，GitHub Actions 将自动打包并部署站点到 GitHub Pages。 更新主题 之后，你可以使用以下命令升级主题： # 手动更新主题 git submodule update --remote --merge themes/FixIt 通过 NPM 脚本启动 npm install # 构建博客 npm run build # 运行带有监视的本地调试服务器 npm run server # 在生产环境中运行本地调试服务器 npm run server:production # 更新主题子模块 npm run update:theme 故障排除 remote: Permission to git denied to github-actions[bot]. 转到 Setting =\u003e Actions =\u003e General =\u003e Workflow permissions =\u003e 选中 \"Read and write permissions\"。 ","date":"2022-09-27","objectID":"/projects/hugo-fixit/hugo-fixit-starter1/:0:0","tags":["blog","hugo-blog","hugo-blog-template","hugo-fixit","hugo-fixit-starter"],"title":"🆕 A quick-start template base on Git submodule to create a Hugo FixIt site.","uri":"/projects/hugo-fixit/hugo-fixit-starter1/"},{"categories":["GitHub"],"content":"hugo fixit/hugo shell: Using frequently-used Hugo commands by shell.","date":"2022-09-04","objectID":"/projects/hugo-fixit/hugo-shell/","tags":["hugo"],"title":"Using frequently-used Hugo commands by shell.","uri":"/projects/hugo-fixit/hugo-shell/"},{"categories":["GitHub"],"content":"Hugo Shell Using frequently-used Hugo commands by shell. Download Add a submodule for your Hugo blog project. git submodule add https://github.com/hugo-fixit/hugo-shell.git your_hugo_blog/.shell Usage Run hugo_main.sh to choice frequently-used Hugo commands: cd .shell \u0026\u0026 sh hugo_main.sh --------------Hugo Admin-------------- Please enter the serial number to work -------------------------------------- 1. post 2. server 3. server:production 4. build 5. submodule-sync 6. push -------------------------------------- Press Ctrl+C to stop ","date":"2022-09-04","objectID":"/projects/hugo-fixit/hugo-shell/:0:0","tags":["hugo"],"title":"Using frequently-used Hugo commands by shell.","uri":"/projects/hugo-fixit/hugo-shell/"},{"categories":["Go"],"content":"记录 GO 及 Beego 框架安装及基础配置。 1 安装 Go 官网下载安装包：https://golang.google.cn/dl/ 通过二进制文件快速安装，默认安装目录：/usr/local/go 配置环境变量 vim ~/.bash_profile # golang export GOROOT=/usr/local/go export GOBIN=$GOROOT/bin export PATH=$PATH:$GOBIN export GOPATH=$HOME/go export GOPROXY=https://goproxy.cn # Go work bin export PATH=$PATH:$GOPATH/bin 2 安装 Beego Beego repository Beego docs Beego new docs Beego 的安装需要在新建项目且 go mod init \u003cmodule_name\u003e之后，在项目下执行，具体参考 beego#quick-start。 3 安装 bee bee repository 注意：arm64 架构的 mac (M1 ～系列)，下载安装 bee 时最好，使用 Rosetta 打开终端，不然无法下载 darwin_arm64 的依赖，如果已经安装了，可以使用 Rosetta 打开终端后，运行 bee update 升级，升级完后将终端复原。 bee 工具安装，go install 安裝指定版本的 bee 工具，例如： go install github.com/beego/bee/v2@latest 安装成功后，可以在 $GOPATH/bin 下看到 bee 的可执行文件。 检验 bee 工具是否安装成功： bee version 创建一个新的 Beego 项目 bee new hello cd hello go mod tidy bee run ","date":"2022-08-31","objectID":"/posts/beego-install/:0:0","tags":["Beego","Go"],"title":"Beego 安装及配置","uri":"/posts/beego-install/"},{"categories":["Spec"],"content":" 摘要 版本格式：MAJOR.MINOR.PATCH，版本号递增规则如下： MAJOR: 主版本号，当你做了不兼容的 API 修改 MINOR: 次版本号，当你做了向下兼容的功能性新增 PATCH: 修订号，当你做了向下兼容的问题修正 先行版本号及版本编译信息可以加到 MAJOR.MINOR.PATCH 的后面，作为延伸。 25 格式 基本的语法格式如下，更多请参考 Backus–Naur Form Grammar for Valid SemVer Versions \u003cvalid semver\u003e ::= \u003cversion core\u003e | \u003cversion core\u003e \"-\" \u003cpre-release\u003e | \u003cversion core\u003e \"+\" \u003cbuild\u003e | \u003cversion core\u003e \"-\" \u003cpre-release\u003e \"+\" \u003cbuild\u003e 范例： 代码状态 等级 规则 版本样例 首次发布 新品发布 以 1.0.0 开始 1.0.0 bug 修复，向后兼容 补丁版本发布 变更第三位数字 1.0.1 新功能，向后兼容 次版本发布 变更第二位数字，并且第三位数字重置为 0 1.1.0 重大变更，不向后兼容 主版本发布 变更第一位数字，并且第二位，第三位数字重置为 0 2.0.0 “v1.2.3”是一个语义化版本号吗？ “v1.2.3”并不是的一个语义化的版本号。 但是，在语义化版本号之前增加前缀“v”是用来表示版本号的常用做法。 在版本控制系统中，将“version”缩写为“v”是很常见的。 比如：git tag v1.2.3 -m \"Release version 1.2.3\" 中，标签是“v1.2.3”，语义化版本号是“1.2.3”。 26 规范 以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。 语义化版本控制规范（SemVer） 使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。 标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -\u003e 1.10.0 -\u003e 1.11.0。 标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。 主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。 1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。 修订号 Z（x.y.Z | x \u003e 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。 次版本号 Y（x.Y.z | x \u003e 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用（deprecated）时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。 主版本号 X（X.y.z | X \u003e 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。 先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。 版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。 版本的优先层级指的是不同版本在排序时如何比较。 判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。 由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。 例如：1.0.0 \u003c 2.0.0 \u003c 2.1.0 \u003c 2.1.1。 当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。 例如：1.0.0-alpha \u003c 1.0.0。 有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定： 只有数字的标识符以数值高低比较。 有字母或连接号时则逐字以 ASCII 的排序来比较。 数字的标识符比非数字的标识符优先层级低。 若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。 例如：1.0.0-alpha \u003c 1.0.0-alpha.1 \u003c 1.0.0-alpha.beta \u003c 1.0.0-beta \u003c 1.0.0-beta.2 \u003c 1.0.0-beta.11 \u003c 1.0.0-rc.1 \u003c 1.0.0 27 版本阶段 Base: 设计阶段，只有相应的设计没有具体的功能实现 Alpha: 软件的初级版本，基本功能已经实现，但存在较多的 bug Bate: 相对于 Alpha 已经有了很大的进步，消除了严重的 BUG，但还存在一些潜在的 BUG，还需要不断测试 RC: 该版本已经相当成熟了，基本上不存在导致错误的 Bug，与即将发行的正式版本相差无几 RELEASE: 最终发布版本，没有太大的问题 最终发布版本（RELEASE）之前的所有版本，都称为先行版本（pre-release）。 28 FAQ 29 其他相关 29.1 npm SemVer 通常我们发布一个包到 npm 仓库时，我们的做法是先修改 package.json 为某个版本，然后执行 npm publish 命令。手动修改版本号的做法建立在你对 SemVer 规范特别熟悉的基础之上，否则可能会造成版本混乱。npm 和 yarn 两个包管理都提供了 SemVer 规范的版本控制命令： npm-version yarn version npm 发包基础命令： # 1. 创建一个新的包 npm init # 2. 查看是否官方源 npm config get registry # 3. 登录 npm login # 4. 发布 npm publish # 版本变化 major.minor.patch npm version patch # 升级补丁版本 npm version minor # 升级小版号 npm version major # 升级大版号 # 下架 [-force] npm unpublish 全局设置版本号前缀 # https://docs.npmjs.com/cli/v8/using-npm/config#tag-version-prefix npm config set tag-version-prefix \"\" # 全局设置版本更新 commit 提交信息 # https://docs.npmjs.com/cli/v8/using-npm/config#message npm config set message \"Chore(release): %s\" 或者设置项目的 .npmrc 或者 .yarnrc # .npmrc tag-version-prefix=\"\" message=\"Chore(release): %s\" # .yarnrc version-tag-prefix \"\" version-git-message \"Chore(release): %s\" package.json 版本控制规则使用了一些些符号： ^ ~ \u003e \u003e= \u003c \u003c= = - || 这些规则的详情如下： ^: 只会执行不更改最左边非零数字的更新。如果写入的是 ^0.13.0，则当运行 npm update 时，可以更新到 0.13.1、0.13.2 等，但不能更新到 0.14.0 或更高版本。如果写入的是 ^1.13.0，则当运行 npm update 时，可以更新到 1.13.1、1.14.0 等，但不能更新到 2.0.0 或更高版本。 ~: 如果写入的是 〜0.13.0，则当运行 npm update 时，会更新到补丁版本：即 0.13.1 可以，但 0.14.0 不可以。 \u003e: ","date":"2022-08-13","objectID":"/posts/semver/:0:0","tags":["SemVer"],"title":"语义版本控制（SemVer）","uri":"/posts/semver/"},{"categories":["Spec","Git"],"content":" Commit messages are short descriptions of changes to a repository. We should follow certain standards to effectively describe changes, such as the Conventional Commits specification based on the Angular convention that is most used on GitHub, or each development team can simplify and formulate their own commit specification. This is not only conducive to the automatic generation of Changelog in the later stage, but more importantly, when a bug occurs, the entire warehouse can be quickly checked, the problem point can be accurately located, and the version can be reverted. 13 Format [{emoji} ]{type}[({module})]: {subject within 50 words}[ (#{issue/pull request})] example: : tada: Feat: add shortcode fixit-encryptor shortcode (#123) : arrow_up: Chore(libs): update Artalk from 2.2.12 to 2.3.4 (#150) 14 Emoji https://gitmoji.dev vscode plugin utools plugin GitEmoji 15 Message Emoji Type Example Description (No Ambiguous) 🎉 ✨ Feat Feat: add {feature} new feature 🚚 Feat: adjust/migrate {feature name}, {change details} For the adjustment feature, it is necessary to describe the current situation (before) and after adjustment (after) 🔥 Feat: delete {feature name}, {deletion reason} If the feature is deleted, the reason for deletion must be explained 🐛 🚧 🚨 Fix Fix: fix {bug description} Fix known bugs 🎨 💄 ✏️ Style Style: Typesetting/CSS style {optimizing content} Changes that do not affect code operation, such as code layout and style change ♻️ Refactor Refactor: override {feature name} It is neither a new function nor a code change to fix a bug. Simply rewriting the code of a function does not affect the function result ⚡ Perf Perf: improve performance {function name}, {improve content} Optimize code performance ⏪ Revert Revert: restore version {commit message of restore version} Restore the version of one commit 📝 ✏️ Docs Docs: revise comments/update documents Adjustment of documents and notes 🔧 Chore Chore: update plugin version Changes in the construction process or auxiliary tools ","date":"2022-08-12","objectID":"/posts/commit-spec/:0:0","tags":["Git"],"title":"Commit Message Spec","uri":"/posts/commit-spec/"},{"categories":["JavaScript"],"content":"总结一下最近 electron 开发遇到的问题和一些重要知识点。 1 简介 如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的开源框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。 2 知识点 2.1 进程 electron 由两种进程组成，包括主进程和 0 个或 n 个渲染进程。 主进程：承担应用的生命周期（包括启动，退出，准备，正在切换到后台，正在切换到前台等，还负责与原生操作系统 API 通信） 渲染进程：做 web 页面的 ui，渲染进程之间独立在各自的单线程，渲染进程之间相互隔离，不能直接访问操作系统，需要通信到主线程，在通过主线程操作访问操作形态，一个 BrowserWindow 实例即为一个渲染进程 2.2 技术栈 electron 整合了 Node 和浏览器的所有能力，可以随意发挥这些技术栈的特点。由于固定浏览器内核，可以无需考虑兼容性地使用 html/js/css 新特性。 2.3 安装 安装 electron 时，可能因为网络问题导致下载失败，需要使用镜像仓库来下载。 # 设置 electron 镜像仓库 # https://registry.npmmirror.com/-/binary/electron # 13.1.7 版本 下载链接可能会拼错导致 404，要设置成 https://registry.npmmirror.com/-/binary/electron/v npm config set electron_mirror=https://npmmirror.com/mirrors/electron/ M1 Mac 安装较低版本 electron 时可能会报错，Failed to find Electron v xxx for darwin-arm64，因为这些版本的 electron 不支持 darwin-arm64 架构。Apple 针对未适配的 X64 应用提供了 Rosetta2 转换器，安装 darwin-x64 版本的 electron 在 Intel 模式下运行即可，参考。 2.4 remote 不要频繁使用 remote, 更多应该手动进行和主进程之间的通信。 使用时需在窗口创建时设置 webPreferences.enableRemoteModule 为 true。 旧版本的 electron.remote 已经弃用，应该使用依赖 electron/remote 代替。 使用了旧版本的 remote 时会有控制台警告信息： (electron) The remote module is deprecated. Use https://github.com/electron/remote instead. 获取当前窗口：remote.getCurrentWindow() 3 问题点 3.1 打开外部浏览器 electron 的 shell 模块，可以使用 shell.openExternal(url) 在默认浏览器打开链接。 3.2 防抖与节流 防抖：短期内大量触发事件时，只执行最后一次。 function debounce(fn) { let timer = null; return function () { clearTimeOut(timer); timer = setTimeOut(() =\u003e { fn.applay(this, arguments); }, 300); }; } 节流：短期内大量触发事件时，只执行第一次。 function throttle(fn) { let timer = null; return function () { if (timer) return; timer = setTimeOut(() =\u003e { fn.applay(this, arguments); timer = null; }, 300); }; } 3.3 devTools 初始化窗口时设置 webPreferences.devTools 为 true，然后通过 mainWindow.webContents.openDevTools() 打开开发者工具。 如果只在开发环境启用开发者工具，则需要设置 webPreferences.devTools 为 process.env.NODE_ENV === 'development' 3.4 启动白屏 在创建窗口时设置 show: false，在 ready-to-show 事件之后执行 mainWindow.show()， 可见官方文档 优雅地显示窗口。 3.4.1 启动前 loading 额外创建一个 loading 窗口，该窗口可设置为透明只包含 loading 图标和文字，在 mainWindow.show() 后关闭。 3.4.2 启动后 loading 如果使用了 Vue 框架，在 Vue 初始化之前窗口虽然出现了，但是内容时空白的，可以在 Vue 实例 #app 里写一个 loading, Vue 加载完后会覆盖掉。 \u003cdiv id=\"app\"\u003e \u003c!-- Display the loading icon and text until Vue initialization is complete --\u003e \u003cstyle type=\"text/css\"\u003e html, body { height: 100%; margin: 0; } body { display: flex; } #app { margin: auto; display: flex; align-items: center; } @media (prefers-color-scheme: dark) { body { color: #fff; background-color: #202124; } } \u003c/style\u003e \u003csvg xmlns=\"http://www.w3.org/2000/svg\" style=\"margin:auto;background:0 0\" width=\"60\" height=\"60\" viewBox=\"0 0 100 100\" preserveAspectRatio=\"xMidYMid\" display=\"block\" \u003e \u003ccircle cx=\"50\" cy=\"50\" r=\"20\" stroke-width=\"4\" stroke=\"#a5a5a5\" stroke-dasharray=\"31.416 31.416\" fill=\"none\" stroke-linecap=\"round\" transform=\"rotate(67.21 50 50)\" \u003e \u003canimateTransform attributeName=\"transform\" type=\"rotate\" repeatCount=\"indefinite\" dur=\"1s\" keyTimes=\"0;1\" values=\"0 50 50;360 50 50\" /\u003e \u003c/circle\u003e \u003c/svg\u003e \u003cspan\u003e加载中 ...\u003c/span\u003e \u003c/div\u003e 3.5 阻止窗口关闭 可以在关闭前一些事件里做拦截，比如：onbeforeunload 等，详见 实例事件。 3.6 手动关闭窗口 当自定义关闭时，使用 mainWindow.destroy() 来关闭窗口，因为使用 mainWindow.close() 时，windows 系统打开开发者工具时会出现无法关闭窗口的情况。 3.7 全局快捷键 当 electron 版本较低时，比如 13.1.7，会出现在 mac 系统上复制粘贴等常用快捷键失效的问题。可通过设置菜单并绑定快捷键的方式解决。 const main = [ { label: '', submenu: [ { label: '关于', role: 'about' }, { label: '关闭', role: 'close' }, { label: '退出', role: 'quit' } ] }, { label: '编辑', submenu: [ { label: '撤销', role: 'undo' }, { label: '恢复', role: 'redo' }, { type: 'separator' }, { label: '剪切', role: 'cut' }, { label: '复制', role: 'copy' }, { label: '粘贴', role: 'paste' }, { type: 'separator' }, { label: '全选', role: 'selectAll' } ] } ]; const dev = [ { label: '开发者', submenu: [ { label: '刷新', role: 'reload' }, { label: '强制刷新', role: 'forcereload' }, { type: 'separator' }, { label: '开发者工具', role: 'toggledevtools' } ] } ]; if (process.env.NODE_ENV === 'development') { main.push(...dev); } export default main; import memuConfig from './menu'; import { Menu } f","date":"2022-08-12","objectID":"/posts/electron-summary/:0:0","tags":["electron"],"title":"electron 踩坑总结","uri":"/posts/electron-summary/"},{"categories":["JavaScript"],"content":"记录一下前端实现页面加密的思路。 1 加密基础知识 1.1 双向加密 可还原的加密算法，可以逆向解密。 对称加密（单密钥加密） 采用单钥密码系统的加密方法，同一个密钥同时用作信息的加密和解密。 密钥生成算法有 DES、3DES、AES。 非对称加密（公开密钥系统） 两个密钥：公开密钥（publickey）和私有密钥（privatekey）。 公钥/私钥加密/签名，用私钥/公钥解密/验证签名。 密钥生成算法有 RSA（公钥、私钥）、DSA（公钥、私钥、数字签名）。 1.2 单向加密 不可还原的加密算法（暴力撞库除外），常见的算法有：MD5、SHA1、SHA256、SHA512。 2 页面内容加密 内容加密算法 通过比对密码和输入的 md5 值来判断密码是否输入正确 密码验证通过后，开始解密内容 拿到正确的输入值的 sha256 值的部分内容 然后按照加密规则解秘内容 这里利用 Set 进行事件管理，简单模拟了 addEventListener 和 removeEventListener 的操作。并提供了两个事件：decrypted 和 reset，详见 fixit-decryptor.js。 ","date":"2022-08-08","objectID":"/posts/encryption-fe/:0:0","tags":["JavaScript","加密"],"title":"前端页面内容加密总结","uri":"/posts/encryption-fe/"},{"categories":["Node.js","JavaScript"],"content":" 问题 腾讯云云函数从 2022 年 6 月 1 日开始收费了，差不多每个月 12 块，对于可能几个月都用不上一次云函数刷新缓存的人来说，有点太贵了。 使用 Node.js 和 GitHub Actions 刷新 CDN 的方式，可以节省不少钱。 1 安装依赖 npm install qcloud-cdn-node-sdk 2 编写脚本 vim .scripts/qcloudcdn.js /** * Refresh Qcloud CDN cache * @command `node qcloudcdn.js $SECRET_ID $SECRET_KEY` */ const qcloudSDK = require('qcloud-cdn-node-sdk'); // Get the config from https://console.qcloud.com/capi qcloudSDK.config({ secretId: process?.argv[2], secretKey: process?.argv[3] }); qcloudSDK.request( 'RefreshCdnDir', { // See https://cloud.tencent.com/document/api/228/3947 'dirs.0': 'https://lruihao.cn/' }, (res) =\u003e { res.code \u0026\u0026 console.log(res); } ); 3 增加快捷指令 打开 package.json 增加 scripts: { \"scripts\": { \"qcloudcdn\": \"node .scripts/qcloudcdn.js $SECRET_ID $SECRET_KEY\" } } 运行方式： SECRET_ID=\u003csecretId\u003e SECRET_KEY=\u003csecretKey\u003e npm run qcloudcdn Mac OS 环境变量配置（可选） vim ~/.bash_profile # Qcloud secret key-value export SECRET_ID=\u003csecretId\u003e export SECRET_KEY=\u003csecretKey\u003e source ~/.bash_profile 然后，在本地可简化指令为 npm run qcloudcdn 或者 yarn qcloudcdn。 等同于 SECRET_ID=$SECRET_ID SECRET_KEY=$SECRET_KEY npm run qcloudcdn 4 配置 GitHub Actions 在原有 GitHub Actions 中部署后增加一个步骤： - name: Refresh Qcloud CDN cache env: SECRET_ID: ${{ secrets.SECRET_ID }} SECRET_KEY: ${{ secrets.SECRET_KEY }} run: npm run qcloudcdn 在仓库 Settings \u003e Secrets \u003e Actions 中增加两个 Secret: SECRET_ID 和 SECRET_KEY，原来有配置过的就不用了，比如，我原来的叫 COS_SECRET_ID 和 COS_SECRET_ID，那修改上面配置 env 中的变量名即可。 最后上传代码，以后更新仓库时就会自动刷新 CDN 缓存了。 5 参考资料 Qcloud_CDN_API/nodejs 本方案使用的旧的 API 请求方式，如果失效，可以参考新的 API，见 SDK 中心。 ","date":"2022-08-07","objectID":"/posts/qcloudcdn/:0:0","tags":["CDN","GitHub Actions","Node.js"],"title":"Node.js + GitHub Actions 自动刷新 CDN","uri":"/posts/qcloudcdn/"},{"categories":["OS"],"content":"换行符（通常称为行尾、行尾 (EOL)、下一行 (NEL) 或换行符）是字符编码规范（例如，ASCII、EBCDIC）中的控制字符或控制字符序列，用于表示一行文本的结尾和新文本的开头。 周五下班的时候想在 windows 电脑上跑一下 FixIt 看看有没有什么 bug, 然后就发现了 typyit shortcode 开头多出一行空行，mermaid shortcode 则直接语法报错了。 看了一下代码明明有 trim \\n 处理，而且 Vercel 打包和 Mac 上运行打包都没问题。debug 了一下才发现 Windows 系统上的换行是 \\r\\n, 而 Mac 系统上的换行是 \\n。于是查了一下不同系统的换行符的差异问题。 17 历史 简单来说，回车换行这些说法是从打字机那个时代开始叫的，然后在不同的标准下换行符有不同的表现符号。 Windows 系统设计遵循了 CR + LF 的约定，而 Unix 系统则遵循了 LF 的约定，之后的 类 Unix (Linux, macOS) 系统也遵循了 LF 的约定。 当然也有异类，老版的 mac 系统使用 CR 作为换行符。 18 表示 CR 回车：\\r LF 换行：\\n 操作系统 换行符号 Windows \\r\\n Unix、Linux、MacOS \\n classic Mac OS \\r 19 问题 由于这个差异，会导致文本类的文件在跨系统浏览时会产生一些差异，比如说，Mac 的文本文件在 Windows 打开会全部挤在一行等等。 对于开发人员来说，这很有可能导致某些程序失效，比如正则去除空行等等。 甚至因此，Linux 系统下提供有两个命令用来进行 Windows 和 Unix 文件的转化：dos2unix和 unix2dos。 20 参考 Newline ","date":"2022-08-07","objectID":"/posts/newline/:0:0","tags":["newline"],"title":"不同系统的换行符的差异","uri":"/posts/newline/"},{"categories":["Grocery"],"content":"ohmyzsh 自带了很多主题，也有很多没有收录的扩展主题，我就想要个简约的主题，但是每个都差点意思，干脆改一个主题。 1 自定义主题 复制默认主题，当作模板： cd ~/.oh-my-zsh cat themes/robbyrussell.zsh-theme \u003e custom/custom.zsh-theme vim custom/custom.zsh-theme 然后修改里面的内容： if [[ -z $ZSH_THEME_CUSTOM_PREFIX ]]; then ZSH_THEME_CUSTOM_PREFIX=\"\u003e\" fi PROMPT=\"%(?:%{$fg_bold[blue]%}$ZSH_THEME_CUSTOM_PREFIX:%{$fg_bold[red]%}$ZSH_THEME_CUSTOM_PREFIX)\" PROMPT+=' %{$fg[blue]%}%c%{$reset_color%} $(git_prompt_info)' ZSH_THEME_GIT_PROMPT_PREFIX=\"%{$fg_bold[green]%}git:(%{$fg[magenta]%}\" ZSH_THEME_GIT_PROMPT_SUFFIX=\"%{$reset_color%} \" ZSH_THEME_GIT_PROMPT_DIRTY=\"%{$fg[green]%}) %{$fg[yellow]%}✗\" ZSH_THEME_GIT_PROMPT_CLEAN=\"%{$fg[green]%})\" 2 配置 vim ~/.zshrc ZSH_THEME=custom 然后重启终端即可。 ","date":"2022-07-31","objectID":"/posts/ohmyzsh-custom/:0:0","tags":null,"title":"自定义 ohmyzsh 主题","uri":"/posts/ohmyzsh-custom/"},{"categories":["OS"],"content":"记录 linux 系统下文件权限相关的内容，Mac OS 下类似。 13 查看文件权限 查看 linux 系统下的文件权限，可以使用 ll 命令或者 ls 命令 带 -l（长列表选项） ➜ ~ ll total 160 drwx------@ 8 liruihao staff 256B Jul 5 14:47 Applications drwx------@ 10 liruihao staff 320B Jul 27 11:31 Desktop drwx------+ 7 liruihao staff 224B Jun 17 15:01 Documents drwx------@ 22 liruihao staff 704B Jul 29 16:35 Downloads drwx------@ 94 liruihao staff 2.9K Jul 23 19:02 Library drwx------ 4 liruihao staff 128B Nov 13 2021 Movies drwx------+ 6 liruihao staff 192B Nov 18 2021 Music drwx------+ 9 liruihao staff 288B Apr 26 10:25 Pictures drwxr-xr-x+ 5 liruihao staff 160B Nov 14 2021 Public drwxr-xr-x 5 liruihao staff 160B Jul 29 17:48 file-share drwxr-xr-x 3 liruihao staff 96B Jul 26 17:17 node_modules -rw-r--r-- 1 liruihao staff 27B Jun 24 13:47 package-lock.json drwxr-xr-x 20 liruihao staff 640B Jul 29 22:20 workspace -rw-r--r-- 1 liruihao staff 86B Jul 26 17:17 yarn.lock 文件列表信息分为：文件类型、权限、链接数、所属用户、所属用户组、文件大小、最后修改时间、文件名。 14 文件类型 linux 一共有 7 种文件类型，分别如下： -: 普通文件 d: 目录文件 l: 链接文件 b: 块设备文件 p: 管道文件 c: 字符设备文件 s: 套接口文件/数据接口文件 后四种是特殊文件 15 文件权限对应关系 权限 含义 对应数字 r 读权限 4 w 写权限 2 x 执行权限 1 读、写、运行三项权限用数字表示就是 r=4,w=2,x=1。所以，-rw-r--r-- 用数字表示成 644。 权限字段 -rwxrwxrwx 的内容总共会有 10 个 -，第一个表示文件类型，如该文件是文件 (-表示），文件夹 (d 表示）, 连接文件 (l 表示），后面 9 个按照每三位为一组分。 drwxr-xr-x 5 liruihao staff 160B Jul 29 17:48 file-share d: 代表文件夹 rwx: 代表文件所有者 (u 表示）权限，这里是 liruihao，liruihao 对该文件拥有读写执行权限。 r-x: 代表所属（g 表示）的权限，这里同组用户拥有对该文件读和执行的权限。 r-x: 代表其他用户（o 表示）的权限，这里和上面权限一样。 ","date":"2022-07-30","objectID":"/posts/linux-permission/:0:0","tags":["linux","Mac","他山之石"],"title":"linux 文件权限","uri":"/posts/linux-permission/"},{"categories":["Memo"],"content":"记录一下使用 Mac 作为生产工具开发的一些基本配置和经验。 1 配置文件 Mac 上有很多配置文件都可以用来保存环境变量等配置，根据自己的理解记录了四个文件的用途： # etc/profile 系统配置文件 # etc/.bash_profile 系统环境变量配置 # ~/.bash_profile 个人环境变量配置 # ~/.zshrc zsh 的配置文件 # $ZSH_CUSTOM/*.zsh 自定义 zsh 脚本，在 zsh 启动时会自动执行 编辑最多的应该是 ~/.bash_profile 和 ~/.zshrc, 基本上建议所有的个人配置都放在 ~/.bash_profile 中，然后在 ~/.zshrc 最后执行 source ~/.bash_profile, 这样也方便将自己的个人环境变量配置备份。 注意 pnpm setup 会自动在 ~/.zshrc 中添加一些配置，如下： # pnpm export PNPM_HOME=\"/Users/liruihao/Library/pnpm\" case \":$PATH:\" in *\":$PNPM_HOME:\"*) ;; *) export PATH=\"$PNPM_HOME:$PATH\" ;; esac # pnpm end 2 常用命令 # 安装/卸载 homebrew install.sh/uninstall.sh /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" # 注意：安装 Homebrew 会下载 node, 请做好 node 环境被破坏的准备 # 显示隐藏文件 true/false or cmd+shift+. defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder # 释放端口 lsof -i:$your_port # 1. 查看使用端口进程 kill -9 $your_PID # 2. 释放进程 3 Node # 设置阿里镜像 npm config set registry=https://registry.npmmirror.com # npm config set registry https://registry.npmjs.org # GitHub 仓库下载地址前缀镜像 npm config set disturl=https://registry.npmmirror.com/-/binary/ # 全局安装的依赖 npm install -g npm@8.13.1 npm install -g cnpm npm install -g @vue/cli npm install -g nvm npm install -g nrm npm install -g yarn npm install -g yrm # npm 参数 --ignore-scripts # 忽略脚本错误 --force # 会无视冲突，并强制获取远端 npm 库资源，即使本地有资源也会覆盖掉 --legacy-peer-deps # 安装时忽略所有 peerDependencies，忽视依赖冲突，采用 npm 版本 4 到版本 6 的样式去安装依赖，已有的依赖不会覆盖 # 清除缓存 npm cache clean --force rm -rf node_modules rm -rf package-lock.json npm install # nvm nvm alias default [node_version] # 设置默认版本 # 检查过时依赖 npm outdated # 安全更新 npm update # ncu 更新检查工具 # https://blog.51cto.com/u_13028258/5115637?b=totalstatistic npm install -g npm-check-updates ## 检查 ncu ncu vue ## 更新 ncu -u ncu -u vue electron 相关配置 # 设置 electron 镜像仓库 # https://registry.npmmirror.com/-/binary/electron # 13.1.7 版本 下载链接可能会拼错导致 404，要设置成 https://registry.npmmirror.com/-/binary/electron/v npm config set electron_mirror=https://npmmirror.com/mirrors/electron/ 4 SourceTree Custom actions Script target: /bin/bash Parameters: /Users/liruihao/workspace/.shell/sync_tags.sh 技巧 根据不同的 shell 程序选择不同的文件后缀名，并给文件增加可执行权限： zsh: .zsh bash: .sh #! /bin/bash # 同步远程仓库标签分支脚本 git tag -l | xargs git tag -d # git fetch origin --prune # git fetch origin --tags git fetch origin --prune --prune-tags #! /bin/bash # 同步所有子模组 git submodule update --remote --merge #! /bin/zsh # ssh 配置但无法连接时 ssh-agent -s ssh-add ~/.ssh/Lruihao-Github # 私钥路径 技巧 开机启动时系统会去自动读取 id_rsa 的私钥来启动 SSH 链接，若不是默认命令就会失败需要手动执行上诉命令启动，可添加到开机自启动。 SourceTree 相关文章 解决 SourceTree 提交时候 husky 命令失败问题 5 Terminal Terminal: 系统自带 Shell: zsh 美化：ohmyzsh 修改启动语 vim $PREFIX/etc/motd 6 sublime-text 3 # Terminal 启用 sublime 别名 subl ## 1.设置软链（推荐） sudo ln -s \"/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl\" /usr/local/bin/subl ## 2.设置别名 vim ~/.bash_profile alias subl=\"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\" source ~/.bash_profile # 每打开一个命令窗口，需要先让命令生效 7 开机自启动 系统偏好设置 -\u003e 用户与群组 -\u003e 登录项 -\u003e 增删可执行文件 (需配置默认启动软件) 将 shell 命令添加到 /System/Library/StartupItems/ 或 /Library/StartupItems/ 文件夹（测试无效） 8 备份 # ------------------------------------- # This configuration is for Lruihao. # https://lruihao.cn/posts/config4mac/ # ------------------------------------- export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 # workspace export WORKSPACE=\"$HOME/workspace\" # alias alias subl=\"'/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl'\" alias mysql=/usr/local/mysql/bin/mysql alias mysqladmin=/usr/local/mysql/bin/mysqladmin alias incr=\"source $WORKSPACE/.shell/incr*.zsh\" alias typora=\"open -a typora\" # maven export M2_HOME=$HOME/Applications/apache-maven-3.8.5 export PATH=$PATH:$M2_HOME/bin # jenv export PATH=\"$HOME/.jenv/bin:$PATH\" eval \"$(jenv init -)\" # java export JAVA_8_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_321.jdk/Contents/Home export JAVA_17_HOME=/Library/Java/JavaVirtualMachines/jdk-17.0.2.jdk/Contents/Home export JAVA_HOME=$JAVA_8_HOME # 设置一个中间变量，","date":"2022-07-29","objectID":"/posts/config4mac/:0:0","tags":["Git","Mac","Node.js","nvm"],"title":"Mac 上的开发配置总结","uri":"/posts/config4mac/"},{"categories":["GitHub"],"content":"hugo fixit/docs: 📄 The open-source repo for fixit.lruihao.cn","date":"2022-07-23","objectID":"/projects/hugo-fixit/docs/","tags":["documentation","hugo","hugo-blog","hugo-fixit"],"title":"📄 The open-source repo for fixit.lruihao.cn","uri":"/projects/hugo-fixit/docs/"},{"categories":["GitHub"],"content":"FixIt 主题文档 👉 中文 | English FixIt 主题文档主要分为：文档、教程 两大板块，欢迎大家发起 PR 完善主题文档。 系统依赖 Node.js: \u003e= 18.0.0 Go Hugo: \u003e= 0.147.7 (extended version) 贡献文档 首先，点击 fork 按钮 fork 本仓库。 然后，克隆你 fork 的仓库。 git clone https://github.com/hugo-fixit/docs.git fixit-docs \u0026\u0026 cd fixit-docs 接着，安装开发依赖。 npm install 最后，你就可以开始了！ 这里有一些有用的命令。 # 运行带有监听文件变化的本地调试服务器 npm run server # 运行带有监听文件变化的本地调试服务器（生产环境） npm run server:production # 查看编辑主题部分 npm run server:development 参与翻译 包含 missing-translation shortcode 的文档表示该部分尚未翻译，点击查看 缺失翻译的文档。 编辑主题 如果你想做与文档相关的主题更改，最简单的方法是将 fixit-docs 和 FixIt 克隆为兄弟目录，然后运行： HUGO_MODULE_WORKSPACE=hugo.work hugo server --ignoreVendorPaths \"**\" 最后，在 https://github.com/hugo-fixit/docs/pulls 创建一个新的 pull request 来提交你的贡献 🎉 感谢赞助 translate.js 赞助企业级翻译通道。 ","date":"2022-07-23","objectID":"/projects/hugo-fixit/docs/:0:0","tags":["documentation","hugo","hugo-blog","hugo-fixit"],"title":"📄 The open-source repo for fixit.lruihao.cn","uri":"/projects/hugo-fixit/docs/"},{"categories":["Memo"],"content":"作为非安卓专业开发，无需下载 Android SDK， 仅下载 Android SDK 中的 platform-tools 命令行工具即可，并配置好环境变量。 17 安装 platform-tools 18 配置环境变量 open .bash_profile 写入以下内容 # platform-tools of Android SDK export PATH=$PATH:$HOME/Applications/platform-tools source .bash_profile Windows 系统打开高级设置，配置 PATH 变量，增加一条路径即可。 19 ADB 命令 通过 USB 连接手机和电脑，执行以下命令 # 1. 打开手机 tcpip 5555 端口 adb tcpip 5555 # 2. 查看手机网络 IP adb shell ifconfig # 3. 在电脑上 ping 手机网络 IP # 4. adb connect [Android IP] Android 调试桥 (adb) awesome-adb 20 注意 windows 系统下的文件（夹）命名所采用的是 GBK 编码，而 linux 是采用的 UTF-8 编码，使用 adb 的 push 和 pull 命令时由于编码方式的不同会产生错误，因此需要修改 adb 的源代码来支持编码转换。 ","date":"2022-07-05","objectID":"/posts/adb-for-mac/:0:0","tags":["Android","ADB"],"title":"Mac 配置 ADB","uri":"/posts/adb-for-mac/"},{"categories":["JavaScript"],"content":" 前言 前端框架轮替变化越来越快，JavaScript 也在不断地升级迭代，越来越多的新特性让我们的代码写起来变得简洁有趣。 每隔一段时间就该重新认识一下 JS，这篇文章会介绍 6 种新特性，一起研究一下吧。 1 数组方法 some, every, find, filter, map 共同点：这几个方法都不会改变原始数组。 some some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试，它返回一个布尔值。 数组中有至少一个元素通过回调函数的测试就会返回 true，所有元素都没有通过回调函数的测试返回值才会为 false。 arr.some(callback(element[, index[, array]])[, thisArg]) [2, 5, 8, 1, 4].some((x) =\u003e x \u003e 10); // false [12, 5, 8, 1, 4].some((x) =\u003e x \u003e 10); // true 技巧 some() 不会对空数组进行检测，空数组返回 false every 助记：every() 和 some() 功能相反 every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试，它返回一个布尔值。 如果回调函数的每一次返回都为 truthy 值，返回 true ，否则返回 false。 arr.every(callback(element[, index[, array]])[, thisArg]) [12, 5, 8, 130, 44].every((x) =\u003e x \u003e= 10); // false [12, 54, 18, 130, 44].every((x) =\u003e x \u003e= 10); // true 技巧 every() 不会对空数组进行检测，空数组返回 true Find 助记：功能和 some() 类似，some() 返回布尔值，find() 返回找到的元素 find() 方法返回数组中满足提供的测试函数的第一个元素的值，否则返回 undefined。 arr.find(callback[, thisArg]) const array1 = [5, 12, 8, 130, 44]; const found = array1.find((element) =\u003e element \u003e 10); console.log(found); // expected output: 12 引用 另请参见 findIndex() 方法，它返回数组中找到的元素的索引，而不是其值。 如果你需要找到一个元素的位置或者一个元素是否存在于数组中，使用 Array.prototype.indexOf() 或 Array.prototype.includes()。 filter 助记：如字面意思，它是一个筛子，会筛选出满足条件的元素 filter() 方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素。 返回值是一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 var newArray = arr.filter(callback(element[, index[, array]])[, thisArg]) const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present']; const result = words.filter((word) =\u003e word.length \u003e 6); console.log(result); // expected output: Array [\"exuberant\", \"destruction\", \"present\"] map 助记：功能和 filter() 类似，filter() 返回筛选的元素，map() 返回筛选的结果值 map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 返回值是一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg]) const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map((x) =\u003e x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] 2 使用 Object.hasOwn 替代 in 操作符 有时，我们想知道对象上是否存在某个属性，一般会使用 in 操作符或 obj.hasOwnProperty，但它们都有各自的缺陷。 in 如果指定的属性位于对象或其原型链中，in 运算符将返回 true。 const Person = function (age) { this.age = age; }; Person.prototype.name = 'fatfish'; const p1 = new Person(24); console.log('age' in p1); // true console.log('name' in p1); // true 注意这里 obj.hasOwnProperty hasOwnProperty 方法会返回一个布尔值，表示对象自身属性中是否具有对应的值（原型链上的属性不会读取）。 const Person = function (age) { this.age = age; }; Person.prototype.name = 'fatfish'; const p1 = new Person(24); console.log(p1.hasOwnProperty('age')); // true console.log(p1.hasOwnProperty('name')); // fasle 注意这里 obj.hasOwnProperty 已经可以过滤掉原型链上的属性，但在某些情况下，它还是不安全。 Object.create(null).hasOwnProperty('name'); // Uncaught TypeError: Object.create(...).hasOwnProperty is not a function Object.hasOwn 别急，我们可以使用 Object.hasOwn 来避免这两个问题，这比 obj.hasOwnProperty 方法更加方便、安全。 let object = { age: 24 }; Object.hasOwn(object, 'age'); // true let object3 = Object.create(null); Object.hasOwn(object3, 'age'); // false 3 使用 “#” 声明私有属性 以前，我们一般用 _ 表示私有属性，但它并不靠谱，还是会被外部修改。 class Person { constructor(name) { this._money = 1; this.name = name; } get money() { return this._money; } set money(money) { this._money = money; } showMoney() { console.log(this._money); } } const p1 = new Person('fatfish'); console.log(p1.money); // 1 console.log(p1._money); // 1 p1._money = 2; // 依旧可以从外部修改_money 属性，所以这种做法并不安全 console.log(p1.money); // 2 console.log(p1._money); // 2 使用 # 实现真正私有属性 class Person { #money = 1; constructor(name) { this.name = name; } get money() { return this.#money; } set money(money) { this.#money = money; } showMoney() { console.log(this.#money); } } const p1 = new Person('fatfish'); console.log(p1.money); // 1 // p1.#money = 2 // 没法从外部直接修改 p1.money = 2; console.log(p1.money); // 2 console.log(p1.#money); // Uncaught SyntaxError: Private field '#money' must be declared in an enclosing class 4 有用的数字分隔符 可以使用 _ 分隔数字，当然也可以用于计算 // ✅ 更加易于阅读 const newSixBillion = 6000_000_000; // ❌ 难以阅读 con","date":"2022-05-01","objectID":"/posts/js-rediscover/:0:0","tags":["JavaScript","ES6"],"title":"重新认识 JavaScript","uri":"/posts/js-rediscover/"},{"categories":["CSS"],"content":"关于 CSS 和 Scss 变量运算那些事","date":"2022-04-30","objectID":"/posts/css-scss-var/","tags":["CSS","Scss"],"title":"关于 CSS 和 Scss 变量运算那些事","uri":"/posts/css-scss-var/"},{"categories":["CSS"],"content":"1 问题分析 昨天在开发 FixIt 的时候，在 Scss 中写 max(foo, bar) 函数比较不同的单位变量时报错了，但是在 CSS 中使用 max 或者 min 函数函数比较不同的单位变量是没有问题的。 造成这一问题的原因是，在 Scss 中，也实现了 max 和 min 函数，但是在 Scss 中，不同单位的变量是不能进行运算的，所以使得在 Scss 中直接使用 max 或者 min 函数会提示单位不同的报错。（同类 Less 中的变量运算是支持不同单位的） 知道造成问题的原因后，解决这个问题就很简单了，有很多种方法，有些方法感觉像在卡 BUG，有点意思，记录一下。 2 奇技淫巧 由于 Scss 区分大小写而 CSS 不区分，所以为了不让 Scss 中的函数覆盖 CSS 的函数，我们可以使用除了 max 以外的 23 - 1 种写法，这样就能使用原生 CSS 的 max 函数来比较了，就不会报错了。 .foo { padding-left: MAX(10vh, 3.5rem); } 使用 Scss 没有的 CSS 函数 clamp: clamp(MIN, VAL, MAX) 其实就是表示 max(MIN, min(VAL, MAX)) .foo { padding-left: clamp($header-height, 10vh, 10vh); } 使用 unquote($string) 函数让 Scss 删除字符串最前和最后的单引号或双引号 .foo { padding-left: unquote('max(10vh, #{$header-height})'); } 3 By the way 如果需要在 CSS 函数内部恢复 Scss 解析（引用 Scss 变量），只需用 #{...} 包围 Scss 代码。 $header-height: 3.5rem !default; .foo { margin: calc(10vh - $header-height); } 上面的 Scss 将解析成 以下无效的 CSS 代码： .foo { margin: calc(10vh - $header-height); } 用 #{...} 包围 Scss 变量 $header-height: 3.5rem !default; .foo { margin: calc(10vh - #{$header-height}); } ","date":"2022-04-30","objectID":"/posts/css-scss-var/:0:0","tags":["CSS","Scss"],"title":"关于 CSS 和 Scss 变量运算那些事","uri":"/posts/css-scss-var/"},{"categories":["Memo"],"content":" quote Getting Things Done (GTD) is a personal productivity system developed by David Allen and published in a book of the same name. GTD is described as a time management system. Allen states “there is an inverse relationship between things on your mind and those things getting done”. Reference #20 17 理解 简而言之原则就是： 搜集 (Collections Box) 处理 组织 Next actions Projects Waiting for Someday 检查 18 Apple Reminders app 按照以上原则就可以把 Apple 的提醒事项建 5 个大分类， 日常各种想法收集到收集箱， 空闲下来后再组织，分到不同时间点去做， 然后就要自律地去执行处理，做完回顾检查是否都完成。 还可以通过标签更加细分我们的 idea, 配合日历使用让生活学习更高效。 19 Github 收集：选择 repository -\u003e 建 issue 处理：解决并关闭 issue 组织： Labels Projects Milestone Lable Description bug Something isn’t working documentation Improvements or additions to documentation duplicate e or pull request already exists enhancement New feature or request good first issue Good for newcomers help wanted Extra attention is needed invalid This doesn’t seem right priority Something to deal with first question Further information is requested study Self learning plan wontfix This will not be worked on 20 总结 之前在 Foxconn 工作，因为工作电脑、个人电脑、手机可以做到互不干扰，本来想的是把工作、学习 (Free Code) 和 生活 的计划完全分开。 但是换工作后用自己的电脑，工作和 Free Code 就有了交集，换 mac 后，由于苹果生态的原因，不可避免生活计划也加入其中，形成一个三者互相交错的 Venn 图，所以简单分一下： 工作、生活 苹果生态：日历、提醒、备忘录（标签区分） 学习 Github (collection, backup), Blog (summarize) ","date":"2021-12-22","objectID":"/posts/gtd/:0:0","tags":["GTD"],"title":"Getting Things Done for ios App Reminders and Github issues","uri":"/posts/gtd/"},{"categories":["GitHub"],"content":"hugo fixit/FixIt: 🔧 A clean, elegant but advanced blog theme for Hugo 一个简洁、优雅且高效的 Hugo 主题","date":"2021-12-16","objectID":"/projects/hugo-fixit/fixit/","tags":["algolia","blog","giscus","hugo","hugo-blog","hugo-blog-theme","hugo-fixit","hugo-theme","pwa","pwa-app"],"title":"🔧 A clean, elegant but advanced blog theme for Hugo 一个简洁、优雅且高效的 Hugo 主题","uri":"/projects/hugo-fixit/fixit/"},{"categories":["GitHub"],"content":" FixIt 是一个简洁、优雅且高效的 Hugo 博客主题。 如果你喜欢这个主题，别忘了留下一颗 ⭐️ 哦，谢谢！ English | 简体中文 | 繁體中文 | Français | Русский язык | Español | हिन्दी | deutsch | 한국어 | しろうと FixIt 它的原型基于 LoveIt 主题，KeepIt 主题和 LeaveIt 主题。 即时预览 💟 Production | ❇️ Preview | 🚼 Demo | 🆕 Starter 更多 FixIt 的例子参见 这里。 为什么选择 FixIt 我也不知道为什么 🤷。 使用指南 主题文档 前往 快速上手 页面，了解如何使用 FixIt 主题创建一个新网站的详细步骤。 大纲：安装篇 ➜ 入门篇 ➜ 内容管理 ➜ 进阶篇 快速开始 我们提供了一个 CLI 工具，可以通过一个命令来创建一个新的 FixIt 项目。 pnpx fixit-cli create my-blog 模板 点击以下链接使用模板生成一个新的仓库： 模板 仓库 生成链接 基于 Hugo Modules 的快速入门模板。 hugo-fixit-starter 点击生成 基于 Git submodule 的快速入门模板。 hugo-fixit-starter1 点击生成 使用 Fixit 主题构建多语言网站。 docs 点击生成 基于 FixIt 主题进行自定义设置。 Lruihao/hugo-blog 点击生成 特色 点击展开 性能和 SEO 性能优化：在 Google PageSpeed Insights 中，99/100 的移动设备得分和 100/100 的桌面设备得分 使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化 支持 Google Analytics 支持 Fathom Analytics 支持 百度统计 支持 Umami Analytics 支持 Plausible Analytics 支持 Cloudflare Web Analytics 支持 Splitbee Analytics 支持搜索引擎的网站验证 (Google, Bing, Yandex, Pinterest, Baidu, 360 and Sogou) 支持所有第三方库的 CDN 外观和布局 响应式布局 浅色/深色 主题模式 全局一致的设计语言 支持分页 易用和自动展开的文章目录 支持多语言和国际化 美观的 CSS 动画 社交和评论系统 支持 Gravatar 头像 支持本地头像 支持多达 87 种社交链接 支持多达 28 种网站分享 支持 Disqus 评论系统 支持 Gitalk 评论系统 支持 Valine 评论系统 支持 Waline 评论系统 支持 Facebook 评论系统 支持 Telegram comments 评论系统 支持 Commento 评论系统 支持 Utterances 评论系统 支持 Artalk 评论系统 支持 Twikoo 评论系统 支持 giscus 评论系统 扩展功能 支持基于 PostChat 的 AI 摘要、AI 搜索 和 AI 智能客服 支持渐进式网页应用 支持二级菜单 支持内容加密（页面、局部） 支持友情链接的页面模板 支持基于 algolia、Fuse.js、 CSE 或 PostChat 的搜索 支持基于 Google 的自定义搜索引擎 (CSE) 支持 Twemoji 支持代码高亮 一键复制代码到剪贴板 支持基于 lightgallery 的图片画廊 支持 Font Awesome 图标的扩展 Markdown 语法 支持上标注释的扩展 Markdown 语法 支持分数的扩展 Markdown 语法 支持基于 KaTeX 或 MathJax 的数学公式 支持基于 mermaid 的图表 代码块扩展语法和 shortcode 支持基于 ECharts 的交互式数据可视化 代码块扩展语法和 shortcode 支持 Timeline 的代码块扩展语法和 shortcode 支持基于 Mapbox GL JS 的 Mapbox shortcode 支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode 支持 Bilibili 视频 和 抖音视频 shortcode 支持多种注释的 shortcode 支持自定义样式的 shortcode 支持自定义脚本的 shortcode 支持自定义模板块 支持基于 TypeIt 的打字动画 shortcode 支持基于 cookieconsent 的 Cookie 许可横幅 支持基于 cell-watermark 的网页水印 支持基于 pangu.js 的中文排版 支持本地缓存远程图床图片 …… 多语言和国际化 FixIt 主题多语言基本配置及自动翻译等详见 内容管理 文档，欢迎 贡献一种新的语言。 FixIt 支持下列语言。 英语 简体中文 繁体中文 法语 波兰语 巴西葡萄牙语 意大利语 西班牙语 德语 塞尔维亚语 俄语 罗马尼亚语 越南语 印地语 主题组件 FixIt 主题旨在在简洁性和可扩展性之间取得平衡。为此，我们开发了一系列额外的 Hugo 主题组件 供用户选择。 点击展开 fixit-bundle 🌲 Bundles the FixIt core theme and all hugo-fixit components into a single component. cmpt-flyfish 🐟 A canvas implemented animation effect of small fish swimming. cmpt-mdevtools Mobile devtools component powered by vConsole and eruda. cmpt-translate 🌐 A component for site automatic translation. component-projects 🐙 Display your GitHub projects in the FixIt theme and generate blog posts from readme. hugo-atom-feed Hugo theme component for ATOM feed custom Output Format. hugo-json-feed Hugo theme component for JSON feed custom Output Format. shortcode-asciinema A Hugo theme component with asciinema-embed shortcode. shortcode-caniuse A Hugo theme component with caniuse shortcode. shortcode-docs-bookmark 🔖 Embed bookmark of FixIt Docs. shortcode-missing-translation A Hugo theme component with missing-translation shortcode. shortcode-mmt-netease 🎶 A Hugo theme component with a NetEase Cloud random comment shortcode. shortcode-rewards A Hugo theme component with reward-log or sponsor-log shortcode. 社区支持 所有的反馈都是欢迎的！详见 Discussions、Pull requests 和 Issues。 官方社区 说明 Discussions GitHub 讨论区 FixIt 主题交流群（微信） 关注「菠菜眾長」回复“FixIt”获取 FixIt 主题交流群（QQ） QQ 群：814031017 Hugo FixIt 星球 付费知识星球 参与贡献 我们欢迎你加入 FixIt 的开发，贡献出你的一份力量。请看开源 贡献指南。 🤗 你也可以随时向我们的 官方插件 提交 Issue 或 Pull Request。 注意 在贡献时，请先通过此存储库上的讨论来讨论你希望进行的更改，然后再进行实际更改。 致谢 感谢 所有贡献者 的支持！ FixIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css autocomplete-js algoliasearch Fuse.js object-fit-images Twemoji emoji-data lightgallery Sharer.js TypeIt KaTeX MathJax mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent cell-watermark 不蒜子 Vercount pangu.js Artalk Waline Twikoo github-corners giscus crypto-js pace xxhash-wasm FixIt 主题还借鉴了以下项目的部分功能，同样感谢它们的作者： DoIt NexT 许可协议 FixIt 根据","date":"2021-12-16","objectID":"/projects/hugo-fixit/fixit/:0:0","tags":["algolia","blog","giscus","hugo","hugo-blog","hugo-blog-theme","hugo-fixit","hugo-theme","pwa","pwa-app"],"title":"🔧 A clean, elegant but advanced blog theme for Hugo 一个简洁、优雅且高效的 Hugo 主题","uri":"/projects/hugo-fixit/fixit/"},{"categories":["Memo"],"content":" 插件地址 https://github.com/robinchenyu/imagepaste 1 功能 支持 Windows/Linux 系统下，实现对剪切板图像的处理调用 (Ctrl+Shift+V) 默认使用 JPG 的方式保存，可以显著减小图片的存储体积。 对剪切板图像保存到本地并在 Markdown 文本中插入链接地址 对剪切板中的图像地址，直接插入到 Markdown 文本中 2 食用说明 首先下载 zip 到本地，放到 sublime 安装目录的 xxx\\sublime\\Data\\Packages 中，注意不是 xxx\\sublime\\Packages 下哦。 记得要把 subl_imgpaste2-master 的 -master 删除掉。接着重新打开 sublime, 选择 Preferences-\u003ePackage Settings-\u003eImaPaste2-\u003esettings-Default 输入如下内容： { \"caption\": \"ImagePaste: Paste Image From Clipboard\", \"command\": \"image_paste\", \"image_dir_name\": \"images/\" # 图片保存目录 } 然后就可以愉快的使用截图，然后在 sublime 里使用 ctrl+shift+v 粘贴 Markdown 格式的图片。默认会自动根据 md 文件名在同级目录下新建文件夹，图片就默认保存在那。如图： 使用演示 VScode 也有更好用的插件：Past Image \"pasteImage.defaultName\": \"YY_X\", \"pasteImage.path\": \"${currentFileDir}/images/\" ","date":"2021-10-05","objectID":"/posts/subl_imgpaste2/:0:0","tags":["Markdown","Sublime"],"title":"Sublime 剪贴板图片粘贴插件 —— Markdown 必备","uri":"/posts/subl_imgpaste2/"},{"categories":["Memo"],"content":" 卡片式链接已整合到 FixIt 主题 https://github.com/Lruihao/FixIt 回顧 之前在使用 hexo 的時候也有用到，模仿知乎卡片式链接 和之前的相比，優化之前是后加載，由 JS 在 瀏覽器處理， 使用 shortcodes 方式后，則是在 GO 構建頁面的時候處理，效能上會好很多。 1 源碼 基於 LoveIt 主題的 Link Shortcodes, 主要改到以下幾個文件，完整提交記錄 assets/css/custom.scss assets/css/partial/cardlink.scss # 卡片式鏈接樣式 layouts/partials/plugin/cardlink.html # 卡片式鏈接模板 layouts/shortcodes/cardlink.html static/images/card-link-bg.jpg 2 使用 使用參數见 FixIt 擴展 Shortcodes - Link {{\u003c cardlink href=\"https://github.com/Lruihao/hugo-blog/commit/089c303693e806bff855ecf3fee110baa62b870b\" content=\"知乎卡片式链接 Git 記錄\" \u003e}} 💡 注：FixIt 已合併 shortcode cardlink 到 shortcode link，只需添加 card=true {{\u003c link href=\"https://github.com/Lruihao/FixIt\" content=\"卡片式链接已整合到 FixIt 主题\" card=true \u003e}} 信息 我的博客即将同步至腾讯云 + 社区，邀请大家一同入驻： https://cloud.tencent.com/developer/support-plan?invite_code=3o5dmfzf0xkwk ","date":"2021-10-05","objectID":"/posts/hugo-cardlink/:0:0","tags":["hugo","Shortcodes"],"title":"Hugo 添加知乎卡片式链接 Shortcodes","uri":"/posts/hugo-cardlink/"},{"categories":["Memo"],"content":" 工作上一直常用繁體，最近臨帖也都寫的繁體，所以博客的語言也想換成繁體，但是 LoveIt 主題沒有支持中文繁體。就只好自己添加了。 更新说明：FixIt 主题已支持中文繁體。 1 翻譯 屬於直譯，有些詞語可能並不符合現在臺灣或者香港那邊的說法。比如，分類好像臺灣常說歸類吧 新建 i18n/zh-TW.toml # Translations for Traditional Chinese # 繁體中文的翻譯 # https://gohugo.io/content-management/multilingual/#translation-of-strings # === baseof == [backToTop] other = \"回到頂部\" [viewComments] other = \"查看評論\" # === baseof == # === Post === [posts] other = \"文章\" # === Post === # === Taxonomy === [allSome] other = \"所有{{ .Some }}\" [tag] other = \"標籤\" [tags] other = \"標籤\" [category] other = \"分類\" [categories] other = \"分類\" [years] other = \"年度總結\" # === Taxonomy === # === Pagination === [more] other = \"更多\" # === Pagination === # === partials/header.html === [selectLanguage] other = \"選擇語言\" [switchTheme] other = \"切換主題\" # === partials/header.html === # === partials/footer.html === [poweredBySome] other = \"由 {{ .Hugo }} 強力驅動 | 主題 - {{ .Theme }}\" # === partials/footer.html === # === partials/comment.html === [valineLang] other = \"zh-TW\" [valinePlaceholder] other = \"你的評論 ...\" [facebookLanguageCode] other = \"zh-TW\" # === partials/comment.html === # === partials/assets.html === [search] other = \"搜索\" [searchPlaceholder] other = \"搜索文章標題或內容 ...\" [clear] other = \"清空\" [cancel] other = \"取消\" [noResultsFound] other = \"沒有找到結果\" [lunrLanguageCode] other = \"zh\" [lunrLanguageLib] other = \"lib/lunr/lunr.zh.js\" [lunrSegmentitLib] other = \"lib/lunr/lunr.segmentit.js\" [copyToClipboard] other = \"複製到剪貼板\" [cookieconsentMessage] other = \"本網站使用 Cookies 來改善您的流覽體驗。\" [cookieconsentDismiss] other = \"同意\" [cookieconsentLink] other = \"瞭解更多\" # === partials/assets.html === # === partials/plugin/share.html === [shareOn] other = \"分享到\" # === partials/plugin/share.html === # === posts/single.html === [contents] other = \"目錄\" [publishedOnDate] other = \"發佈於 {{ .Date }}\" [includedInCategories] other = \"收錄於 {{ .Categories }}\" [wordCount] other = \"約 {{ .Count }} 字\" [readingTime] other = \"預計閱讀 {{ .Count }} 分鐘\" [views] other = \"次閱讀\" [author] other = \"作者\" [updatedOnDate] other = \"更新於 {{ .Date }}\" [readMarkdown] other = \"閱讀原始文檔\" [back] other = \"返回\" [home] other = \"主頁\" [readMore] other = \"閱讀全文\" # === posts/single.html === # === 404.html === [pageNotFound] other = \"頁面沒找到\" [pageNotFoundText] other = \"抱歉，您要查找的頁面不存在。\" # === 404.html === # === shortcodes/admonition.html === [note] other = \"注意\" [abstract] other = \"摘要\" [info] other = \"信息\" [tip] other = \"技巧\" [success] other = \"成功\" [question] other = \"問題\" [warning] other = \"警告\" [failure] other = \"失敗\" [danger] other = \"危險\" [bug] other = \"Bug\" [example] other = \"示例\" [quote] other = \"引用\" # === shortcodes/admonition.html === # === shortcodes/version.html === [new] other = \"新增\" [changed] other = \"更改\" [deleted] other = \"刪除\" # === shortcodes/version.html === 2 配置 打開 config.toml defaultContentLanguage = \"zh-tw\" ","date":"2021-10-05","objectID":"/posts/hugo-i18n-zh-tw/:0:0","tags":["FixIt","hugo","I18n"],"title":"Hugo I18n 添加中文繁體翻譯","uri":"/posts/hugo-i18n-zh-tw/"},{"categories":["Memo"],"content":" 過程 以前的 hexo 博客是自己寫的友鏈模板，換到 hugo 後想著在網上隨便找一個範本用著就好，然而並沒有自己想要的 layout, 幾乎都是使用 shortcodes 的，代碼風格有點問題且 shortcodes 作為友鏈添加的方式是真的麻煩。就只好自己寫羅。 友情鏈接模板已整合到 FixIt 主題 https://github.com/Lruihao/FixIt 友情鏈接範本 https://lruihao.cn/friends/ 1 創建模板 開始之前去看了 hugo 的官網，再看了一下 go 模板的語法。 新建 layouts/friends/single.html {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- $params := .Scratch.Get \"params\" -}} \u003cdiv class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated pulse faster\"\u003e{{- .Title -}}\u003c/h1\u003e {{- /* Subtitle */ -}} {{- with $params.subtitle -}} \u003ch2 class=\"single-subtitle\"\u003e{{ . }}\u003c/h2\u003e {{- end -}} {{- /* Friend links */ -}} {{- $loading := resources.Get \"svg/loading.svg\" | minify -}} \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003clink rel=\"stylesheet\" href=\"/friends/css/_friends.css\" /\u003e \u003cdiv class=\"friend-links\"\u003e {{ range $index, $friend := .Site.Data.friends }} \u003ca class=\"friend-link\" title=\"{{ $friend.description }}\" href=\"{{ $friend.url | safeURL }}\" rel=\"external nofollow noopener noreferrer\" target=\"_blank\" \u003e {{ if $friend.avatar }} \u003cimg class=\"friend-avatar lazyload\" src=\"{{ $loading.RelPermalink }}\" data-src=\"{{ $friend.avatar }}\" alt=\"{{ $friend.nickname }}\" /\u003e {{ else }} \u003csvg class=\"friend-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{ add 1 $index }}\"\u003e\u003c/use\u003e \u003c/svg\u003e {{ end }} \u003cspan class=\"friend-nickname\" title=\"{{ $friend.nickname }}\"\u003e@{{ $friend.nickname }}\u003c/span\u003e \u003c/a\u003e {{ end }} \u003c/div\u003e {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/div\u003e {{- end -}} 2 模板樣式 新建文件 _friends.css /** * @Description: Style of layout named 'Friend links'. * @Author: lruihao.cn * @Updated: 2021/9/20 19:26 */ .friend-links { margin-top: 1rem; display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; } @media (max-width: 576px) { .friend-links { justify-content: space-around; } } .friend-link { width: 150px; height: 200px; font-size: 1rem; text-align: center; background: rgba(255, 255, 255, 0.3); box-sizing: border-box; box-shadow: 3px 3px 5px #aaa; border-radius: 5px; border: none; transition-duration: 0.3s; margin-bottom: 1rem; display: flex; flex-direction: column; justify-content: space-between; } .friend-link:hover { background: #fff; transform: scale(1.03); box-shadow: 0 0 3px #aaa; } .friend-avatar { object-fit: cover; object-position: center; width: 100% !important; height: 150px !important; border-radius: 5px; margin: 0; padding: 0; } .friend-nickname { display: block; position: relative; color: #2bbc8a; font-weight: bold; max-width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; line-height: 18px; margin-bottom: 1rem; } .friend-nickname:hover { color: #d480aa; } 3 友鏈頁面 hugo new friends/index.md 將 _friends.css 放到 content/friends/css/ 打開友鏈頁面 content/friends/index.md --- title: '友鏈' date: 2021-09-19T12:33:48+08:00 type: 'friends' --- 4 數據 新建數據文件 data/friends.yml, 數據格式為： # - nickname: 标题 # avatar: 头像 # url: 站点 # description: 描述 - nickname: Lruihao avatar: https://gravatar.loli.net/avatar/3f985efb5907ca52944a3cd7edd51606?d=wavatar\u0026v=1.3.10 url: https://lruihao.cn description: 不怕萬人阻擋，只怕自己投降 5 結語 這樣每次添加友鏈或者刪除友鏈衹要操作數據文件 friends.yml 就好，乾淨又衛生！ 友鏈頁面 content/friends/index.md 繼承了基礎頁面的功能，內容評論等 ","date":"2021-10-05","objectID":"/posts/hugo-friends/:0:0","tags":["hugo"],"title":"Hugo 友情連結模板","uri":"/posts/hugo-friends/"},{"categories":["Memo"],"content":"使用 Shell 腳本管理 Hugo 本地博客","date":"2021-10-04","objectID":"/posts/hugo-admin/","tags":["hugo","shell"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo"],"content":" 摘要 在使用 hugo 寫博客的過程中會使用到一些命令，包括 Git 的使用也會用到 Git 命令，但是這些命令我感覺知道就好，沒必要因輸入命令而增加寫博客和部署博客的額外工作。 自然要想辦法簡化這些過程，Git 還好有 SourceTree 等工具，Hugo 卻沒有，也懶得去網絡上找類似以前 hexo 有 hexo-admin 的插件可以讓大家在瀏覽器寫博客，因為我覺得這和靜態博客初衷背道而馳，於是我就折中方案，寫了一個滿足日常需求的 Shell 腳本，生成管理本地博客。 1 實現 一共六個腳本，放在 hugo-site/_localadmin/ 下 _localadmin/ ├── auto_push.sh # 自動化提交源碼 ├── hugo_builder.sh # 構建 hugo 命令 ├── hugo_main.sh # 主介面入口 ├── hugo_server.sh # 啟動本地服務 ├── post_generator.sh # 創建文章 └── public_async.sh # 同步 public 子模組 1.1 post_generator.sh 輸入文章名稱（建議使用英文） 文章是否會插入圖片等資源（默認：否） #!/bin/bash #author: Lruihao cd .. read -p \"Please enter the article name: \" postName if [ -z $postName ];then echo \"The article name is required!\" else read -p \"Will there be pictures in this article? [y/n]...\" choice if [ $choice = \"y\" ];then hugo new posts/$postName/index.md else hugo new posts/$postName.md fi fi 1.2 hugo_server.sh cd .. hugo server --disableFastRender 1.3 hugo_builder.sh cd .. hugo --minify 1.4 public_async.sh cd .. git submodule update --remote git add public git commit -m \"Feat: Update public module commit id\" 1.5 auto_push.sh 不輸入 Git 提交訊息會使用腳本中默認訊息 Docs: 『菠菜眾長』内容更新 YYYY-MM-DD week hh:mm::ss #!/bin/bash #author: Lruihao cd .. # 是否需要每次提交自動更新子模組 # git submodule update --remote # git add public # git commit -m \"Feat: Update public module commit id\" git add . read -p \"Please enter commit message: \" commitMsg if [ -z $commitMsg ];then commitMsg=\"Docs: 『菠菜眾長』内容更新 $(date +'%F %a %T')\" fi git commit -m \"$commitMsg\" git push 1.6 hugo_main.sh 可單獨執行子腳本也可以通過主介面來選擇序號執行 #!/bin/bash #author: Lruihao echo \"Please enter the serial number to work\" echo \"--------------------------------------\" echo \"1. post generator\" echo \"2. hugo server\" echo \"3. hugo build\" echo \"4. public async\" echo \"5. auto push\" echo \"--------------------------------------\" echo \"Press Ctrl+C to stop\" read num case $num in 1) sh post_generator.sh ;; 2) sh hugo_server.sh ;; 3) sh hugo_builder.sh ;; 4) sh public_async.sh ;; 5) sh auto_push.sh ;; *) echo \"There is no such serial number\" ;; esac echo \"Press any key to continue...\" read x clear sh hugo_main.sh 2 使用 將 hugo_main.sh 建立桌面快捷鍵 雙擊 hugo_main.sh 進入根據提示使用即可 由於一般寫博客會便邊寫邊預覽，所以一般開兩個主介面窗口，如下圖： 一個選擇 2 啟動本地服務 一個用於生成文章，部署文章等 Hugo Admin ","date":"2021-10-04","objectID":"/posts/hugo-admin/:0:0","tags":["hugo","shell"],"title":"Hugo 本地管理 Shell 腳本","uri":"/posts/hugo-admin/"},{"categories":["Memo","Git"],"content":" 解決痛點 Github Actions 真是靜態博客的福音，有了它 hugo, hexo 等博客構建過程可以丟給 Github 的服務器幫我們做了。 也就是説實現了在線寫靜態博客的需求。 1 準備 工作流程涉及到兩個倉庫和一個 cos 桶，例如： Lruihao/hugo-blog # Blog source repository Lruihao/lruihao.github.io # GitHub pages repository blog-1256932288 # COS bucket 2 Github Actions 2.1 創建 workflows 任務 創建 hugo-site/.github/workflows/deploy.yml, 這個文件會寫一些命令告訴 Github 在我們提交源碼的時候，它要幫我們做哪些事情。 name: Auto Deploy hugo on: [push] jobs: Explore-GitHub-Actions: runs-on: ubuntu-latest steps: - name: Check out repository code uses: actions/checkout@v2 with: submodules: recursive # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: ${{ vars.HUGO_VERSION || 'latest' }} extended: true - name: Build Hugo static files run: hugo --minify - name: Deploy to Github Pages uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.GP_DEPLOY_KEY }} external_repository: Lruihao/lruihao.github.io publish_branch: main publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} - name: Install coscmd run: sudo pip install coscmd - name: Configure coscmd env: COS_SECRET_ID: ${{ secrets.COS_SECRET_ID }} COS_SECRET_KEY: ${{ secrets.COS_SECRET_KEY }} COS_BUCKET_NAME: blog-1256932288 # Change for yourself COS_BUCKET_REGION: ap-chengdu # Change for yourself run: coscmd config -a $COS_SECRET_ID -s $COS_SECRET_KEY -b $COS_BUCKET_NAME -r $COS_BUCKET_REGION - name: Deploy to COS Bucket run: coscmd upload -r -s --delete -f public/ / 2.2 配置 Github Pages 密鑰 為了讓 Lruihao/hugo-blog 提交代碼后自動部署到 Lruihao/lruihao.github.io, 需要生成一對 ssh key. ssh-keygen -t rsa -b 4096 -C \"$(git config user.email)\" -f gh-pages -N \"\" # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) 打開 Lruihao/hugo-blog 倉庫的 settings, 再点击 Secrets, 然後添加 private key, name 为 GP_DEPLOY_KEY 打開 Lruihao/lruihao.github.io, 点击 Deploy keys, 添加 public key, name 隨意，Allow write access 一定要勾上，否則無法提交 2.3 配置 COS 密鑰 打開 Lruihao/hugo-blog 倉庫的 settings, 再点击 Secrets, 然後添加 COS 桶的 secret_id 和 secret_key: COS_SECRET_ID COS_SECRET_KEY 至此，Github Pages 和 COS 都已經可以通過 Github Actions 自動部署了，有部署記錄后， 打開 Lruihao/hugo-blog -\u003e Actions 可以看到構建過程和結果，構建失敗也會收到 Github 發給你的郵件。 3 COS 自動同步（備用） 本小節內容和 Github Actions 無關，僅作為 COS 備用上傳方式。 COSBrowser 下載 COS 官方軟件 COSBrowser 點開右上角 工具箱 選擇 文件同步 選擇 本地文件夹 eg. hugo-site/public 選擇 存储桶目录 同步类型：單次同步、自動同步、定時同步 同步前先執行 hugo 構建命令，eg. hugo --minify 有 Github actions 選單次同步就好，在 Github 不好用時可用。 ","date":"2021-10-04","objectID":"/posts/github-actions/:0:0","tags":["Git","GitHub Actions","hugo","腾讯云 cos 桶"],"title":"Hugo 使用 GitHub Actions 部署到 GithHb Pages 和 腾讯云 cos 桶","uri":"/posts/github-actions/"},{"categories":["Memo"],"content":" 电脑升级 win 11 后，分盘操作存在 bug, 然后又不小心把装代码的盘格式化了，虽然都有备份到 github, 但是当时为了省事，hexo Node 安装的很多以来插件都没有备份，现在又下载不到了，所以 hexo 博客没办法完整复原，另外，早就觉得基于 Node 的 hexo 实在有些臃肿，且博客内容多了以后部署太慢，就干脆乘机换了好了，经过一段时间寻找，最终选择了基于 Go 的 hugo, 记录一下迁移过程及待办事项。 1 Hugo 准备 1.1 概念 Hugo is a fast and modern static site generator written in Go, and designed to make website creation fun again. 那 hugo 基于编译语言 GO 构建，对于静态页面的构建肯定是碾压 hexo 的存在，其官方标语也是很直白 \"The world’s fastest framework for building websites\", 作为先后使用过 hexo 和 hugo 的我来说，这确实名副其实。 gohugo 1.2 安装 hugo 提供了很多种安装方式，Git, Docker, Binary. 个人电脑使用二进制安装是最方便快捷的，无需安装其他依赖。 到 Hugo Releases 下载对应的 windows 操作系统版本的 Hugo 二进制文件，玩就要玩全的，所以我就选择了扩展版本，此次选择的最新版为 hugo_extended_0.88.1_Windows-64bit.zip, 然后自行解压安装即可。 1.3 生成站点 使用 Hugo 快速生成站点，比如希望生成到 /path/to/site 路径： hugo new site /path/to/site 站点目录结构： ▸ archetypes/ # 配置文章模板，相当于 hexo 的 scaffolds ▸ content/ # 文章页面内容，相当于 hexo 的 source ▸ data/ # 可存放一些 yaml, json, toml 格式的数据 ▸ layouts/ # 页面布局源码，改造主题可不动主题源码 ▸ static/ # 静态文件存放 config.toml # 站点配置文件，相当于 hexo 的 _config.yml 1.4 创建文章 注：路径要写以 content/ 为根目录的相对路径 hugo new path/fileName 1.5 添加主题 添加主题的方式选用 Git 子模组的形式，为了日后快速升级，避免在使用 hexo 中因大量魔改 next 主题而导致难以升级的困扰。 精挑细选最终选择了 LoveIt =\u003e FixIt git init git submodule add https://github.com/Lruihao/FixIt.git themes/FixIt 在 config.toml 添加 theme = “LoveIt” theme = \"FixIt\" 1.6 在本地启动网站 使用以下命令启动网站： hugo serve --disableFastRender 去查看 http://localhost:1313 1.7 hugo build 使用以下命令生成静态文件，然后自己可手动选择部署到 github pages 或 COS 等服务器 hugo --minify 2 写作指北 FixIt 主题文档 - 基本概念 FixIt 主题文档 - 内容 FixIt 主题文档 - 内置 Shortcodes FixIt 主题文档 - 扩展 Shortcodes 3 Todo list 本站源码备份 https://github.com/Lruihao/hugo-blog 原来 hexo 做了大量的美化和扩展功能，迁移到 hugo 想尽可能多的保留。取之精华，去其糟粕。 3.1 Base 迁移 hexo 所有文章内容 迁移 hexo 所有页面内容 留言页面 网友打赏支持页面，整合到留言页面 重写关于页面，一切从简 友情链接页面 重写 404 页面 站点时间和不蒜子计数改到 hello-world 页面 cos-album 和 🍚 饭醉团伙 🍷 整合到博客 cos-album/ #7 (wontfix) 新增 demo/, 以子模组的形式存放前端 demo, serverless 记账本等（保持原本博客的纯粹性） 博客 valine 评论，阅读数迁移，可用 leancloud API 写代码转化（但似乎没必要） 博客 SEO 优化迁移 baidu_urls.txt Github actions 自动部署到 Github pages 和 COS 脚本编写 hugo 本地管理 shell 脚本工具编写 知乎卡片式链接 改成 hugo shortcodes, 取名 cardlink zxm/沐目体 归档 :( #6 安装 沐目体 压缩 沐目体 fontspider 沐目体 post 修订 typyit 配合 随机诗词和网易云热评 API 实时预览功能 base on Vuejs [恋爱叙事体] love 归档 [光] 归档 hugo 内容加密研究 #3 Lruihao/hugo-blog README 撰写，MIT, 发布 1.0.0 版本做完整备份，base on theme version 更换 gravatar 头像 #4 博客在线编辑器研究 github1s 等 #5 [baidu_urls.txt]:↩︎ 生成百度链接集合小技巧，关掉归档分页，在归档页面控制台执行以下代码即可获得所有文章链接 let urls = []; for (let a of document.querySelectorAll('.archive-item a')) { urls.push(a.href); } console.log(urls.join('\\n')); FixIt 主题已支持自动输出 baidu_urls.txt 文件 3.2 Theme FixIt hugo LoveIt 主题整体优化，必要时建 PR 或 issue 到 LoveIt 仓库 (LoveIt 已停更一年多） 先把自己发现和 LoveIt 原 repo 的 issue 尽可能的修复，修改的原则是：不改动原项目代码， 唯一途径就是在站点相同的目录用新增的方式替代修改、删除操作。 之后再等等看作者是否还会更新，如已做大量的更改，再做考虑整合为一个新的主题。 为了更好的完善博客功能以及修复 BUG 已创建新的主题 FixIt (fork from LoveIt) Hugo theme FixIt https://github.com/Lruihao/FixIt 进度更新至 #8 CSS 优化，背景，元素圆角化，外圆内方，居中对齐等 沐目体引入 TOC 序号生成 Fix: 无标题时也会生成目录的 BUG subtitle 等细节优化 Fix: typeit 打印代码时跑版的问题 Fix: 文章 h1 标题多行跑版 Code Review ","date":"2021-10-03","objectID":"/posts/hexo-to-hugo/:0:0","tags":["FixIt","Hexo","hugo"],"title":"个人博客从 Hexo 迁移至 Hugo","uri":"/posts/hexo-to-hugo/"},{"categories":null,"content":"「菠菜眾長」的友情链接","date":"2021-09-19","objectID":"/friends/","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"本页共 - 次阅读 基本信息 网络 ID：Lruihao 头像：https://lruihao.cn/images/avatar.jpg URL：https://lruihao.cn 描述：菠菜眾長 - 「不怕萬人阻擋，只怕自己投降」（或者你对我的看法😉） 友链要求 友情提醒：那些不尊重他人劳动成果，转载不加出处的，或恶意行为的网站，还请你不要来进行交换了。 原创博客文章至少 10 篇以上，内容健康，无违法违规内容。 网站创建时间至少 3 个月以上，且长期保持更新。（频率至少一年 1 篇） 目前仅限个人非商业博客/网站。（商务合作邮件联系） 满足上述基本要求，互换友链请按以下格式在评论区留言： ```yaml - nickname: \u003cyour nickname\u003e avatar: \u003cyour avatar\u003e url: \u003cyour site link\u003e description: \u003cdescription of your site\u003e ``` 失效链接 公示一个月后删除，如更换域名请及时联系！ ","date":"2021-09-19","objectID":"/friends/:0:0","tags":null,"title":"友情链接","uri":"/friends/"},{"categories":null,"content":"互联网的广大朋友们，欢迎光临我的小博客！欢迎留言！","date":"2021-09-13","objectID":"/guestbook/","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":null,"content":"- 次阅读 Welcome 互联网的广大朋友们，欢迎光临我的小博客！欢迎留言！ 温馨提示，音乐自动播放，请带好耳机～ From playlist, Powered by mmt-netease. 给博主买杯卡布奇诺～ 赞赏 支付宝 微信 - 次阅读 ","date":"2021-09-13","objectID":"/guestbook/:0:0","tags":null,"title":"留言","uri":"/guestbook/"},{"categories":["GitHub"],"content":"Lruihao/hugo blog: Lruihao's Note","date":"2021-09-08","objectID":"/projects/lruihao/hugo-blog/","tags":["blog","front-end","hugo","hugo-blog","hugo-fixit","hugo-site"],"title":"Lruihao's Note","uri":"/projects/lruihao/hugo-blog/"},{"categories":["GitHub"],"content":"菠菜眾長 站名“菠菜眾長”，取“兼收並蓄，博採眾長”之意。 Content 博客内容主要以 Web 前端开发方向为主，分享一些有趣程序、技巧、开发教程、心情和学习记录等。 以内容为中心，搭建了智能笔记知识库，支持 AI 搜索、AI 对话、智能摘要等功能，点击左下角 🤖 图标 立即体验。 归档 分类 合集 标签 提示 你可以通过我的微信公众号、GitHub 或 RSS 来订阅本博客。 Source 博客中涉及的相关源码： HTML/CSS/JS Demo Vue2 Demo Hugo FixIt CoverView Vercel API Proxy MMT webfont package 更多 Roadmap Project setup 本博客已部署到 Vercel 和 GitHub Pages，工作流如下图所示： ▸ .github/ # GitHub configuration ▸ .scripts/ # custom scripts ▸ .shell/ # shell commands for hugo project, entrance: hugo_main.sh ▸ archetypes/ # page archetypes (like scaffolds of archetypes) ▸ assets/ # css, js, third-party libraries etc. ▸ config/ # configuration files ▸ content/ # markdown files for hugo project ▸ private/ # private submodule for encrypted content ▸ data/ # blog data (allow: yaml, json, toml), e.g. friends.yml ▸ public/ # build directory ▸ static/ # static files, e.g. favicon.ico ▸ themes/ # theme submodules System requirements Node.js: \u003e= 18.0.0 Go Hugo: \u003e= 0.146.0 (extended version) Clone 首先点上 Star 😜，然后下载源码： git clone --recursive git@github.com:Lruihao/hugo-blog.git \u0026\u0026 cd hugo-blog 下载源码后，有两种方法可以启动这个博客。 NPM npm install # build the blog npm run build # run a local debugging server with watch npm run server # run a local debugging server in production environment npm run server:production # update theme submodules npm run update:theme 如果没有全局安装 Hugo，甚至可以通过 hugo-bin 在 Node.js 环境下使用 Hugo。 参考：hugo-bin npm install hugo-bin --save-dev package.json 需配置 extended 版本： { ... \"hugo-bin\": { \"buildTags\": \"extended\" } } 再通过 npx hugo 启动。 Hugo # Development environment hugo server --disableFastRender --navigateToChanged --bind 0.0.0.0 # Production environment hugo server --disableFastRender --navigateToChanged --environment production --bind 0.0.0.0 此外，还可以运行 shell 脚本来选择常用的 Hugo 命令。 cd .shell \u0026\u0026 sh hugo_main.sh --------------Hugo Admin-------------- Please enter the serial number to work -------------------------------------- 1. post 2. server 3. server:production 4. build 5. submodule-sync 6. push -------------------------------------- Press Ctrl+C to stop License 此存储库中的文本、图像和视频等内容采用 CC BY-NC-SA 4.0 许可 此存储库中的代码采用 MIT 许可 content/private 目录不在任何许可范围内 Sponsor 赞赏记录，感谢大家的支持！❤️ 长期赞助致谢： translate.js 赞助企业级翻译通道。 Powered 博客基于 Hugo 和 FixIt 搭建，建站的初衷不是为了炫耀所知，而是记录无知。 Author Lruihao ","date":"2021-09-08","objectID":"/projects/lruihao/hugo-blog/:0:0","tags":["blog","front-end","hugo","hugo-blog","hugo-fixit","hugo-site"],"title":"Lruihao's Note","uri":"/projects/lruihao/hugo-blog/"},{"categories":null,"content":" 不卑不亢，不矜不伐，戒骄戒躁 不嗔不怒，不争不弃，独善其身 —— 自我期许 关于作者 人知道的越多，就会发现无知的越多。有更广袤的世界可以探索，真是莫大的快乐！ 喜欢瞎折腾、造轮子、写东西，分享一些前端开发中的所见、所闻、所思。 👨‍💻 一名前端开发工程师 🫶 Hugo FixIt 作者 📚 专业：计算机科学与技术  关注 Follow：Lruihao  微信公众号：菠菜眾長 关于博客 博客内容主要以前端开发方向为主，分享一些有趣程序、技巧、开发教程、心情和学习记录等。 你可以通过我的微信公众号、GitHub 或 RSS 来订阅本博客。 /** * 菠菜眾長，取“兼收並蓄，博採眾長”之意。 * Licensed under CC BY-NC-SA 4.0 * @since 2018-05-28 20:01:01 */ class Blog { constructor(name, author, url) { this.name = name; this.author = author; this.url = url; } } // 建站的初衷不是为了炫耀所知，而是记录无知。 const site = new Blog('菠菜眾長', 'Lruihao', 'https://lruihao.cn'); 博客历史 部署从 GitHub Pages 迁移至 Vercel。 2023-05-01 17:13:51大学毕业后，出湖南工作。网警打电话告知我迁移备案，我觉得麻烦就注销了，同时部署从腾讯云 COS 桶迁移至 GitHub Pages。 2023-02-14 18:00:40LoveIt =\u003e FixIt LoveIt 长期停更，博客主题改为 FixIt，并自行开发维护。 2021-12-18 16:15:22博客迁移至 Hugo，使用 LoveIt 主题，重新出发。 2021-09-08 20:53:21升级 Windows 11，系统更新出现故障，整理磁盘时不小心把代码全删除了，无备份，GitHub 仅备份了 Markdown 源码。博客开始停止运行。 2021-08-19 22:48:06博客名称“博採眾長”改为“菠菜眾長”，因为网站备案不能使用成语。 这个时候博客内容开始转向前端开发了。部署在腾讯云 COS 桶，速度嘎嘎快。 2019-12-06 21:04:01基于 Hexo + NexT 主题搭建博客，博客取名为“博採眾長”，取“兼收並蓄，博採眾長”之意。 当时还在打 ACM，博客内容也主要是记录题解。 2018-05-28 20:01:01 有偿帮助 前后端开发需求可以联系我，暂定价格 50～100 元/小时，具体详聊。 （其他类型开发也可以咨询） 商务合作 广告投放、其他平台同步授权等事宜请邮件与我联系。 📮 邮箱：1024@lruihao.cn（备注来意） 已授权平台：云 + 社区 进入PGgyIGNb5fbcbd56537bce1ee1174c5e0fe69e3a75437f9867b76600ad802dffsYXNzPSJoZWFkaW5nLWVsZW1lbnQiIGlkPSLmlbDmja7liIbmnpAiPjxzcGFuPuaVsOaNruWIhuaekDwvc3Bhbj4KICA8YSBocmVmPSIjJWU2JTk1JWIwJWU2JThkJWFlJWU1JTg4JTg2JWU2JTllJTkwIiBjbGFzcz0iaGVhZGluZy1tYXJrIj4KICAgIDxzdmcgY2xhc3M9Im9jdGljb24gb2N0aWNvbi1saW5rIiB2aWV3Qm94PSIwIDAgMTYgMTYiIHZlcnNpb249IjEuMSIgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBhcmlhLWhpZGRlbj0idHJ1ZSI+PHBhdGggZD0ibTcuNzc1IDMuMjc1IDEuMjUtMS4yNWEzLjUgMy41IDAgMSAxIDQuOTUgNC45NWwtMi41IDIuNWEzLjUgMy41IDAgMCAxLTQuOTUgMCAuNzUxLjc1MSAwIDAgMSAuMDE4LTEuMDQyLjc1MS43NTEgMCAwIDEgMS4wNDItLjAxOCAxLjk5OCAxLjk5OCAwIDAgMCAyLjgzIDBsMi41LTIuNWEyLjAwMiAyLjAwMiAwIDAgMC0yLjgzLTIuODNsLTEuMjUgMS4yNWEuNzUxLjc1MSAwIDAgMS0xLjA0Mi0uMDE4Ljc1MS43NTEgMCAwIDEtLjAxOC0xLjA0MlptLTQuNjkgOS42NGExLjk5OCAxLjk5OCAwIDAgMCAyLjgzIDBsMS4yNS0xLjI1YS43NTEuNzUxIDAgMCAxIDEuMDQyLjAxOC43NTEuNzUxIDAgMCAxIC4wMTggMS4wNDJsLTEuMjUgMS4yNWEzLjUgMy41IDAgMSAxLTQuOTUtNC45NWwyLjUtMi41YTMuNSAzLjUgMCAwIDEgNC45NSAwIC43NTEuNzUxIDAgMCAxLS4wMTggMS4wNDIuNzUxLjc1MSAwIDAgMS0xLjA0Mi4wMTggMS45OTggMS45OTggMCAwIDAtMi44MyAwbC0yLjUgMi41YTEuOTk4IDEuOTk4IDAgMCAwIDAgMi44M1oiPjwvcGF0aD48L3N2Zz4KICA8L2E+CjwvaDI+PHVsPgo8bGk+PGEgaHJlZj0iaHR0cHM6Ly91cy51bWFtaS5pcy9zaGFyZS9GU1B3bTFJc3JRRlk3WnZQL2xydWloYW8uY24idGFyZ2V0PSJfYmxhbmsiIHJlbD0iZXh0ZXJuYWwgbm9mb2xsb3cgbm9vcGVuZXIgbm9yZWZlcnJlciI+VW1hbWk8aSBjbGFzcz0iZmEtc29saWQgZmEtZXh0ZXJuYWwtbGluay1hbHQgZmEtZncgZmEteHMgbXMtMSB0ZXh0LXNlY29uZGFyeSIgYXJpYS1oaWRkZW49InRydWUiPjwvaT48L2E+PC9saT4KPGxpPjxhIGhyZWY9Imh0dHBzOi8vdmVyY291bnQub25lL2Rhc2hib2FyZC9hbmFseXRpY3M/ZG9tYWluPWxydWloYW8uY24idGFyZ2V0PSJfYmxhbmsiIHJlbD0iZXh0ZXJuYWwgbm9mb2xsb3cgbm9vcGVuZXIgbm9yZWZlcnJlciI+VmVyY291bnQ8aSBjbGFzcz0iZmEtc29saWQgZmEtZXh0ZXJuYWwtbGluay1hbHQgZmEtZncgZmEteHMgbXMtMSB0ZXh0LXNlY29uZGFyeSIgYXJpYS1oaWRkZW49InRydWUiPjwvaT48L2E+PC9saT4KPC91bD4K - 次阅读 ","date":"2021-09-07","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["CSS"],"content":" Sass 和 Less 都屬於 CSS 前置處理器，CSS 前置處理器定義了一種新的語言，其基本思想是，用一種專門的程式設計語言，為 CSS 增加了一些程式設計的特性，將 CSS 作為目標生成檔，然後開發者就只要使用這種語言進行 CSS 的編碼工作。 轉化成通俗易懂的話來說就是 “用一種專門的程式設計語言，進行 Web 頁面樣式設計，再通過編譯器轉化為正常的 CSS 檔，以供專案使用”。 1 為什麼，什麼時候要使用 CSS 前置處理器？ (Why, When) CSS 有具體以下幾個缺點： 語法不夠強大，比如無法嵌套書寫，導致模組化開發中需要書寫很多重複的選擇器 沒有變數和合理的樣式複用機制，使得邏輯上相關的屬性值必須以字面量的形式重複輸出，導致難以維護 這就導致了我們在工作中無端增加了許多工作量。而使用 CSS 前置處理器可大大提高了我們的開發效率： 提供 CSS 缺失的樣式層複用機制 減少冗餘碼 提高樣式代碼的可維護性。 但是，CSS 的好處在於簡便、隨時隨地被使用和調試。這就使得預編譯 CSS 步驟的加入具有以下缺點： 開發工作流中多了一個環節，調試也變得更麻煩 預編譯很容易造成後代選擇器的濫用 所以我們在實際項目中衡量預編譯方案時，還是得想想，比起帶來的額外維護開銷，CSS 前置處理器有沒有解決更大的麻煩。 系統級框架開發（大型複雜的樣式設計） 持續維護 2 Less、Sass/Scss 是什麼？ (What) 2.1 Less 是一種動態樣式語言。對 CSS 賦予了動態語言的特性，如變數、繼承、運算、函數。 Less 既可以在用戶端上運行（支援 IE 6+, Webkit, Firefox)，也可在服務端運行。 2.2 Sass 是一種動態樣式語言，Sass 語法屬於縮排語法， 比 CSS 比多出好些功能（如變數、嵌套、運算，混入 (Mixin)、繼承、顏色處理，函數等），更容易閱讀。 2.3 Sass 與 Scss 的關係 Sass 的縮排語法，對於寫慣 CSS 的前端開發者來說很不直觀，也不能將 CSS 代碼加入到 Sass 裡面，因此 Sass 語法進行了改良，Sass 3 就變成了 Scss(Sassy CSS)。與原來的語法相容，只是用{}取代了原來的縮進。Sass 相當於 Scss 的嚴格模式。 3 Sass 和 Less 的比較 3.1 相同點 Less 和 Sass 在語法上有些共性，比如下面這些： 混入 (Mixins)——class 中的 class 參數混入——可以傳遞參數的 class，就像函數一樣 嵌套規則——Class 中嵌套 class，從而減少重複的代碼 運算——CSS 中用上數學 顏色功能——可以編輯顏色 名字空間 (namespace)——分組樣式，從而可以被調用 作用域——局部修改樣式 JavaScript 賦值——在 CSS 中使用 JavaScript 運算式賦值 3.2 不同點 實現方式 Less 是基於 JavaScript，是在用戶端處理的 Sass 是基於 Ruby 的，是在伺服器端處理的 關於變數在 Less 和 Sass 中的唯一區別就是 Less 用@，Sass 用$ less 中的變量運算可帶、可不帶單位，Sass 需要帶單位元 語法不同，請詳見 Less、Sass 官網 4 選用 Less 還是 Sass ? 無論是學習資料，討論情況，以及項目使用情況 Sass/Scss 都優於 Less，比如 Bootstrap 4 就使用的 Sass, 但是 Less 的使用更加簡單，使用門檻也較低，內網開發的情況，Less 則更加適合。 ","date":"2021-06-22","objectID":"/posts/less-sass-scss/:0:0","tags":["Less","Sass","Scss"],"title":"less\u0026sass\u0026scss","uri":"/posts/less-sass-scss/"},{"categories":["JavaScript"],"content":"1 簡介 Lightbox（燈箱），用来放大显示图片覆盖于当前页面之上。其是用 CSS 来定义图片容器，用一幅半透明的 png 图片实现渐变阴暗的效果。 一般的網頁，圖片是使用 img 標籤寫在 HTML 頁面中，圖片點擊并不會放大，想放大看圖片要麼方法整個網頁，要麼複製圖片鏈接新開窗口，操作繁瑣，而使用 Lightbox 的網站可以点击缩略图浮层显示大图，放大後可点击键盘 ←、→ 键切换图片，也可以鼠标点击左右箭头切换。按下键盘 Esc 键或者点击关闭按钮可輕鬆關閉圖層，圖片流覽的體驗度是遠遠大於未使用的 Lightbox 的網站。 2 實現思路 大概思路就在每个图片的点击事件中添加图层与图片副本。 /** * @author github.com@flymysql */ let container = document.documentElement || document.body; let img, div, src, btnleft, btnright; var imgid = 0; let x, y, w, h, tx, ty, tw, th, ww, wh; let closeMove = function () { if (div == undefined) { return false; } div.style.opacity = 0; img.style.height = h + 'px'; img.style.width = w + 'px'; img.style.left = x + 'px'; img.style.top = y - container.scrollTop + 'px'; // 延迟移除 dom setTimeout(function () { div.remove(); img.remove(); btnright.remove(); btnleft.remove(); }, 100); }; let closeFade = function () { if (div == undefined) { return false; } div.style.opacity = 0; img.style.opacity = 0; // 延迟移除 dom setTimeout(function () { div.remove(); img.remove(); btnright.remove(); btnleft.remove(); }, 100); }; let style = function () { btnleft.style.cssText = ` position:fixed; border-radius: 50%;; left:${x - 20}px; top:${y - container.scrollTop + h / 2}px; width:50px; height:50px; border: 0px; background-color: rgba(200,200,200,0.8); font-size: 20px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnright.style.cssText = ` position:fixed; border-radius: 50%; left:${x + w + 20}px; top:${y - container.scrollTop + h / 2}px; width:50px; border: 0px; height:50px; font-size: 20px; background-color: rgba(200,200,200,0.8); z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; btnleft.innerText = '\u003c'; btnright.innerText = '\u003e'; img.style.cssText = ` position:fixed; border-radius: 12px; left:${x}px; top:${y - container.scrollTop}px; width:${w}px; height:${h}px; z-index: 999999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); opacity:0; `; }; // 监听滚动关闭层 document.addEventListener('scroll', function () { closeFade(); }); document.querySelectorAll('img').forEach((v) =\u003e { if (v.parentNode.localName != 'a') { v.id = imgid; imgid++; v.addEventListener('click', function (e) { // 注册事件 // 记录小图的位置个大小 x = e.target.offsetLeft; y = e.target.offsetTop; w = e.target.offsetWidth; h = e.target.offsetHeight; src = e.target.src; id = e.target.id; // 创建遮罩层 div = document.createElement('div'); div.style.cssText = ` position:fixed; left:0; top:0; bottom:0; right:0; background-color: rgba(25,25,25,0.8); z-index:99999999; transition:all .3s cubic-bezier(0.165, 0.84, 0.44, 1); `; document.body.appendChild(div); setTimeout(function () { div.style.opacity = 1; }, 0); // （此处可以加 loading) // 创建副本 img = new Image(); btnright = document.createElement('button'); btnleft = document.createElement('button'); img.src = src; style(); btnleft.onclick = function () { if (id === 0) { alert('已经是第一张了！'); return; } var left = document.getElementById(id - 1); img.src = left.src; x = left.offsetLeft; y = left.offsetTop; w = left.offsetWidth; h = left.offsetHeight; style(); id--; }; btnright.onclick = function () { id++; if (id \u003e= imgid) { alert('已经是最后一张了！'); return; } var right = document.getElementById(id); img.src = right.src; x = right.offsetLeft; y = right.offsetTop; w = right.offsetWidth; h = right.offsetHeight; style(); }; img.onload = function () { document.body.appendChild(img); document.body.appendChild(btnright); document.body.appendChild(btnleft); // 浏览器宽高 wh = window.innerHeight; ww = window.innerWidth; // 目标宽高和坐标 if (w / h \u003c ww / wh) { th = wh - 80; tw = ((w / h) * th) \u003e\u003e 0; tx = (ww - tw) / 2; ty = 40; } else { tw = ww * 0.8; th = ((h / w) * tw) \u003e\u003e 0; tx = ww * 0.1; ty = (wh - th) / 2; } // 延迟写入否则不会有动画 setTimeout(function () { img.style.opacity = 1; img.style.height = th + 'px'; img.style.width = tw + 'px'; img.style.left = tx + 'px'; img.style.top = ty + 'px'; btnleft.style.left = tx - 90 + 'px'; btnleft.style.top = ty + th / 2 + 'px'; btnright.style.left = tx + tw + 4","date":"2021-06-21","objectID":"/posts/lightbox/:0:0","tags":["Lightbox","JavaScript"],"title":"Lightbox","uri":"/posts/lightbox/"},{"categories":["GitHub"],"content":"Lruihao/watermark: Create watermark for webpage and automatic adjust when window resize.","date":"2021-05-24","objectID":"/projects/lruihao/watermark/","tags":["cell-watermark","watermark"],"title":"Create watermark for webpage and automatic adjust when window resize.","uri":"/projects/lruihao/watermark/"},{"categories":["GitHub"],"content":"Watermark Create watermark for webpage and automatic adjust when windows resize. Documentation Usage Browser Clone source git clone git@github.com:Lruihao/watermark.git Load Watermark \u003cscript type=\"text/javascript\" src=\"./src/watermark.js\"\u003e\u003c/script\u003e \u003c!-- Or CDN --\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/cell-watermark\"\u003e\u003c/script\u003e Initialization document.addEventListener('DOMContentLoaded', function () { new Watermark({ content: \"cell-watermark\" }) }); NPM Install npm i cell-watermark Import import Watermark from 'cell-watermark' /* Or */ var Watermark = require(\"cell-watermark\") ","date":"2021-05-24","objectID":"/projects/lruihao/watermark/:0:0","tags":["cell-watermark","watermark"],"title":"Create watermark for webpage and automatic adjust when window resize.","uri":"/projects/lruihao/watermark/"},{"categories":["JavaScript"],"content":" Usage Browser Clone source git clone git@github.com:Lruihao/watermark.git Load Watermark \u003cscript type=\"text/javascript\" src=\"./src/watermark.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"./src/watermark.min.js\"\u003e\u003c/script\u003e \u003c!-- Or CDN --\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/cell-watermark@1.0.3/src/watermark.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.jsdelivr.net/npm/cell-watermark@1.0.3/src/watermark.min.js\"\u003e\u003c/script\u003e Initialization document.addEventListener('DOMContentLoaded', function () { new Watermark({ content: \"cell-watermark\" }) }); NPM Install npm i cell-watermark Import import Watermark from 'cell-watermark' /* Or */ var Watermark = require(\"cell-watermark\") Class: Watermark Watermark(options) new Watermark(options) Parameters Name Type Description options Object The options of watermark（Properties） Properties Name Type Attributes Default Description content String \u003coptional\u003e watermark’s text appendTo String \u003coptional\u003e ‘body’ parent of watermark’s container width Number \u003coptional\u003e 150 watermark’s width. unit: px height Number \u003coptional\u003e 20 watermark’s height. unit: px rowSpacing Number \u003coptional\u003e 60 row spacing of watermarks. unit: px colSpacing Number \u003coptional\u003e 30 col spacing of watermarks. unit: px rotate Number \u003coptional\u003e 15 watermark’s tangent angle. unit: deg opacity Number \u003coptional\u003e 0.1 watermark’s transparency fontSize Number \u003coptional\u003e 0.85 watermark’s fontSize. unit: rem fontFamily String \u003coptional\u003e ‘inherit’ watermark’s fontFamily Author: Lruihao Methods upload(content) Upload watermark’s text content Parameters Name Type Description content String watermark’s text render(options) Rerender watermark Parameters Name Type Description options Object The options of watermark（Properties） destroy() Force destroy watermark ","date":"2021-05-23","objectID":"/projects/cell-watermark/:0:0","tags":["watermark","JavaScript"],"title":"Cell Watermark","uri":"/projects/cell-watermark/"},{"categories":["Memo"],"content":"1 程式碼的持續優化 對一個入門的工程師來說，掌握程式語法與模仿範例實作是基本的能力。那有了這樣的基本能之後，要如何寫出更好的程式呢？怎樣才能夠成為一個「優秀」的新手工程師呢？事實上，寫出會動的程式不難，但想寫出好的程式其實是需要刻意練習的。大部分的人會建議要「多練習、多實作」，但我認為在大量練習之外，適時的「優化程式」也是提升「程式碼品質」重要的關鍵。而在「優化程式」可以分成兩個角度： 程式執行效能更好 程式碼結構更精簡 程式執行效能就是從速度跟空間來思考，執行時間越短、變數佔用空間越小。而程式碼結構則會從可讀性和精簡來衡量，例如：變數的命名有沒有意義、程式碼有沒有冗余、繁瑣的部分等等。只不過新手很容易停留在寫出程式的喜悅以及受到固有的解題思考，而忽略優化的過程。 透過「Code Review」是推薦新手的方法，經由反饋與討論來找出程式中可優化的空間。 2 Code Review 的關注點 以我自己的經驗來說，Review 一份專案的時候會關注： 程式能不能正常操作，有没有什么明显的错误？（低標） 程式碼當中有沒有奇怪的地方？（優化） 第一個關注點是程式碼的低標，結果正確與可正常運行一定是最重要的。如果程式無法運行動或存在很明顯的問題，那再多的優化都沒有意義。除了確保執行之外，同時也會檢查一下是否有低級的邏輯失誤或是安全性的疑慮，像是資料庫沒有正確關閉或密碼明碼沒有加密之類的問題。 第二個關注點是「程式碼品質提升」的部分，我會把它定義成程式運作上沒有問題，但看起來很不舒服或執行效率很差的部分。大致上可以從以下幾點下手： 命名有沒有意義/不一致 資料庫的正規化情況 是否存在特別複雜的程式片段（例如多次的資料庫查詢、多層的迴圈使用） 重複的程式碼有沒有定義成 function 冗長的程式碼能不能拆分成 function 不過一次的 Code Review 建議著重在 3 - 5 個優化地方，比較容易聚焦在優化的品質。根據時程的壓力，決定 Code Review 迭代的次數。 3 從架構的規劃到細節的優化 在拿到一份程式碼時，通常會先掃過一眼程式的檔案結構，是否有不該上傳的檔案或缺漏。 以這個例子來說，第一眼會覺得檔案配置蠻結構化的。但再多看一點會發現存在幾個冗餘的檔案，例如：-filesqqqq、diff，甚至 /icon 資料夾也不該放在最上層。 進入程式的第一步先從 package.json 檔案開始，確認一下專案的基本資訊是否完整、使用到的套件與版本，以及程式的進入點是什麼。然後打開進入點的檔案（通常會命名成 app 或 main），通常有幾個點需要注意：「套件的載入順序」會建議從第三方套件 → 自定義的模組 → 程式內的變數這樣順序定義；「善用 MVC 的架構」將非主程式的部分依照功能拆分模組，避免檔案資訊量太雜亂。接著就會從 Router → Controller → Service → View 的流程一個一個功能，以下分享一些存在優化空間的程式碼： 善用工具，已有的工具，不用自己手刻 變數名稱不建議用大寫開頭（通常是用在 Class 的命名） 保持優化的空間與彈性 「優化其實是一種取捨」，不需要也不應該追求一步到位。開發往往都是在品質跟產出做取捨，初期可以把開發目標放在「先求可以動，再求持續優化」的節奏上。新手需要在意的點有幾下兩點： 很容易把重點全部放在程式碼的產出上而忽略的程式碼的品質。 停留在做出成果的喜悅，而停滯了優化的步調。 因此，會建議在開發當下就「多想」兩秒鐘，感覺可優化但來不及的部分先在旁邊加個註解提醒自己。另外也養成一段時間回頭看之前的程式碼的習慣，試著刻意找出可以優化改進的部分。專案的提交可能會有期限，但程式碼的優化沒有盡頭。面對相同的專案與程式碼，唯有透過不停的迭代優化才能打造更好的程式，同時也見證了你和程式一起變得更好的過程。所以建立逐步優化的空間，養成持續提升程式碼品質的習慣，才是一個新手工程師需要修煉的心法。 ","date":"2021-03-04","objectID":"/posts/codereview/:0:0","tags":["codereview"],"title":"Code Review 怎麼做？新手工程師如何提升「程式碼品質」","uri":"/posts/codereview/"},{"categories":["瞎折腾"],"content":"17 起因 起因 事情是這樣，年前和朋友一起合租了一個房子，然後捏，生活嘛，除了開心，當然是乾飯最大啦！ 自然就會有購物，買菜等日常消費，那就要記賬，一開始是各自記在手機的便簽上，最後再算一下； 三個人，一共七种組合消費，排除各自消費的三種情況，也有四種 (AB, AC, BC, ABC)。好麻煩啊！！！ 18 經過 作為一個程序猿，怎麼能接受這麼麻煩的記賬方式呢，拿起筆就開始畫，於是有了下面這張圖的公式。簡單說明一下就是： 設前面說的四種組合為：X1, X2, X3, X4，個人實際付款總額為：Y1, Y2, Y3，那麼帶入未知數，我們就可以算出每個人最後結算時的錢：S1, S2, S3， 綜上所述，很好理解，當 S \u003e= 0 時，收紅包，當 S \u003c 0 時，發紅包。 OK，一個簡單的初中方程式已經到位了，下一步，思考一下，用什麼來運作這個這個方程。來，先跑個題，春節期間，不是每天都要在騰訊文檔上填表記錄活動軌跡嗎？再回來，那不如就用 excel 實現吧，三個人都可以在手機上編輯。好的，說做就做。 一頓操作，10 minutes later… 只新建了一個 excel 文件，O.o! 不會 excel，果斷放棄，另尋他路。 19 結果 回到本職，那不如寫個網站吧，可是畢業後，學生機服務器也過期了，怎麼搞？那就寫個純前端的，數據呢存哪裡？ 別急，重新擼一擼需求先： 存取消費數據 計算每月，實付（總分），應付以及最後計算結算金額 按月查詢，月結賬單 三人皆可編輯 主要就是存取數據這點，沒有服務器，數據庫怎麼實現？ valine 可以實現無後端，那我是不是也可以，leancloud 文檔走一波，然後“數據表”設計一下，其實是 leancloud-storage Object，於是有了以下東西，源碼放在 Github bill-note http://github.com/Lruihao/bill-note 19.1 數據設計 去 leancloud 创建一个应用，再新增一个 Bill Class, 补充一下字段： name type description pay Number 消费金额 pay_description String 消费描述 pay_type String 消费类型 pay_user String 付款人 19.2 主要邏輯 19.2.1 初始化 set for yourself. AV.init({ appId: '', appKey: '', serverURL: '' }); 19.2.2 存數據 //記賬提交按鈕事件監聽 document.querySelector('.submit').addEventListener('click', function (event) { event.preventDefault(); let formPay = document.querySelector('#form-pay'); let bill = new AV.Object('Bill'); bill.set('pay', Number(formPay.pay.value)); bill.set('pay_type', Number(formPay.pay_type.value)); bill.set('pay_user', Number(formPay.pay_user.value)); bill.set('pay_description', formPay.pay_description.value); bill.save().then( (object) =\u003e { formPay.reset(); }, function (error) { console.log(JSON.stringify(error)); alert('保存失敗'); } ); }); 19.2.3 取數據 /** * 獲取歷史消費記錄數據 * @param [start=0] 開始位置 * @param [count=15] 每次查詢筆數 */ function getBillData(start = 0, count = 15) { queryBill .descending('createdAt') .skip(start * count) .limit(count) .find() .then(function (response) { let billLength = response.length; if (billLength \u003e 0) { billVm.noMore = billLength !== count ? true : false; for (bill of response) { billVm.bills.push({ pay: bill.attributes.pay, payType: payType[bill.attributes.pay_type], payUser: payUser[bill.attributes.pay_user], payDescription: bill.attributes.pay_description, payDt: new Date(bill.createdAt).toLocaleString() }); } } else { billVm.noMore = true; } }); } /** * 獲取月賬單數據 * @param month 年月份 fmt: yyyy-MM */ function getMonthBill(month) { let dateTime = `${month} 00:00:00`; let startMonth = new Date(dateTime); let nextMonth = new Date(new Date(dateTime).setMonth(startMonth.getMonth() + 1)); let startDateQuery = new AV.Query('Bill'); startDateQuery.greaterThanOrEqualTo('createdAt', startMonth); let endDateQuery = new AV.Query('Bill'); endDateQuery.lessThan('createdAt', nextMonth); let MonthBillQuery = AV.Query.and(startDateQuery, endDateQuery); MonthBillQuery.find().then(function (response) { billVm.monthBill = { payType0: 0, payType1: 0, payType2: 0, payType3: 0, payUser0: 0, payUser1: 0, payUser2: 0 }; for (bill of response) { let { pay, pay_type, pay_user } = bill.attributes; billVm.monthBill[`payType${pay_type}`] += pay; billVm.monthBill[`payUser${pay_user}`] += pay; } }); } 19.3 技術棧 leancloud-storage Vue.js HTML,CSS,JS 20 總結 簡單總結一下，登录功能不做，安不安全自己说了算。删除修改功能也不做，直接上 leancloud 操作，css 美化的样式也不写，干净又卫生！ 然后衍生一下，什么过年斗地主，天炸，麻将，字牌记账系统那不也是同理可得嘛！ over! Demo ","date":"2021-03-02","objectID":"/projects/bill-note/:0:0","tags":["JavaScript","Vue2","leancloud"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/bill-note/"},{"categories":["GitHub"],"content":"Lruihao/bill note: 基于 leancloud-storage 实现的无后端记账本","date":"2021-02-28","objectID":"/projects/lruihao/bill-note/","tags":["vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/lruihao/bill-note/"},{"categories":["GitHub"],"content":"Preparation 去 leancloud 创建一个应用，再新增一个 Bill Class, 补充一下字段： name type description pay Number 消费金额 pay_description String 消费描述 pay_type String 消费类型 pay_user String 付款人 Init set for yourself. AV.init({ appId: '', appKey: '', serverURL: '' }); Push push the bill-note/docs to web server. 技术栈 leancloud-storage Vue.js HTML, CSS, JS ","date":"2021-02-28","objectID":"/projects/lruihao/bill-note/:0:0","tags":["vue"],"title":"基于 leancloud-storage 实现的无后端记账本","uri":"/projects/lruihao/bill-note/"},{"categories":["PHP"],"content":" 基于 Laravel7 开发，Markdown 语法的个人独立博客。Cell Blog, 也是我的毕业设计作品，目前已開源。 1 功能 支持 Markdown, 文章实时预览效果 支持多种编程语言代码高亮 编辑器图片上传 后台上传文件管理 文章搜索 文章分类 文章标签 热门文章 随机格言 文章管理（发布，评论开关，排序） 自定义导航（显示开关，排序） 自定义页面（发布开关） 友情链接（显示开关，排序） COS 桶相册 丰富的博客配置（方便扩展，支持自定义 JS 脚本） 不蒜子计数 Leancloud 计数 Valine 评论插件 文章分享插件 2 截图 3 安装 注意事项：PHP 取消禁用函数putenv()和symlink()，安装fileinfo扩展。 下载 git clone https://github.com/Lruihao/cell-blog.git 进入站点 cd cell-blog 生成。env cp .env.example .env 编辑。env 环境配置 APP_URL=http://localhost #使用本地文件系统存储文件时，必须填写正确地址 APP_DEBUG=false #关闭调试 DB_HOST= #数据库地址 DB_PORT=3306 #数据库端口 DB_DATABASE= #数据库名称 DB_USERNAME= #数据库用户 DB_PASSWORD= #数据库密码 打开app\\Providers\\AppServiceProvider.php, 注释SystemController:load() 防止后续步骤报错 public function boot() { Schema::defaultStringLength(191); //SystemController::load(); } 安装项目依赖 composer install 生成 key php artisan key:generate 运行数据迁移和后台数据填充 php artisan admin:install已包含数据迁移命令php artisan migrate G:\\cell-blog\\app\\Admin directory already exists !无需理会，继续执行剩下命令即可。 php artisan admin:install php artisan admin:import media-manager php artisan db:seed 默认下使用了本地文件系统，创建 storage 目录在 public 的软链接 php artisan storage:link 打开app\\Providers\\AppServiceProvider.php, 取消注释SystemController:load() public function boot() { Schema::defaultStringLength(191); SystemController::load(); } 将博客网站根目录指向入口 public 目录 如果使用 Nginx，要设置伪静态 location / { try_files $uri $uri/ /index.php?$query_string; } 启动服务后，在浏览器打开http://localhost/admin/, 使用用户名admin和密码admin登录。 4 License Cell Blog is open-sourced software licensed under the MIT license. ","date":"2020-07-25","objectID":"/projects/cell-blog/:0:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 功能介绍与安装","uri":"/projects/cell-blog/"},{"categories":["Memo"],"content":" Cell Blog 开发记录，项目地址 73 搭建 php 环境 安装 wampserver 安装 composer 更换 aliyun 源 composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 74 新建 laravel 项目 composer create-project --prefer-dist laravel/laravel cell-blog \"7.*\" 或者 composer global require laravel/installer laravel new blog 75 下载 debugbar composer require barryvdh/laravel-debugbar --dev 76 修改语言时区 修改 config/app.php，将 local 的值 en 改成 zh-CN(laravel-admin 自带 zh-CN)： ## 时区 'timezone' =\u003e 'Asia/Shanghai', ## 语言 'locale' =\u003e 'zh-CN', 77 配置数据库 首先确保安装好了 laravel，并且数据库连接设置正确。 APP_URL=http://cell.blog DB_CONNECTION=mysql DB_HOST=127.0.0.1 DB_PORT=3307 DB_DATABASE=cell_blog DB_USERNAME=root DB_PASSWORD=123456 78 下载 laravel-admin cd cell-blog composer require encore/laravel-admin 卸载命令composer remove xxx 然后运行下面的命令来发布资源： php artisan vendor:publish --provider=\"Encore\\Admin\\AdminServiceProvider\" 在该命令会生成配置文件config/admin.php，可以在里面修改安装的地址、数据库连接、以及表名，建议都是用默认配置不修改。 然后运行下面的命令完成安装： php artisan admin:install 运行这个命令的时候，如果遇到了下面的错误： SQLSTATE[42000]: Syntax error or access violation: 1071 Specified key was too long; max key length is 1000 bytes (SQL: alter tableusersadd uniqueusers_email_unique(email)) 参考这个 issue 来解决 https://github.com/z-song/laravel-admin/issues/1541 在app\\Providers\\AppServiceProvider.php添加默认值 \u003c?php namespace App\\Providers; use Illuminate\\Support\\ServiceProvider; use Illuminate\\Support\\Facades\\Schema; //add fixed sql class AppServiceProvider extends ServiceProvider { /** * Bootstrap any application services. * * @return void */ public function boot() { Schema::defaultStringLength(191); //add fixed sql } /** * Register any application services. * * @return void */ public function register() { // } } 启动服务后，在浏览器打开 http://localhost/admin/ , 使用用户名 admin 和密码 admin 登录。 报错Disk [admin] not configured, please add a disk config in config/filesystems.php 在config/filesystems.php中 disks 处添加以下配置后执行php artisan storage:link来创建软链接（windows 和 linux 的软链接不一样不能直接复制！） 宝塔执行时删除禁用函数 putenv(),symlink() 'admin' =\u003e [ 'driver' =\u003e 'local', 'root' =\u003e storage_path('app/public/system'), 'url' =\u003e env('APP_URL').'/storage/system', 'visibility' =\u003e 'public', ], 或 'admin' =\u003e [ 'driver' =\u003e 'local', 'root' =\u003e public_path('uploads'), 'url' =\u003e env('APP_URL').'/public/uploads/', 'visibility' =\u003e 'public', ], 79 下载 dcat-admin composer require dcat/laravel-admin 然后运行下面的命令来发布资源： php artisan admin:publish 在该命令会生成配置文件config/admin.php，可以在里面修改安装的地址、数据库连接、以及表名，建议都是用默认配置不修改。 然后运行下面的命令完成安装： php artisan admin:install 80 迁移文件创建表 php artisan make:migration create_articles_table php artisan make:migration create_tags_table php artisan make:migration create_categories_table php artisan make:migration create_article_tags_table php artisan make:migration create_navigations_table php artisan make:migration create_friendship_links_table php artisan make:migration create_pages_table php artisan make:migration create_systems_table php artisan make:migration create_mottoes_table 运行迁移 php artisan migrate 81 创建模型 model php artisan make:model Models/Article php artisan make:model Models/Category php artisan make:model Models/Tag php artisan make:model Models/Navigation php artisan make:model Models/FriendshipLink php artisan make:model Models/Page php artisan make:model Models/System php artisan make:model Models/Motto 82 创建控制器 php artisan admin:make ArticleController --model=App\\Models\\Article php artisan admin:make CategoryController --model=App\\Models\\Category php artisan admin:make TagController --model=App\\Models\\Tag php artisan admin:make NavigationController --model=App\\Models\\Navigation php artisan admin:make FriendshipLinkController --model=App\\Models\\FriendshipLink php artisan admin:make PageController --model=App\\Models\\Page php artisan admin:make SystemController --model=App\\Models\\System php artisan admin:make MottoController --model=App\\Models\\Motto 83 添加后台路由 app/Admin/routes.php $router-\u003eresource('articles', ArticleController::class); $router-\u003eresource('categories', CategoryController::class); $router-\u003eresource('tags', Ta","date":"2020-07-25","objectID":"/posts/cell-blog-dev/:0:0","tags":["PHP","Laravel","Markdown"],"title":"cell-blog 开发记录","uri":"/posts/cell-blog-dev/"},{"categories":["GitHub"],"content":"Lruihao/cell blog: 基于 Laravel 7 开发，支持 Markdown 语法的博客","date":"2020-04-17","objectID":"/projects/lruihao/cell-blog/","tags":["blog","laravel","laravel-blog"],"title":"基于 Laravel 7 开发，支持 Markdown 语法的博客","uri":"/projects/lruihao/cell-blog/"},{"categories":["GitHub"],"content":"Cell Blog 基于Laravel7开发，Markdown语法的个人独立博客。 功能 支持Markdown,文章实时预览效果 支持多种编程语言代码高亮 编辑器图片上传 后台上传文件管理 文章搜索 文章分类 文章标签 热门文章 随机格言 文章管理(发布，评论开关，排序) 自定义导航(显示开关，排序) 自定义页面(发布开关) 友情链接(显示开关，排序) COS桶相册 丰富的博客配置(方便扩展，支持自定义JS脚本) 不蒜子计数 Leancloud计数 Valine评论插件 文章分享插件 截图 安装 注意事项：PHP取消禁用函数putenv()和symlink()，安装fileinfo扩展。 下载 git clone https://github.com/Lruihao/cell-blog.git 进入站点 cd cell-blog 生成.env cp .env.example .env 编辑.env环境配置 APP_URL=http://localhost ##使用本地文件系统存储文件时，必须填写正确地址 APP_DEBUG=false ##关闭调试 DB_HOST= ##数据库地址 DB_PORT=3306 ##数据库端口 DB_DATABASE= ##数据库名称 DB_USERNAME= ##数据库用户 DB_PASSWORD= ##数据库密码 打开app\\Providers\\AppServiceProvider.php,注释SystemController:load() 防止后续步骤报错 public function boot() { Schema::defaultStringLength(191); //SystemController::load(); } 安装项目依赖 composer install 生成key php artisan key:generate 运行数据迁移和后台数据填充 php artisan admin:install已包含数据迁移命令php artisan migrate G:\\cell-blog\\app\\Admin directory already exists !无需理会，继续执行剩下命令即可。 php artisan admin:install php artisan admin:import media-manager php artisan db:seed 默认下使用了本地文件系统，创建storage目录在public的软链接 php artisan storage:link 打开app\\Providers\\AppServiceProvider.php,取消注释SystemController:load() public function boot() { Schema::defaultStringLength(191); SystemController::load(); } 将博客网站根目录指向入口public目录 如果使用Nginx，要设置伪静态 location / { try_files $uri $uri/ /index.php?$query_string; } 启动服务后，在浏览器打开http://localhost/admin/,使用用户名admin和密码admin登录. License Cell Blog is open-sourced software licensed under the MIT license. ","date":"2020-04-17","objectID":"/projects/lruihao/cell-blog/:0:0","tags":["blog","laravel","laravel-blog"],"title":"基于 Laravel 7 开发，支持 Markdown 语法的博客","uri":"/projects/lruihao/cell-blog/"},{"categories":["瞎折腾","Python"],"content":" 使用 python 模拟浏览器行为刷 csdn 访问量，脚本仅做学习，请勿滥用~ 直接丢代码，把代码挂到服务器上可以策马奔腾~，也可以生成二进制文件放到 Windows 桌面上随时使用~ 打包 exe 参考 #!/usr/bin/python # -*- coding: utf-8 -*- __author__ = 'lruihao.cn' import urllib.request import re import time from bs4 import BeautifulSoup opener = urllib.request.build_opener() opener.addheaders = [('User-agent', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36')] def get_article_url(page,name): endurl = \"/\"+name+\"/article/details/........\" print(name) p = re.compile(endurl) url = \"http://blog.csdn.net/\"+name+\"/article/list/\"+str(page) # 使用 build_opener() 是为了让 python 程序模仿浏览器进行访问 html = opener.open(url).read().decode('utf-8') allfinds = p.findall(html) return allfinds #print('allfinds',allfinds) def start_do(allfinds): urlBase = \"http://blog.csdn.net\" # 需要将网址合并的部分 # 页面中的网址有重复的，需要使用 set 进行去重复 mypages = list(set(allfinds)) for i in range(len(mypages)): mypages[i] = urlBase + mypages[i] print('要刷的网页有：') for index, page in enumerate(mypages): print(str(index), page) # 设置每个网页要刷的次数 brushNum = 1 # 所有的页面都刷 print('下面开始刷了哦：') for index, page in enumerate(mypages): for j in range(brushNum): try: pageContent = opener.open(page).read().decode('utf-8') # 使用 BeautifulSoup 解析每篇博客的标题 soup = BeautifulSoup(pageContent) blogTitle = str(soup.title.string) blogTitle = blogTitle[0:blogTitle.find('-')] print(str(j), blogTitle) except urllib.error.HTTPError: print('urllib.error.HTTPError') time.sleep(3) # 出现错误，停几秒先 except urllib.error.URLError: print('urllib.error.URLError') time.sleep(3) # 出现错误，停几秒先 time.sleep(0.5) # 正常停顿，以免服务器拒绝访问 def main(name): for page in range(1,5): print(\"************第\"+str(page)+\"页*************\") endurl = get_article_url(page,name) start_do(endurl) if __name__ == '__main__': name = input(\"输入你的 csdn 用户名：\") if name==\"\": name = \"qq_39520417\" #cheung99857 while 1: main(name) print(\"开始休息 ...\") time.sleep(40) 主函数也可以这样写实现同时刷多人的访问量，人多可以适当减少休眠时间，当然有兴趣的可以尝试一下多线程~ if __name__ == '__main__': # 多用户 names = [\"qq_39520417\",\"cheung99857\"] while 1: for name in names: main(name) print(\"开始休息 ...\") # 控制休眠时间相当于控制刷新的速度 time.sleep(30) ","date":"2020-03-26","objectID":"/posts/csdnvisiter/:0:0","tags":["Python"],"title":"使用 Python 刷 csdn 访问量","uri":"/posts/csdnvisiter/"},{"categories":["OS"],"content":"17 基本语法 \u003c秒\u003e \u003c分钟\u003e \u003c小时\u003e \u003c日期 day-of-month\u003e \u003c月份\u003e \u003c星期 day-of-week\u003e Cron 表达式是一个具有时间含义的字符串，字符串以 5 个空格隔开，分为 6 个域，格式为 X X X X X X。其中 X 是一个域的占位符。单个域有多个取值时，使用半角逗号，隔开取值。每个域可以是确定的取值，也可以是具有逻辑意义的特殊字符。 18 域取值 位置 字段 约束 取值 可使用的特殊符号 1 秒 必须 0-59 , - * / 2 分钟 必须 0-59 , - * / 3 小时 必须 0-23（0 为午夜） , - * / 4 日期 必须 1-31 , - * ? / L W 5 月份 必须 1-12 或者 JAN-DEC , - * / 6 星期 必须 1-7 或者 SUN-SAT (1 代表星期一） , - ? / L # 19 特殊符号 符号 含义 示例 * 所有可能的值。 在月域中，*表示每个月；在星期域中，*表示星期的每一天。 , 列出枚举值。 在分钟域中，5,20表示分别在 5 分钟和 20 分钟触发一次。 - 范围。 在分钟域中，5-20表示从 5 分钟到 20 分钟之间每隔一分钟触发一次。 / 指定数值的增量。 在分钟域中，0/15表示从第 0 分钟开始，每 15 分钟。在分钟域中3/20表示从第 3 分钟开始，每 20 分钟。*/ 和 0/ 相同 ? 不指定值，仅日期和星期域支持该字符。 当日期或星期域其中之一被指定了值以后，为了避免冲突，需要将另一个域的值设为?。 L 单词 Last 的首字母，表示最后一天，仅日期和星期域支持该字符。说明 指定L字符时，避免指定列表或者范围，否则，会导致逻辑问题。 在日期域中，L表示某个月的最后一天。在星期域中，L表示一个星期的最后一天，也就是星期日（SUN）。如果在L前有具体的内容，例如，在星期域中的6L表示这个月的最后一个星期六。 W 除周末以外的有效工作日，在离指定日期的最近的有效工作日触发事件。W字符寻找最近有效工作日时不会跨过当前月份，连用字符LW时表示为指定月份的最后一个工作日。 在日期域中5W，如果 5 日是星期六，则将在最近的工作日星期五，即 4 日触发。如果 5 日是星期天，则将在最近的工作日星期一，即 6 日触发；如果 5 日在星期一到星期五中的一天，则就在 5 日触发。 # 确定每个月第几个星期几，仅星期域支持该字符。 在星期域中，4#2表示某月的第二个星期四。 20 举个栗子 🌰 表达式 说明 0 0/5 * * * ? 每隔 5 分钟执行一次 10 0/5 * * * ? 每隔 5 分钟执行一次，每次执行都在分钟开始的 10 秒，例如 10:00:10、10:05:10 等等。 0 30 10-13 ? * WED,FRI 每周三和每周五的 10:30、11:30、12:30、13:30 执行。 0 0/30 8-9 5,20 * ? 每个月的 5 号和 20 号的 8 点和 10 点之间每隔 30 分钟执行一次，也就是 8:00、8:30、9:00 和 9:30。 0 15 10 ? * * 每天上午 10:15 执行任务 0 15 10 * * ? 每天上午 10:15 执行任务 0 0 12 * * ? 每天中午 12:00 执行任务 0 0 10,14,16 * * ? 每天上午 10:00 点、下午 14:00 以及下午 16:00 执行任务 0 0/30 9-17 * * ? 每天上午 09:00 到下午 17:00 时间段内每隔半小时执行任务 0 * 14 * * ? 每天下午 14:00 到下午 14:59 时间段内每隔 1 分钟执行任务 0 0-5 14 * * ? 每天下午 14:00 到下午 14:05 时间段内每隔 1 分钟执行任务 0 0/5 14 * * ? 每天下午 14:00 到下午 14:55 时间段内每隔 5 分钟执行任务 0 0/5 14,18 * * ? 每天下午 14:00 到下午 14:55、下午 18:00 到下午 18:55 时间段内每隔 5 分钟执行任务 0 0 12 ? * WED 每个星期三中午 12:00 执行任务 0 15 10 15 * ? 每月 15 日上午 10:15 执行任务 0 15 10 L * ? 每月最后一日上午 10:15 执行任务 0 15 10 ? * 6L 每月最后一个星期六上午 10:15 执行任务 0 15 10 ? * 6#3 每月第三个星期六上午 10:15 执行任务 0 10,44 14 ? 3 WED 每年 3 月的每个星期三下午 14:10 和 14:44 执行任务 ","date":"2020-03-25","objectID":"/posts/cron/:0:0","tags":["linux","shell","Cron"],"title":"Cron 表达式的基本语法","uri":"/posts/cron/"},{"categories":["瞎折腾","Python"],"content":" 信息 这件事还得从一只蝙蝠说起 … 算了，昨天下午 3 点半，我还在王者峡谷 Timing, 突然潇 X 巴哥打了个电话给我说关于自动打卡的想法 … 哎，反正就是由于疫情需要每天健康打卡汇报给学校，然后每天提交一样的太麻烦了，就想写个程序自动打卡 … 我和潇 X 巴哥确定思路后兵分两路： 他用 java 写个后台自动刷多人的，再弄个网页给用户填写账号密码保存在数据库； 我想的就很直接，只刷一个人的，python 模拟浏览器登录后打卡，再设置定时任务（多人则设定多个）； 1 Windows 运行效果 打卡成功 重复打卡 定时任务日志 2 核心代码 适用湖南工程学院的打卡系统。 请勿滥用代码提交不实健康信息，隐瞒疫情将受到相关法律处理！ 完整代码 def lajaDaka(): # 登录 r1 = requests.post(login_url, data=login,headers=headers,verify=False) if r1.status_code == 200: print(time.strftime(\"%Y:%m:%d:%H:%M\", time.localtime())) print(login[\"username\"] + \" 登录成功！\") # 拿到登录后的 cookie 并添加到 header 中 header1 = r1.headers headers[\"Cookie\"] = header1[\"Set-Cookie\"] else: return # 打卡 r2 = requests.post(daka_url, data=daka,headers=headers,verify=False) response2=r2.json() if r2.status_code != 200: print(\"打卡失败！\") return if response2[\"result\"] == True: print(\"打卡成功！\") else: print(response2[\"errorInfoList\"][0][\"message\"]) if __name__==\"__main__\": lajaDaka() 3 自动运行 3.1 Windows 适用 python 代码控制休眠时间 if __name__==\"__main__\": while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) # 设置每天 8 点发送 if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 脚本将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后打卡\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 脚本将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后打卡\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"软件明天开始将在每天 8 点发送数据！\") lajaDaka() time.sleep(24*60*60-int(now_min)*60) 3.2 linux（云服务器） 搭建 python 环境下载依赖后，使用 shell 脚本定时执行。 python /home/python/yiban_daka/daka.py CRON 表达式的基本语法 4 潇 x 巴哥的 java web 版本 符合程序员的应该有的简洁和方便，干净又卫生！ http://39.105.174.214/index.html java web 版 ","date":"2020-03-25","objectID":"/posts/daka/:0:0","tags":["Python","HTTP"],"title":"新冠疫情未返校未返工第 N 天之“自动打卡”","uri":"/posts/daka/"},{"categories":["MySQL"],"content":" SQL 增删改查 (CRUD) 语句与常用函数总结。 33 SQL Introduction 一般我们对数据库的操作主要分为四种，增C(CREATE)、删D(DELETE)、改U(UPDATE)、查R(READ)，所以，我就从CRUD这四个方面来制作查询表。 开发规则： 尽量减少对数据库的访问次数，且不能查询无用的数据，浪费效能（例如：我只要男生的数据，你把所有人的数据都查询出来）。 属于SQL语法的要使用大写（SELECT, WHERE, INSERT etc…）。 属于使用者自己定义的要使用小写（表名、列名 etc…）。 表名与列名前后使用 ` 包起来，防止与关键字冲突（例如： INSERT INTO `user` VALUES(‘a’,‘b’); ）。 禁止使用 Table Join。 禁止使用 Oracle Trigger。 禁止使用 SELECT * （为了加强代码可读性）。 不能将查询数据库的 SQL 放在循环中查询。 34 新增（CREATE） 功能 语句 创建数据库 CREATE DATABASE \u003c数据库名\u003e; 创建数据表 CREATE TABLE \u003c表名\u003e (\u003c列名 1\u003e \u003c数据类型\u003e \u003c约束条件\u003e,\u003c列名 2\u003e \u003c数据类型\u003e \u003c约束条件\u003e,\u003c列名 3\u003e \u003c数据类型\u003e \u003c约束条件\u003e,......\u003c该表的的约束条件 1\u003e\u003c该表的的约束条件 2\u003e...); 插入数据 INSERT INTO \u003c表名\u003e （列名 1, 列名 2,...) VALUES （值 1, 值 2,...);（每列都有数据插入时，可省略列名。但是为了代码的可读性，不建议如此操作。） 增加列 ALTER TABLE \u003c表名\u003e ADD \u003c列名\u003e \u003c数据类型\u003e \u003c约束条件\u003e AFTER \u003c前一列列名\u003e;（默认插入到最后一列） 35 删除（DELETE） 功能 语句 删除数据库 DROP DATABASE \u003c数据库名\u003e; 删除数据表 DROP TABLE \u003c表名\u003e; 清空表数据 DELETE FROM \u003c表名\u003e; 或者 TRUNCATE TABLE \u003c表名\u003e; 删除行数据 DELETE FROM \u003c表名\u003e WHERE \u003c条件\u003e; 删除列数据 ALTER TABLE \u003c表名\u003e DROP \u003c列名\u003e; 36 修改（UPDATE） 功能 语句 修改数据库名 RENAME DATABASE \u003c旧名称\u003e TO \u003c新名称\u003e; 修改表名 RENAME TABLE \u003c旧名称\u003e TO \u003c新名称\u003e; 修改数据 UPDATE \u003c表名\u003e SET \u003c列名 1\u003e = \u003c新值 1\u003e,\u003c列名 2\u003e = \u003c新值 2\u003e WHERE \u003c条件\u003e; 修改列名 ALTER TABLE \u003c表名\u003e CHANGE \u003c旧列名\u003e \u003c新列名\u003e \u003c数据类型\u003e \u003c约束条件\u003e; 注意：重命名数据库与数据表一般不推荐使用，若想测试，请先备份好自己的数据库~ 37 查询（ R E A D ） 功能 语句 查询所有数据库 SHOW DATABASES; 查询指定数据库中所有表名 USE \u003c数据库名\u003e; 然后 SHOW TABLES;或者 SHOW TABLES FROM \u003c数据库名\u003e; 查询表中所有列信息 SHOW COLUMNS FROM \u003c表名\u003e; 查询表中所有数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e; 查询表中某个数据 SELECT \u003c列名\u003e FROM \u003c表名\u003e; 查询表中指定多个数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e WHERE \u003c条件\u003e; 查询表中指定一个数据 SELECT \u003c列名\u003e FROM \u003c表名\u003e WHERE \u003c条件\u003e; 查询指定范围数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e WHERE\u003c某列名\u003e BETWEEN \u003c某列名范围值-小\u003e AND \u003c某列名范围值-大\u003e; 字符串模式匹配查询 SELECT \u003c列名\u003e FROM \u003c表名\u003e WHERE name LIKE 'Y%';（查询以 Y 开头的，更多匹配方式自行百度哦~。） 指定多个值数据查询 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e WHERE\u003c某列名\u003e IN ('\u003c某列名值 1\u003e','\u003c某列名值 2\u003e','\u003c某列名值 3\u003e',...); 查询结果排序 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e ORDER BY \u003c某列名\u003e DESC;（此处为递减排列，默认为递增ASC） 查询指定几笔数据 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,... FROM \u003c表名\u003e LIMIT n,m;（从n到m笔数据） 分群查询 SELECT \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,...,\u003c函数\u003e FROM \u003c表名\u003e GROUP BY \u003c列名 1\u003e,\u003c列名 2\u003e,\u003c列名 3\u003e,...;（常搭配函数有：SUM()、AVG()、COUNT()、MAX()、MIN()） 38 常用函数 函数名 用途 ABS（数值） ABS 函数（求绝对值） MOD（被除数，除数） MOD 函数（求余） ROUND（对象数值，保留小数的位数） ROUND 函数（四舍五入） 字符串 1 ΙΙ 字符串 2 ΙΙ 函数（拼接） LENGTH（字符串） LENGTH 函数（求字符串长度） LOWER（字符串） LOWER 函数（小写转换） UPPER（字符串） UPPER 函数（大写转换） REPLACE（对象字符串，替换前的字符串，替换后的字符串） REPLACE 函数（字符串的替换） SUBSTRING （对象字符串，截取的起始位置，截取的字符数） SUBSTRING 函数（字符串的截取） CURRENT_DATE CURRENT_DATE 函数（当前日期） CURRENT_TIME CURRENT_TIME 函数（当前时间） CURRENT_TIMESTAMP CURRENT_TIMESTAMP 函数（当前日期和时间） EXTRACT（日期元素 FROM 日期） EXTRACT 函数（截取日期元素） CAST（转换前的值 AS 想要转换的数据类型） CAST 函数（类型转换） COALESCE（数据 1, 数据 2, 数据 3….) COALESCE 函数（将 NULL 转换为其他值） 补充：CASE 表达式。 CASE WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e WHEN \u003c求值表达式\u003e THEN \u003c表达式\u003e ...... ELSE \u003c表达式\u003e END 39 其他知识 39.1 常见数据类型 39.2 别名 给表设置别名，让 SQL 更简洁。例如： SELECT \u003ccol-1\u003e,\u003ccol-2\u003e,\u003ccol-3\u003e,... FROM \u003ctable1\u003e \u003calias-a\u003e,\u003ctable2\u003e \u003calias-b\u003e WHERE \u003calias-a\u003e.\u003cid\u003e = \u003calias-b\u003e.\u003cid\u003e; 列名也可以设置别名。例如： SELECT \u003ccol-1\u003e \u003calias-a\u003e,\u003ccol-2\u003e \u003calias-b\u003e,\u003ccol-3\u003e \u003calias-c\u003e,... FROM \u003ctable\u003e; 或者 SELECT \u003ccol-1\u003e AS \u003calias-a\u003e,\u003ccol-2\u003e AS \u003calias-b\u003e,\u003ccol-3\u003e AS \u003calias-c\u003e,... FROM \u003ctable\u003e; 40 总结 以上整理的内容均为基础内容，更多进阶知识还需各位自行 Google。 ","date":"2020-01-16","objectID":"/posts/sql/:0:0","tags":["MySQL"],"title":"SQL 总结","uri":"/posts/sql/"},{"categories":["JavaScript"],"content":" 信息 cos 桶相册，终于！！终于来了！！，idea 来自 [兰州小红鸡 - 给 hexo 静态博客添加动态相册功能]， 功能虽好，但是还是先友情提示！ 开放 API 是一个很危险的操作，意味着你的 cos 桶里面的所有资源包括目录结构都暴露的整个世界中，所以建议不要放一些比较私密的照片，保护自己的隐私，提防不良用心之人。下面就开始吧！ 17 创建腾讯云 cos 存储桶 就创建一个 COS 就好了！有几点注意事项： 权限设置为共有读私有写 policy 权限设置整个桶的读操作 跨域访问 CORS 设置，自己随意 18 上传照片 首先我这个 cos 相册，相册分类就是文件夹分类，所以 cos 桶里面先新建不同的文件夹，文件夹名称就是相册名称， 每个相册里面需要放置一张名称为**“封面.jpg”**的图片作为该相册的封面。 18.1 上传工具 COSBrowser GUI 工具，桌面/移动版【官方、推荐】 COSCMD 命令行工具【官方】 PicGo 图床上传工具【第三方、推荐】 19 食用方式 cos album 相册源码下载地址，别忘点赞哈 http://github.com/Lruihao/cos-album 首先，下载源码，引入 cos-album.css 和 cos-album.js 然后，在你的 js 中 new 一个 Cosalbum 对象 ( xmlLink 后不需要添加/) 19.1 Step1 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"cos-album.min.css?v=1.1.2\"\u003e \u003cscript type=\"text/javascript\" src=\"cos-album.min.js?v=1.1.2\"\u003e\u003c/script\u003e 19.2 Step2 \u003cscript type=\"text/javascript\"\u003e new Cosalbum({ 'xmlLink': 'https://img-xxxxxxxxxx.cos.ap-chengdu.myqcloud.com', 'prependTo': '.cos-album', 'viewNum': 8, 'imgUrl': '//img.lruihao.cn' }); \u003c/script\u003e 19.3 Params param type default description xmlLink String 需要解析的騰訊云 COS 桶 XML 鏈接 prependTo String ‘body’ 可選解析相冊到某個節點 viewNum Number 4 每個相冊顯示的照片數目 copyUrl String href CDN 链接，雙擊複製 URL Since: 1.1.6 imgType String [‘jpg’, ‘jpeg’, ‘png’, ‘gif’, ‘svg’] 图片類型 Since: 1.1.6 videoType String [‘mp4’, ‘mp3’, ‘avi’, ‘mov’, ‘qt’] 視頻類型 Since: 1.1.6 viewport 视个人情况添加。 hexo 中使用时 css 和 js 都需要做适当调整，配合加密功能使用等等，这里不再展开。 注：代码设定不加载根目录文件，所以可以利用静态服务把源码部署在根目录，配合 PicGo、COSBrowser 上传来搭建个人图床。 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\" /\u003e \u003ctitle\u003ecos-album\u003c/title\u003e \u003c!-- \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e --\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"cos-album.css\" /\u003e \u003cscript type=\"text/javascript\" src=\"cos-album.js\" defer\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e new Cosalbum({ xmlLink: 'https://img-xxxxxxxxxx.cos.ap-chengdu.myqcloud.com', prependTo: '.cos-album', viewNum: 8, copyUrl: '//img.lruihao.cn' }); \u003c/script\u003e \u003c!-- 你的其他内容，如评论等 --\u003e \u003c/body\u003e \u003c/html\u003e cos-album demo 20 changelog 2020-9-28 22:46 升級：相冊封裝成類，可以更方便 new 出來 優化：相冊圖片樣式優化 2019-11-24 10:52:34 修改整理了一下代码，分割功能为函数，并写了注释，更加方便 伸手党! ","date":"2019-11-24","objectID":"/projects/cos-album/:0:0","tags":["CosAlbum","腾讯云 cos 桶","JavaScript"],"title":"利用腾讯云为静态页面添加“动态”相册","uri":"/projects/cos-album/"},{"categories":["GitHub"],"content":"Lruihao/cos album: 解析腾讯云 cos 桶 xml 生成相册,同时也是图床的显示页面","date":"2019-11-23","objectID":"/projects/lruihao/cos-album/","tags":["cos-album","cos-bucket"],"title":"解析腾讯云 cos 桶 xml 生成相册,同时也是图床的显示页面","uri":"/projects/lruihao/cos-album/"},{"categories":["GitHub"],"content":"cos-album demo Step1 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"cos-album.min.css?v=1.1.6\"\u003e \u003cscript type=\"text/javascript\" src=\"cos-album.min.js?v=1.1.6\"\u003e\u003c/script\u003e Step2 \u003cscript type=\"text/javascript\"\u003e new Cosalbum({ 'xmlLink': 'https://img-xxxxxxxxxx.cos.ap-chengdu.myqcloud.com', 'prependTo': '.cos-album', 'viewNum': 8, 'copyUrl': '//img.lruihao.cn' }); \u003c/script\u003e Params param type default description xmlLink String 需要解析的騰訊云COS桶XML鏈接 prependTo String ‘body’ 可選解析相冊到某個節點 viewNum Number 4 每個相冊顯示的照片數目 copyUrl String href CDN 链接,雙擊複製 URL Since: 1.1.6 imgType String [‘jpg’, ‘jpeg’, ‘png’, ‘gif’, ‘svg’] 图片類型 Since: 1.1.6 videoType String [‘mp4’, ‘mp3’, ‘avi’, ‘mov’, ‘qt’] 視頻類型 Since: 1.1.6 详细说明 ","date":"2019-11-23","objectID":"/projects/lruihao/cos-album/:0:0","tags":["cos-album","cos-bucket"],"title":"解析腾讯云 cos 桶 xml 生成相册,同时也是图床的显示页面","uri":"/projects/lruihao/cos-album/"},{"categories":["Spec","计算机网络"],"content":" RESTful 是一种系统开发设计风格、原则。可视情况调整，以下参考来源 RFC5789 13 Noun 一般资源 通用于一律使用复数名词 例如：/books 或 /books/123。但有部分人认为应该使用单数名词，因为： /book/123 看似比 /books/123 合理。但想想文件系统的目录命名（例如 /Users 或 /Documents)，其实用复数也没问题。复数可以保持 API endpoint 的一致性，所以一般资源建议用复数。 唯一资源：对 client 而言只有一份的资源 通用于单数名词 例如：user 是指目前验证的使用者，使用者永远只能同时登入一个使用者 14 Http Method MethodIdempotentSafeCRUDOO生活动词用途GETYYReadgetget取得资料list列出资料POSTCreateaddcreate建立一个可以完全独立存在的实体add增加一个必须依赖于某个实体的实体PUTYUpdatesetreplace取代一个关系，已存在时先删除后建立，不存在时直接建立add附加唯一关系，两个关系实体可以互相独立存在，且已经存在PATCHedit编辑某个实体DELETEDeleteremoveremove delete删除某个实体 Safe：该操作不会改变伺服器端的资源状态（而且结果可以被 cache），属于 Safe 的操作必定属于 Idempotent Idempotent (幂等性)：该操作不管做 1 遍或做 n 遍，都会得到同样的资源状态结果（但不一定得到同样的返回值，例如第 2 次 DELETE 请求可能回传 404），因此 client 端可以放心 retry 14.1 GET Safe：每次执行操作时，GET 只有读取 Resource，不会改变到任何的 Resource（资源，资料） Idempotent：每次执行操作时，GET 只有读取 Resource，不会改变到任何的 Resource（资源，资料），所以任何资源的任何状态都是一样的 14.2 POST 每次执行操作时，POST 都会建立一个 Resource（资源，资料） Create：建立一个可以完全独立存在的实体 范例：建立使用者 执行第一次时：建立一个 name = “李四” 的 user，但其 id = 1，执行第二次时：建立一个 name = “李四” 的 user，但其 id = 2，发送同样的请求，可每次都是不同的 Resource 建立使用者前不需要建立任何的东西，就可以建立使用者了，使用者是可以完全独立的存在 POST /users HTTP/1.1 Host: 127.0.0.1 { \"name\": \"李四\" } Add：增加一个必须依赖于某个实体的实体 资料结构：一对多的关系 范例：Add a public key on behalf of a user 增加一个代表使用者的公钥 (Gitea API) 增加这个公钥之前，使用者必须存在，公钥必须归属于某个使用者之下，公钥跟姓名一样，使用相同电脑的公钥就会相同，但不表示是同一个使用者，故公钥也会有自己的 ID 我每次增加公钥时，都将生成不同的公钥 ID POST /api/v1/admin/users/{username}/keys HTTP/1.1 Host: gitea.com { \"key\": \"string\", \"read_only\": true, \"title\": \"string\" } 14.3 PUT Idempotent：每次执行操作时，PUT 都会取代 Resource，不管操作几次，使用者获取得 Resource 结果都是一样的 Replace：不论资源如何，最终的资源状态都是一样的，Resource 已存在时，或许不理会、或许先删除后建立（取代）Resource 不存在时，直接建立 Add：添加唯一关系，建立这个唯一关系前，两个关连实体都必须存在。在没有建立关系前，两个关连实体都可以互相独立存在 资料结构：多对多，且两个关连实体的 PK，同时也是关系实体的 PK、FK 范例：增加使用者与角色的关系 增加使用者跟角色的关系前，使用者跟角色都必须存在；增加使用者跟角色的关系前，使用者跟角色可以独立存在， 使用者 12262 跟 角色 2 的关系最多只能有一条关系（使用者 12262 有 角色 2)，最少没有关系（使用者 12262 没有 角色 2 ) ，执行第二次操作时，使用者 12262 跟 角色 2 的从属关系仍然存在，也不会跑出第二条 使用者 12262 跟 角色 2 的从属关系 PUT user/{account}/roles HTTP/1.1 Host: 127.0.0.1 { \"role_id\": \"2\" } 范例：Follow a user 关注一个使用者 (Gitea API) 增加关注关系时，关注者与被关注者（都是使用者）都必须存在；关注者 12262 跟被关注者 12231 的关系最多只能有一条关系（12262 关注 12231），最少没有关系（12262 不关注 12231），执行第二次操作时，关注者 12262 跟被关注者 12231 的关注关系仍然存在，也不会跑出第二条关注者 12262 跟被关注者 12231 的关注关系 PUT /api/v1/user/following/{username} HTTP/1.1 Host: gitea.com 14.4 PATCH Edit：编辑可独立存在、且已经存在的实体，也就是产生新版本的实体，可能会影响其他 Resource 范例：编辑使用者 编辑使用者，使用者已经存在，且我们可能有纪录编辑时间、编辑人、编辑 IP，所以每次的编辑都会造成不一样的结果 第一次编辑使用者，更新时间变为 08:00，编辑人 12262，IP 172.18.0.66 第二次编辑使用者，更新时间变为 09:00，编辑人 12263，IP 172.18.0.67 PATCH /users/{account} HTTP/1.1 Host: 127.0.0.1 { \"username\": \"李四\", \"age\": \"18\", \"gender\": \"male\" } 14.5 DELETE Idempotent：每次执行操作时，DELETE 都会删除相同的东西 范例：删除使用者 第一次删除使用者 12262，删除使用者 12262, 第二次删除使用者 12262，还是删除使用者 12262，只不过使用者 12262 不存在了 DELETE /users/{account} HTTP/1.1 Host: 127.0.0.1 15 HTTP Status Code HTTP 状态码（HTTP Status Code）是用以表示网页服务器 HTTP 响应状态的 3 位数字代码。所有状态码的第一个数字代表了响应的五种状态之一。除非另有说明，状态码是 HTTP/1.1 标准（RFC 7231）的一部分。 而关于 RESTful API 的请求状态，通常有以下两种设计方案： 方案一：使用 HTTP 状态码来表示请求状态，200 时返回的内容就是数据 方案二：所有接口都返回 200，在响应内容里约定错误码或错误信息 在实际应用中，应据具体情景及需要进行选择与调整。 方案优劣比较方案一优点对服务端来说较为简单方便缺点客户端难以根据状态码处理复杂问题方案二优点方便对返回资料进行统一处理和细微性的控制缺点相当于放弃了 HTTP 状态码的语义 15.1 常用 HTTP 状态码 Code Message 用途 1XX Informational response 此类状态码通常代表的响应都是信息性的，告诉客户端可以进行下一步操作。 100 Continue 表示服务端已接收到请求头，客户端可以继续发送请求体（如 POST 请求）。 101 Switching Protocols 表示服务端支持更优协议，让客户端在服务端更换协议后重新访问。 2XX Successful 此类状态码通常代表请求已成功被服务端接收、理解并接受。 200 OK 表示请求成功。 201 Created 表示请求已被实现，通常是在成功创建了某个资源。 202 Accepted 表示请求已被服务端接收，但尚未进行处理。 204 No Content 表示请求成功，但不会返回任何内容。 205 Reset Content 表示请求成功，但不会返回任何内容，并且要求客户端重置表单。 3XX Redirect 此类状态码通常代表本次请求需要客户端采取进一步操作才能完成。通常用于重定向。 300 Multiple Choices 表示请求的资源有多个供可选择，客户端可自行选择一个进行请求的重定向。 301 Moved Permanently 表示请求的资源已经永久地移动到了新位置，并且将在 Location 域中携带该资源新的 URI。 304 Not Modified 表示请求的资源无发生修改，将不会返回任何资源。 4XX Client Error 此类状态码通常代表客户端可能出现了错误。 400 Bad Request 表示客户端发出的请求有误（格式、大小、无效的…)，服务端不能/ 不会处理该请求。 401 Unauthorized 表示客户端未能提供必要的验证，服务端拒绝提供资源。 403 Forbidden 表示服务端理解了该请求，但客户端没有足够权限以访问，遂拒绝提供该资源。 404 Not Found 表示服务端无法找到请求的资源，其可能已经暂时（永久","date":"2019-11-14","objectID":"/posts/restful/:0:0","tags":["REST","HTTP"],"title":"RESTful","uri":"/posts/restful/"},{"categories":["PHP"],"content":" php 主动推送站点链接到百度站长，神马站长进行 SEO。 1 代码 把需要提交的链接和各站长 api 分别放在两个 txt 文件里面，然后运行 php 文件进行提交，不同站长提交成功一般返回的都是 200 状态码。 \u003c?php //链接存放路径和站长 api 文件存放路径 $urls_path = \"H:\\\\lruihao.cn\\\\public\\\\baidu_urls.txt\"; $apis_path = \"G:\\\\Demo\\\\lrh01\\\\zhanzhang_api.txt\"; //将文件每一行读到一个数组里面去 $urls = file($urls_path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); $apis = file($apis_path, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); for($x=0;$x\u003ccount($apis);$x++){ $ch = curl_init(); $options = array( CURLOPT_URL =\u003e $apis[$x], CURLOPT_POST =\u003e true, CURLOPT_RETURNTRANSFER =\u003e true, CURLOPT_POSTFIELDS =\u003e implode(\"\\n\", $urls), CURLOPT_HTTPHEADER =\u003e array('Content-Type: text/plain'), ); curl_setopt_array($ch, $options); $result = curl_exec($ch); echo \"API: \u003cbr/\u003e\u0026emsp;\".$apis[$x].\"\u003cbr/\u003e\"; echo \"result: \u003cbr/\u003e\u0026emsp;\".$result.\"\u003chr/\u003e\"; } ?\u003e 2 提交结果 ","date":"2019-09-28","objectID":"/posts/phppushurl/:0:0","tags":["PHP"],"title":"php 同时主动推送链接到百度，神马等站长平台","uri":"/posts/phppushurl/"},{"categories":["PHP"],"content":"13 普通方法 首先采用fopen()函数打开文件，得到返回值的就是资源类型。接着采用 while 循环一行行地读取文件，然后输出每行的文字。feof()判断是否到最后一行，fgets()读取一行文本。 \u003c?php //首先采用“fopen”函数打开文件，得到返回值的就是资源类型。 $file_handle = fopen(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\备忘录。txt\",\"r\"); if ($file_handle){ //接着采用 while 循环一行行地读取文件，然后输出每行的文字 while (!feof($file_handle)) { //判断是否到最后一行 $line = fgets($file_handle); //读取一行文本 echo $line; //输出一行文本 echo \"\u003cbr /\u003e\"; //换行 } } fclose($file_handle);//关闭文件 ?\u003e readfile（）函数，返回一整个 String echo readfile(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\备忘录。txt\"); 14 快速方法 file()函数把整个文件读入一个数组中。 数组中的每个元素都是文件中相应的一行，包括换行符在内。 语法 file(path,include_path,context) 参数 描述 path 必需。规定要读取的文件。 include_path 可选参数include_path 可以是以下一个或多个常量：**FILE_USE_INCLUDE_PATH在 include_path 中查找文件。FILE_IGNORE_NEW_LINES在数组每个元素的末尾不要添加换行符FILE_SKIP_EMPTY_LINES**跳过空行 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 NULL，则忽略。 \u003c?php $filepath=\"H:\\\\lruihao.cn\\\\public\\\\baidu_urls.txt\"; echo \"\u003chr/\u003e\"; //将文件每一行读到一个数组里面去 $texts = file($filepath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); var_dump($texts); ?\u003e 15 结果 ","date":"2019-09-28","objectID":"/posts/phpfile/:0:0","tags":["PHP"],"title":"php 按行读取文件信息","uri":"/posts/phpfile/"},{"categories":["GitHub"],"content":"Lruihao/MMT: 沐目之，湘也。— 沐目体","date":"2019-09-26","objectID":"/projects/lruihao/mmt/","tags":["font","mmt"],"title":"沐目之，湘也。— 沐目体","uri":"/projects/lruihao/mmt/"},{"categories":["GitHub"],"content":" 关于沐目体 ","date":"2019-09-26","objectID":"/projects/lruihao/mmt/:0:0","tags":["font","mmt"],"title":"沐目之，湘也。— 沐目体","uri":"/projects/lruihao/mmt/"},{"categories":["JavaScript"],"content":" 使用javascript计算博客等网站的运行时间。 话不多说，直接贴码！ function createTime() { var now = new Date(); var run = new Date('05/28/2018 20:01:01'); //總的秒數 var runTime = (now - run) / 1000, days = Math.floor(runTime / 60 / 60 / 24), hours = Math.floor(runTime / 60 / 60 - 24 * days), minutes = Math.floor(runTime / 60 - 24 * 60 * days - 60 * hours), seconds = Math.floor((now - run) / 1000 - 24 * 60 * 60 * days - 60 * 60 * hours - 60 * minutes); //前置零 if (String(hours).length === 1) { hours = '0' + hours; } if (String(minutes).length === 1) { minutes = '0' + minutes; } if (String(seconds).length === 1) { seconds = '0' + seconds; } /*document.querySelector(\".run-times\").innerHTML = days + \"\u0026thinsp; 天\u0026thinsp;\" + hours + \"\u0026thinsp; 时\u0026thinsp;\" + minutes + \"\u0026thinsp; 分\u0026thinsp;\" + seconds + \"\u0026thinsp; 秒\"; */ document.querySelector('.run-times').innerHTML = 'RunTime: ' + days + ',' + hours + ':' + minutes + ':' + seconds + ''; } //setInterval(\"createTime()\", 500); if (!document.hidden) { var siteTime = setInterval('createTime()', 500); } else { clearInterval(siteTime); } /** * HTML 写法 \u003cspan class=\"run-times\" title=\"网站运行时间\"\u003e载入时分秒 ...\u003c/span\u003e \u003cp class=\"run-times\" title=\"主頁运行时间\"\u003eRunTime Loading...\u003c/p\u003e */ ","date":"2019-09-19","objectID":"/posts/site-time/:0:0","tags":["JavaScript"],"title":"设置网站运行时间","uri":"/posts/site-time/"},{"categories":["JavaScript"],"content":" 注意 JS 的加载分为两个部分：下载和执行。 浏览器在执行 HTML 的时候如果遇到\u003cscript\u003e时会停止页面的渲染，去下载和执行 js 的文件直接遇见\u003c/scirpt\u003e会继续渲染页面。故浏览器在执行 js 文件的时候浏览器表现为一片空白，为了解决这个问题 ECMAScript 定义了 defer 和 async 两个属性用于控制 JS 的下载和执行。 1 不带任何属性 同步模式，又称阻塞模式，我们平时使用的最多的一种方式。当浏览器解析到\u003cscript\u003e标签时，浏览器会停止解析其后的内容，而优先下载脚本文件，并执行其中的代码，是个同步阻塞的过程。 一般建议把\u003cscript\u003e标签放在\u003cbody\u003e结尾处，这样尽可能减少页面阻塞。 而如果想要异步执行 script，则可以给其加上 async 或 defer 属性。 \u003cscript\u003e 2 defer defer 属性在 HTML 解析期间异步下载文件，并且只在 HTML 解析完成后才执行它。对于 defer，我们可以理解是将外链的 js 放在了页面底部。js 的加载不会阻塞页面的渲染和资源的加载。不过 defer 会按照原本的 js 的顺序执行，所以如果前后有依赖关系的 js 可以放心使用。 \u003cscript defer\u003e 3 async async 属性会在 HTML 解析期间异步下载文件，并在完成下载后立即暂停 HTML 解析器去执行 script 中的代码。在执行过程中浏览器处于阻塞状态，响应不了任何需求。如果 js 前后有依赖性，用 async，就很有可能出错。 \u003cscript async\u003e 4 区别 4.1 相同点 加载文件时不阻塞页面渲染 对于 inline 的 script 无效（只适用有src的外部 js） 使用这两个属性的脚本中不能调用 document.write 方法 有脚本的 onload 的事件回调 4.2 区别点 html4.0 中定义了 defer；html5.0 中定义了 async 浏览器支持不同 每一个 async 属性的脚本都在它下载结束之后立刻执行，同时会在 window 的 load 事件之前执行。所以就有可能出现脚本执行顺序被打乱的情况；每一个 defer 属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在 document 的 DOMContentLoaded 之前执行。 5 那么这三种方式各在什么情况下使用呢？ 通常来说，尽可能使用async，然后是defer，最后不使用属性。 并遵循以下规则： 如果脚本是模块化的，并且不依赖于任何脚本，则使用async。 如果脚本依赖于或依赖于另一个脚本，则使用defer。 如果脚本很小并且有async脚本依赖该脚本，则不加属性。 6 兼容性 Internet Explorer 10、Firefox、Opera、Chrome 和 Safari 支持 async 属性。 所有主流浏览器都支持 defer 属性。 7 参考 https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html https://www.jianshu.com/p/17dc82bf08f1 ","date":"2019-09-08","objectID":"/posts/async-defer/:0:0","tags":["JavaScript","defer","async"],"title":"script 的三种加载方式 (async, defer)","uri":"/posts/async-defer/"},{"categories":["Memo"],"content":"Sublime Text3 快捷键一览表 1 tab 转 space 打开 Settings, 加入几行配置 { \"color_scheme\": \"Packages/Color Scheme - Default/Monokai.sublime-color-scheme\", \"font_size\": 14, \"ignored_packages\": [ \"Vintage\" ], \"theme\": \"Adaptive.sublime-theme\", + \"expand_tabs_on_save\": true, + \"tab_size\": 2, + \"translate_tabs_to_spaces\": true } 2 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 3 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的 CSS 属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 4 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是 sublime 允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+：打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用 sublime text 或插件的功能，例如使用 package 安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 5 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1 窗口分屏，恢复默认 1 屏（非小键盘的数字） Alt+Shift+2 左右分屏 -2 列 Alt+Shift+3 左右分屏 -3 列 Alt+Shift+4 左右分屏 -4 列 Alt+Shift+5 等分 4 屏 Alt+Shift+8 垂直分屏 -2 屏 Alt+Shift+9 垂直分屏 -3 屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 ","date":"2019-08-15","objectID":"/posts/sublime-text3/:0:0","tags":["Sublime","他山之石"],"title":"Sublime Text3 快捷键大全","uri":"/posts/sublime-text3/"},{"categories":["Memo"],"content":"13 安裝 官方下載點 14 擴充功能 14.1 安裝擴充功能 下載擴充套件包 官方套件庫 或者在 NetBeans IDE 裏面下載插件（方便） 開啟 NetBeans→Tools→Plugins→Downloaded→Add Plugins 選擇要安裝的擴充套件包 14.2 啟用已安裝的擴充功能 開啟 NetBeans→Tools→Plugins→Installed 選擇要啟用的套件 (*.npm) 點擊 Activate 14.3 匯入設定 開啟 NetBeans→Tools→Options 點擊 Import 匯入設定 選擇要匯入的套件包 (*.zip) 15 常用設定 15.1 程式碼排版 在程式開發中，程式碼排版很重要。一個好的排版利於開發人員程式閱讀，也便於後期維護人員閱讀。 在 NetBeans 中設置程式碼排版 打開 NetBeans-\u003eTools-\u003eOptions-\u003eEditor-\u003eFormatting； Language 選擇 All Languages，勾選\"Expand Tabs to Spaces\", 用兩個空格鍵代替 Tab 鍵，首行留兩個 Tab 鍵。 點擊 Apply 或 Ok 完成設置。具體設置及效果如下圖所示： 15.2 程式碼樣板 程式碼樣板可以幫助你快速書寫程序，不必繁瑣地聲明函數或其他代碼塊，更專注與邏輯的書寫。 在 NetBeans 中設置程式碼樣板 打開 NetBeans→Tools→Options→Editor→Code Templates； 選擇你所用的語言（這裡以 JavaScript 為例）； 點擊\"New\"新建屬於你的或修改原有的程式碼樣板（例子僅為演示）； 在編程中應用它。 15.3 前端壓縮 下載擴充套件netbeans minify 或者 minifierBeans 開啟 NetBeans→Tools→Plugins→Downloaded→Add Plugins 選擇你下載的擴充套件開啟 開啟 NetBeans→Tools→options 15.4 快捷鍵 键位 作用 Ctrl+/ 注释一行（或选中部分） Ctrl+X 剪切一行（或选中部分） Ctrl+E 删除一行（或选中部分） Shift+Alt+上下方向键 移动当前行 Ctrl+Shift+上下方向键 复制当前行（该操作并非复制到粘贴板） Shift+Alt+F 整理代码 TAB 代碼自動補全/缩进/選中文字同時缩进 Shift+TAB 選中文字同時取消缩进 Ctrl+F 查找某个字 Ctrl+Shift+F 整个项目中查找某个字 Ctrl+H 替换某个字 Ctrl+Enter 增加空白行，光标不动。 Ctrl+(0~7) 打开各种小窗口 Shift+方向键 選中文字 Ctrl+Alt+Space 代码输入提示，不习惯的可以设置为 (Alt+/)，超级好用！！！ Ctrl+Shift+F5 调试当前程序 Shift+F6 运行当前程序 F6 运行主程序 Alt+Enter 显示程式 bug 建议或者警示等 NetBeans 中常用的快捷鍵 ↑： 三種複製行方法 复制一行：Ctrl + Shift + 上下方向键（该操作并非复制到粘贴板）； 复制一行：在该行任何地方连续三击选中一样，然后 Ctrl + C 即可复制一行。； 复制一行（使用宏）: 编辑 - 开始录制宏 (Home,Shift + End,Ctrl + C)-停止录制宏 - 设置宏名称（如 select-entire-line)-设置快捷键（如 Ctrl + Alt + C)； 也可自己修改快捷鍵 (Tools→Options→Keympa), 如下圖 {% asset_img quickkey.png quickkey %} 15.5 遠程開發 (FTP) 工作为例 新建项目 打开软件，进入新建项目页面（File-New Project），新建 php 项目，选择第一个（PHP-PHP Application） 项目名和地址自己选择（注意，选择地址后需在地址最后面加上\"/项目名\"） FTP 设置 点击下一步，进入 FTP 设置，Run As 选择 Remote Web Site(FTP,SFTP) Project URL 填写http://127.0.0.1/training/工号 Manage 设置 点击 Manage, 进入页面。名字自取。Host Name 填写：127.0.0.1 Encryption 选择 Pure FTP,User Name 和 Password（填写工号/课务系统登录密码） Initial Directory 填写_training 点击 Test Connection 测试是否连接成功 其他设置 Upload Directory, 上传目录不填，直接上传至个人根目录 Upload File 改为保存时上传文件（On Save） 15.6 Chrome with NetNeans Connector 打開 chrome 中的應用程式商店（使用 chrome 瀏覽器點擊下方鏈接即可） chrome 應用程式商店 在搜索框中輸入 NetNeans Connector 后搜索，然後點擊右邊的加到 Chrome 即可，安裝成功后右上角會顯示 NetBeans 圖標。 開啟 netbeans 選擇 Run→Set Project Browser→ 選中 Chrome with NetBeans Connector 選擇 default 下的 Customize → 選擇 Browser → 選擇 Browser 下 Chrome with NetBeans Connector 即可 ","date":"2019-08-15","objectID":"/posts/netbeans/:0:0","tags":["NetBeans","PHP"],"title":"NetBeans IDE 开发设置","uri":"/posts/netbeans/"},{"categories":["Spec"],"content":"61 精神 绝不写死代码，硬编码 不留不要用的、垃圾代码 62 Git Master 的 BUG 必须最少且趋近于零，为最稳定的版本 每次 Commit 信息应该准确填写。不可模棱两可，eg: 修复 BUG、增加功能 禁止 Commit IDE 的 project data，e.g: .vscode 禁止上传垃圾代码 更多规则详见文档 Commit 规范 62.1 分支（Branch） 命名规则：应以此分支主要目的命名（修复什么 BUG，新增特定功能） 合并后的分支应该删除 62.2 commit 遵循一个功能一个 commit 的原则 63 Restful 资源名词站在 API 的角度思考 复数名词：可以复数笔数据，回传结果为 Array 举例：GET/users 取得多笔使用者资料 刪除，放在复数名词內，让 Router 保持一致性 增加，放在复数名詞內，让 Router 保持一致性 单数名词：仅取得单笔数据，必须指定 PK，两两一组，回传结果为 Object 举例：GET/user/{accont} 取得单笔使用者资料，必须指定 PK URL 中一律不带 id 参数 正确范例： calendar_manager/calendar/29 错误范例： calendar_manager/calendar/29?id=29 更多规则详见文档 RESTful 64 命名 命名应根据内容做有意义的命名，让后续维护人员可以顾名思义！ 即使不会发生错误，代码英文大小写也需明确区分。 64.1 语意 类型 命名规则 说明 属性 (Attribute, Property) 名词 user_name、userName 方法 (Method, Function) 动词 + 名词 getUserName、get_user_name 常見的动词有：get、set、update、delete、remove 64.2 字母与分隔 语言 变量 (Variable, Parameter, Argument) 常量 (Constant) 面向对象 - 类名 (Class Name) 面向对象 - 成员 (mebmer) HTML 全部小写，不同单词以「-」分隔 e.g: user-id CSS、SCSS 全部小写，不同单词以「-」分隔，CSS 变量以「–」开头，SCSS 变量以「$」开头 e.g: .user-id、–header-height、$header-height JavaScript 驼峰式命名法 首字小写，不同单字「首字以大写」分隔 e.g: userId 全部大写，不同单字以「_」分隔 MAX_COUNT 驼峰式命名法 首字大写，不同单字「首字以大写」分隔 一个文件放一个 Class, 文件名即为 Class Name e.g: User 驼峰式命名法 公有 (public) : 首字小写，不同单词「首字以大写」分隔 e.g: name, getName 私有 (private): _公有命名规则 e.g: _name,_getName Vue Java PHP 全部小写，不同单词以「_」分隔 e.g: user_id Python SQL 由使用者定义的：表名、字段名 全部小写，不同单词以「_」分隔 SQL 语法、函数全部大写 e.g: SELECT、INSERT INTO 65 通用 代码编写 每个函数应该使用块注释，注释应包含函数功能说明、参数说明。规则见：JSDoc、JavaDoc 不必要的代码不要写，也应禁止放到注释里面！ if-else 的 {} 严禁省略 代码规范、代码排版等可通过 eslint 等工具做统一处理 65.1 正确写法 public function test () { // do something if (a === b) { // do something } } 66 错误写法 public function test () { // do something if (a === b) { // do something } } 代码排版 任何代码应该以 2 个 space 为一个缩进做好排版、不可使用 tab 函数 (Function, Methd) 函数声明时需在函数上方加上函数注释，注释应包含函数说明、参数内容（参数类型、参数英文名称、参数说明）、返回值内容（返回值类型、返回值说明） 类 (Class) 一个类（Class）的声明只能存在一个文件 类（Class）的声明文件，文件名必须为类名 其他 连接本地任何其他资源（图片、文件、网站）皆使用相对路径，禁止使用绝对路径，非本地资源除外 67 HTML 67.1 代码编写 禁止在 HTML 使用 \u003cstyle\u003e、\u003cscript\u003e，一律使用外部档案引用方式引用 CSS、JavaScript 文件 HTML 标签需成双成对，有头有尾 块级标签：\u003ctag\u003e\u003c/tag\u003e 单标签：\u003ctag /\u003e 禁止使用已被 HTML 舍弃的旧标签、属性，如： \u003c!-- html tag --\u003e \u003ccenter\u003e \u003cfont\u003e \u003cbasefont\u003e \u003cs\u003e \u003cstrike\u003e \u003cu\u003e \u003clisting\u003e \u003cplaintext\u003e \u003cxmp\u003e \u003c!-- html attribute --\u003e align bgcolor color 68 CSS CSS 的定义应该独立一个 CSS 文件，禁止使用 \u003cstyle\u003e 或 style 属性直接在 HTML 中定义样式。 69 JavaScript 禁止使用 HTML 字串，一律使用 Dom 产生 HTML, e.g: document.createDocumentFragment() 69.1 注释 JavaScript 注释应该遵循 JSDoc 的标准撰写 69.1.1 全局变量 (Global) /* global ZT */ 69.1.2 常量 (Constant) /** * 常量說明 * @type {常量类型} */ Example /** * 请求地址 * @type {String} */ const REQUEST_URL = 'http://localhost:8080'; 69.1.3 函數、方法 (Function, Method) /** * 函数用途说明 * @param {参数类型} 参数名称参数说明 * @param {参数类型} [选择性参数名称] 参数说明 * @param {参数类型} [选择性参数名称=参数预设值] 参数说明 * @returns {返回值类型} 返回值说明 */ Example /** * 取得使用者 * @param {Int} userId 使用者 ID * @param {Object} [options] 其他选项 * @param {String} [options.query='a'] 查询关键词 默认为 'a' * @returns {Object} 使用者资料 */ function getUser(userId, options) { // do something return user; } 70 Vue 待补充 71 Java Java 注释应该遵循 JavaDoc 的标准撰写 待补充 72 PHP 72.1 前端参数取得 参数取得需通过 filter_input 函数取得，不得使用 _GET、_POST 72.2 输出到前台 参数命名必须为：全部小写，不同单字以「_」分隔 72.3 注解 PHP 注解应该遵循 PHPDoc 的标准撰写 72.4 成员变量 (Member) 成员变量只的是 Class 内的成员变数，我们都会要求替成员变量增加注解说明。通常 Function 的变量除非太特别否则都不需要特别注解说明。 /** * 成员变量說明 * @type {类型} */ Example /** * 使用者 ID * @type {String} */ $userId = 'Hello'; 72.5 函数、方法 (Function, Method) /** * 函数用途说明 * @param 参数型态 参数名称 参数说明 * @option 参数选项类型 参数选项名称 参数选项说明 * @uses 全局变量 全域变数说明 * @returns 返回值类型 返回值说明 */ Example /** * 取得使用者 * @param int userId 使用者 ID * @param object options 其他选项 * @option string options['query'] 查询关键字 * @uses $_POST['role_id'] 从前端以 POST 取得角色 ID * @returns object 使用者资料 */ function getUser ($userId, $options) { // do something return $user; }; 73 Python 待补充 74 Database 禁止使用 Table Join。 禁止使用 Oracle Trigger。 禁止将查询数据库的 SQL 放在循环中查询 74.1 SQL 撰写 属于 SQL 语法使用大写（SELECT，WHERE，INSERT etc..） 属于使用者自己定义的使用小写（表名 table name，字段名 column name etc..） 表名、字段名前后需加上 ` Example INSERT INTO `user` VALUES('a', 'b'); 75 统一","date":"2019-08-15","objectID":"/posts/dev-rules/:0:0","tags":["CSS","Git","HTML","Java","JavaScript","PHP","Python","REST","Scss"],"title":"Web 开发规则，代码规范","uri":"/posts/dev-rules/"},{"categories":["PHP"],"content":" 简单模仿了一个评论模板，当然肯定是没有博客的 valine 这么强大的 hhhh， PHP 表单安全性的重要提示 $_SERVER[\"PHP_SELF\"]变量能够被黑客利用！ 如果页面中使用了PHP_SELF，用户能够输入下划线然后执行跨站点脚本（XSS）。 比如说注入 js 脚本等，valine 以前的版本也有过这样的漏洞。 跨站点脚本（Cross-site scripting，XSS）是一种计算机安全漏洞类型，常见于 Web 应用程序。XSS 能够使攻击者向其他用户浏览的网页中输入客户端脚本。 可以像 valine 一样在用户输入完后保留输入，还有一些正则控制输入提示等简单功能。UI 就丑爆了算了。 \u003c!DOCTYPE HTML\u003e \u003chtml\u003e \u003chead\u003e \u003cstyle\u003e .error {color: #FF0000;} .main{ width: 20%; height: 100%; border: 1px #000 solid; padding: 20px; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003c?php // 定义变量并设置为空值 $nameErr = $emailErr = $genderErr = $websiteErr = \"\"; $name = $email = $gender = $comment = $website = \"\"; if ($_SERVER[\"REQUEST_METHOD\"] == \"POST\") { if (empty($_POST[\"name\"])) { $nameErr = \"Name is required\"; } else { $name = test_input($_POST[\"name\"]); // 检查名字是否包含字母和空格 if (!preg_match(\"/^[a-zA-Z ]*$/\",$name)) { $nameErr = \"Only letters and white space allowed\"; } } if (empty($_POST[\"email\"])) { $emailErr = \"Email is required\"; } else { $email = test_input($_POST[\"email\"]); // 检查电邮地址语法是否有效 if (!preg_match(\"/([\\w\\-]+\\@[\\w\\-]+\\.[\\w\\-]+)/\",$email)) { $emailErr = \"Invalid email format\"; } } if (empty($_POST[\"website\"])) { $website = \"\"; } else { $website = test_input($_POST[\"website\"]); // 检查 URL 地址语言是否有效（此正则表达式同样允许 URL 中的下划线） if (!preg_match(\"/\\b(?:(?:https?|ftp):\\/\\/|www\\.)[-a-z0-9+\u0026@#\\/%?=~_|!:,.;]*[-a-z0-9+\u0026@#\\/% =~_|]/i\",$website)) { $websiteErr = \"Invalid URL\"; } } if (empty($_POST[\"comment\"])) { $comment = \"\"; } else { $comment = test_input($_POST[\"comment\"]); } if (empty($_POST[\"gender\"])) { $genderErr = \"Gender is required\"; } else { $gender = test_input($_POST[\"gender\"]); } } function test_input($data) { $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data); return $data; } ?\u003e \u003cdiv class=\"main\"\u003e \u003ch2\u003ePHP 验证实例\u003c/h2\u003e \u003cform method=\"post\" action=\"\u003c?php echo htmlspecialchars($_SERVER['PHP_SELF']);?\u003e\"\u003e 姓名：\u003cinput type=\"text\" name=\"name\" value=\"\u003c?php echo $name;?\u003e\"\u003e \u003cspan class=\"error\"\u003e* \u003c?php echo $nameErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 性别： \u003cinput type=\"radio\" name=\"gender\" \u003c?php if (isset($gender) \u0026\u0026 $gender==\"女性\") echo \"checked\";?\u003e value=\"女性\"\u003e女性 \u003cinput type=\"radio\" name=\"gender\" \u003c?php if (isset($gender) \u0026\u0026 $gender==\"男性\") echo \"checked\";?\u003e value=\"男性\"\u003e男性 \u003cspan class=\"error\"\u003e* \u003c?php echo $genderErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 电邮：\u003cinput type=\"text\" name=\"email\" value=\"\u003c?php echo $email;?\u003e\"\u003e \u003cspan class=\"error\"\u003e* \u003c?php echo $emailErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 网址：\u003cinput type=\"text\" name=\"website\" value=\"\u003c?php echo $website;?\u003e\"\u003e \u003cspan class=\"error\"\u003e\u003c?php echo $websiteErr;?\u003e\u003c/span\u003e \u003cbr\u003e\u003cbr\u003e 评论：\u003ctextarea name=\"comment\" rows=\"5\" cols=\"40\"\u003e\u003c?php echo $comment;?\u003e\u003c/textarea\u003e \u003cbr\u003e\u003cbr\u003e \u003cinput type=\"submit\" name=\"submit\" value=\"提交\"\u003e \u003ch2\u003e你的输入是：\u003c/h2\u003e \u003c?php echo $name.\"\u003cbr/\u003e\"; echo $gender.\"\u003cbr/\u003e\"; echo $email.\"\u003cbr/\u003e\"; echo $website.\"\u003cbr/\u003e\"; echo $comment.\"\u003cbr/\u003e\"; ?\u003e \u003cbr/\u003e \u003c/form\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2019-07-19","objectID":"/posts/phpform/:0:0","tags":["PHP"],"title":"简单评论模块--php 表单练习","uri":"/posts/phpform/"},{"categories":["PHP"],"content":" 练习 php 函数的基本使用。 注： 必选参数在可选参数的前面。 可在函数中定义函数，需要先调用外层函数才能调用内层函数。 \u003c?php /* 创建表格 */ function createTable($rows,$cols,$bgcolor='pink',$content='x'){ $table = \"\u003ctable border='1' bgcolor='{$bgcolor}' cellpadding='10' cellspacing='0' width='50%' \u003e\"; for($i=1;$i\u003c=$rows;$i++){ $table.=\"\u003ctr\u003e\"; for($j=1;$j\u003c=$cols;$j++){ $table.=\"\u003ctd\u003e{$content}\u003c/td\u003e\"; } $table .=\"\u003c/tr\u003e\"; } $table.=\"\u003c/table\u003e\"; return $table; } echo createTable(5,5,'pink','hello lruihao'); ?\u003e ","date":"2019-07-15","objectID":"/posts/phpfunc/:0:0","tags":["PHP"],"title":"php 函数学习","uri":"/posts/phpfunc/"},{"categories":["Memo"],"content":" 使用 WAMPServer 时自定义网站根目录。 1 WAMPServer 自定义网站根目录 1.1 修改 apache 配置文件 打开httpd.conf文件搜索documentroot后，找到路径修改为自定义的。 再打开httpd-vhost.conf文件修改对应的路径。 修改完配置文件需要重启所有服务！ 1.2 修改 wampmanager 文件 在 wampserver 安装路径根目录知道wampmanager.ini和wampmanager.tpl两个文件。搜索menu.left, 然后也修改为自定义的路径。 然后退出，重启软件！ 1.3 编写 php 文件测试 \u003c?php echo \"hello world\"; ?\u003e 2 WAMPServer 多站点配置 打开httpd-vhost.conf文件，复制原有的几行配置文件，粘贴修改路径和域名等配置。比如 ## Virtual Hosts # \u003cVirtualHost *:80\u003e ServerName localhost ServerAlias localhost DocumentRoot \"g:/Demo\" \u003cDirectory \"g:/Demo\"\u003e Options +Indexes +Includes +FollowSymLinks +MultiViews AllowOverride All Require local \u003c/Directory\u003e \u003c/VirtualHost\u003e \u003cVirtualHost *:80\u003e ServerName test01.com DocumentRoot \"g:/Demo/test01\" \u003c/VirtualHost\u003e \u003cVirtualHost *:80\u003e ServerName test02.com DocumentRoot \"g:/Demo/test02\" \u003c/VirtualHost\u003e 再打开C:\\Windows\\System32\\drivers\\etc\\hosts文件，在文件最后添加类似于云服务器的域名解析，进行本地域名解析，当输入域名时优先从本地申请资源。 ... ## For example: # ## 102.54.94.97 rhino.acme.com ## source server ## 38.25.63.10 x.acme.com ## x client host ## localhost name resolution is handled within DNS itself. # 127.0.0.1 localhost # ::1 localhost 127.0.0.1 steamcommunity.com 192.168.28.1 windows10.microdone.cn 127.0.0.1 localhost ::1 localhost 127.0.0.1 test01.com 127.0.0.1 test02.com 3 WAMPServer 自拟定端口 WAMP 服务我安装了好几次，每次因为修改配置文件搞崩了。第一次装的时候发现 80 端口被占用了，因为以前玩了一下 Windows 的 IIS，暂停 IIS 的网站，再使用命令或者直接在控制面板关掉就好了。 如果不使用 80 多为默认端口，比如修改为 8080，还是在httpd.conf文件里修改。搜索80都改成8080然后，Ctrl+S 保存，重新启动 WampServer 在浏览器地址栏输入localhost:8000 #监听端口 Listen 0.0.0.0:8080 Listen [::0]:8080 ServerName localhost:8080 使用 Notepad++打开 C:\\wamp 目录下的 wampmanager.ini 和 wampmanager.tpl Ctrl+F 查找 localhost 将其全部替换为localhost:8000 然后，Ctrl+S 保存，重新启动 WampServer ","date":"2019-07-12","objectID":"/posts/wamproot/:0:0","tags":["WAMP","PHP","windows","server"],"title":"WAMPServer 自定义网站根目录等设置","uri":"/posts/wamproot/"},{"categories":["Python"],"content":" 后面几天讲的有点杂，简单记录一下知识点。 13 6.19 这些知识点在课上都只是简单的提到了一下。 比如一些库的使用与安装都不会再课上详细讲解，需要课后再去研究。 13.1 切片操作 列表切片操作 13.2 字符串 13.2.1 python 原始字符串 print(r\"D:\\three\\two\") 13.2.2 长字符串 用三个单引号或者双引号包裹，前后呼应，成双成对。 13.2.3 用、换行字符表示字符未结束 13.3 格式化输出 format \"=={}==\"，{}表示占位符，其前后字符保持原样输出。 #TempConvert.py TempStr = input(\"请输入带有符号的温度值：\") if TempStr[-1] in ['F','f']: C = (eval(TempStr[0:-1]) - 32)/1.8 print(\"转换后的温度是{:.2f}C\".format(C)) elif TempStr[-1] in ['C','c']: F = 1.8*eval(TempStr[0:-1]) + 32 print(\"转换后的温度是{:.2f}F\".format(F)) else: print(\"输入格式错误\") 13.4 多变量赋值与交换（斐波那契数列） python 3.x 版本 end=\"\" 可使输出不换行 print(x, end=\"\") #斐波那契数列 a, b = 1,1 while a \u003c 500: ## 输出不大于 500 的序列 print(a,end=\",\") a,b = b,a + b #交换变量 13.5 笑傲江湖统计字符 (dict, 文件流） 统计《笑傲江湖》小说中出现的所有中文字符及标点符号的数量，每个字符及数目间用冒号:隔开，例如\"笑：1024\"，将所有字符及数量的对应采用逗号分隔，以 CSV 文件格式保存到“笑傲江湖--字符统计。txt”文件中。注意，统计字符不包括空格和回车。 csv 文件格式： ‘,’逗号连接元素 fi = open(\"data/笑傲江湖 - 网络版。txt\",\"r\",encoding=\"utf-8\") fo = open(\"data/笑傲江湖 - 字符统计。txt\",\"w\",encoding=\"utf-8\") txt = fi.read() #打开文件 #txt d = {} for c in txt: d[c] = d.get(c,0)+1 del d[' '] #删除字典中的空格和回车的键值对 del d['\\n'] ls = [] for key in d: ls.append(\"{}:{}\".format(key,d[key])) fo.write(\",\".join(ls)) fi.close() fo.close() 13.6 numpy 模块 … 13.7 pandas 模块 … 14 6.20 14.1 matplotlib 绘图 import matplotlib.pyplot as plt import numpy as np x = np.arange(-5,5,0.01) y = 2**x+1 plt.plot(x,y) plt.title(\"y=2^x+1\",fontsize=24) plt.xlabel(\"X\",fontsize=14) plt.ylabel(\"Y\",fontsize=14) plt.tick_params(axis=\"both\",labelsize=14) plt.show() 14.2 爬虫 举了一个金融界，炒股，获取数据的爬虫 （今天没仔细听课，这数据爬过什么意思，咱不懂，咱也不敢问！） #! /usr/bin/env python #-*- encoding: utf-8 -*- #author pythontab.com import numpy as np import matplotlib.pyplot as plt import pandas as pd import pandas_datareader.data as web import datetime #import tushare as ts df_stockload = web.DataReader(\"000001.SS\", \"yahoo\", datetime.datetime(2017,1,1), datetime.date.today()) #print(type(datetime.datetime.now().strftime('%Y-%m-%d'))) #df_stockload = ts.get_hist_data('sh',start='2017-01-01',end=datetime.datetime.now().strftime('%Y-%m-%d')) print (df_stockload.columns)#查看列名 print (df_stockload.index)#查看索引 print (df_stockload.describe())#查看各列数据描述性统计 #绘制移动平均线 df_stockload.Close.plot(c='b') df_stockload.Close.rolling(window=30).mean().plot(c='r') #pd.rolling_mean(df_stockload.Close,window=30).plot(c='r') df_stockload.Close.rolling(window=60).mean().plot(c='g') #pd.rolling_mean(df_stockload.Close,window=60).plot(c='g') plt.legend(['Close','30ave','60ave'],loc='best') plt.show() Index(['High', 'Low', 'Open', 'Close', 'Volume', 'Adj Close'], dtype='object') DatetimeIndex(['2017-01-03', '2017-01-04', '2017-01-05', '2017-01-06', '2017-01-09', '2017-01-10', '2017-01-11', '2017-01-12', '2017-01-13', '2017-01-16', ... '2019-06-05', '2019-06-06', '2019-06-10', '2019-06-11', '2019-06-12', '2019-06-13', '2019-06-14', '2019-06-19', '2019-06-20', '2019-06-21'], dtype='datetime64[ns]', name='Date', length=596, freq=None) High Low Open Close Volume \\ count 596.000000 596.000000 596.000000 596.000000 5.960000e+02 mean 3076.147753 3039.201569 3056.960338 3060.169056 5.098201e+06 std 269.276147 273.757358 271.612122 272.072346 1.199107e+08 min 2488.479004 2440.906982 2446.019043 2464.363037 8.820000e+04 25% 2845.308228 2800.168762 2825.239502 2827.754822 1.375250e+05 50% 3153.184937 3118.613525 3134.300537 3139.085449 1.666500e+05 75% 3280.115234 3244.825256 3265.322021 3268.600342 2.091250e+05 max 3587.031982 3534.195068 3563.639893 3559.465088 2.927580e+09 Adj Close count 596.000000 mean 3060.169056 std 272.072346 min 2464.363037 25% 2827.754822 50% 3139.085449 75% 3268.600342 max 3559.465088 15 6.21 15.1 类 比第一天稍微仔细一点讲了一下类，有点需要注意： self相当于this表示当前对象 python 类的所有函数的第一个参数都要写self参数，self 也可以是其他的比如lrh等字符替代，但是必须保持一致。 __表示私有的 class 的定义可以不加 (),() 内可写继承的父类 15.2 GUI 设计 wxPython pip install wxPython import wx import wx #导入 wxPython 库 class Panel(wx.Panel): def __init__(self,parent): wx.Panel.__init__(self,parent=parent, id=-1) pass class Frame(wx.Frame): def __init__(self): wx.Frame.__init__(self, parent = None, tit","date":"2019-06-21","objectID":"/posts/pysx2/:0:0","tags":["Python"],"title":"python 实训总结Ⅱ","uri":"/posts/pysx2/"},{"categories":["Python"],"content":" 以前和前一段时间自己也学习了一下 python，也写了几个小爬虫； 这次正好又课程安排了为期两周的综合实训，主要是“用 python 做量化交易” 进行了两天，讲的都是一些基本的东西，以前也接触过，所以很容易理解。还讲了一些软件，pycharm，anaconda,sublime 等大都也都用过。anaconda 倒是第一次接触。 1 6.17 print(\"Hello World!\") 讲了一下变量和 python 的特色什么的。 还讲了模块定义def和类定义 class zxm(): def __init__(self): self.x=0 self.y=0 def move_up(self): self.y +=1 my_zxm=zxm() print(my_zxm) \u003c__main__.zxm object at 0x000001D99CFEF668\u003e 2 6.18 2.1 输入输出 print 输出 input 输入 eval 执行一个字符串表达式，并返回表达式的值 x=eval(input(\"请输入 x 的值：\")) y=eval(input(\"请输入 y 的值：\")) z=(x**2+y**2)**0.5 print(z) # 导入复数数学模块 import cmath num = int(input(\"请输入一个数字：\")) num_sqrt = cmath.sqrt(num) print('{0} 的平方根为 {1:0.3f}+{2:0.3f}j'.format(num ,num_sqrt.real,num_sqrt.imag)) 2.2 数据类型 今天还讲了一下数据类型 字符串： \"\" '' 元组 tuple(2,3) 列表 list[2,3] 字典 dict{Key:Value} 集合{} x=[1,10] type(x)#判断元素类型 list 2.3 循环判断 for x in range(1,10,2): # (start,stop,step) pass # pass 不做任何事情，一般用做占位语句 for letter in 'Python': if letter == 'h': pass print('这是 pass 块') print('当前字母 :'+ letter) print(\"Good bye!\") 当前字母 :P 当前字母 :y 当前字母 :t 这是 pass 块 当前字母 :h 当前字母 :o 当前字母 :n Good bye! 2.4 str() 、import 导库 x=10 print(\"整数转字符串\"+str(x)) import this The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! Google 翻译意思是： 美丽胜过丑陋。显式优于隐式。简单比复杂更好。复杂比复杂更好。Flat 优于嵌套。稀疏优于密集。可读性很重要。特殊情况不足以打破规则。虽然实用性胜过纯洁。错误不应该默默地传递。除非明确沉默。面对模棱两可，拒绝猜测的诱惑。应该有一个最好只有一个明显的方法来做到这一点。虽然这种方式起初可能并不明显，除非你是荷兰人。现在比永远好。虽然现在永远不会比正确好。如果实施很难解释，这是一个坏主意。如果实现很容易解释，那可能是个好主意。命名空间是一个很棒的主意，让我们做更多的事情吧！ 2.5 turtle 绘图库（内置模块） ","date":"2019-06-18","objectID":"/posts/pysx1/:0:0","tags":["Python","turtle"],"title":"python 实训总结Ⅰ","uri":"/posts/pysx1/"},{"categories":["Grocery"],"content":" 黑盒测试着重测试软件功能，它并不涉及程序的内部结构和内容特性，主要根据规格说明，只依靠被测试程序的输入和输出之间关系或程序的功能来设计测试用例。 白盒测试则清楚程序内部的结构以及是如何运作的，因此白盒测试需要对系统内部的结构和工作原理有一个清楚的了解。 1 程序 #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #define N 2\u003c\u003c25 int a=N,b=N,c=N,d=N; void shuru(); void panduan(int a1,int b1,int c1); int main() { char se; shuru(); panduan(a,b,c); while(1) { printf(\"是否要继续 y or n :\"); scanf(\"%c\",\u0026se); if(se=='\\n') scanf(\"%c\",\u0026se); switch(se) { case 'y': shuru(); panduan(a,b,c); break; case 'n': return 0; } } } void shuru() { printf(\"Please enter 三角形三边 (a,b,c)\\n\"); while(!scanf(\"%d,%d,%d,%d\",\u0026a,\u0026b,\u0026c,\u0026d)){//判断非数字字符 fflush(stdin);//清理缓存 a=N;b=N;c=N;d=N; printf(\"输入错误、n\"); } fflush(stdin); while((a\u003c1||a\u003e100)||(b\u003c1||b\u003e100)||(c\u003c1||c\u003e100)||d!=N) { if(b==N||c==N||d!=N) printf(\"输入错误、n\");//边数为 1、2、4 条 else if(a==0||b==0||c==0) printf(\"边长不能为 0\\n\"); else if(a\u003c0||b\u003c0||c\u003c0) printf(\"边长不能为负、n\"); else printf(\"Please enter 1-100 之间的整数、n\"); a=N;b=N;c=N;d=N; while(!scanf(\"%d,%d,%d,%d\",\u0026a,\u0026b,\u0026c,\u0026d)){//判断非数字字符 fflush(stdin);//清理缓存 a=N;b=N;c=N;d=N; printf(\"输入错误、n\"); } fflush(stdin); } } void panduan(int a1,int b1,int c1) { if(a1+b1\u003ec1\u0026\u0026b1+c1\u003ea1\u0026\u0026a1+c1\u003eb1) { if(a1==b1\u0026\u0026a1==c1) printf(\"等边三角形、n\"); else if(a1==b1||a1==c1||b1==c1) printf(\"等腰三角形、n\"); else printf(\"一般三角形、n\"); } else printf(\"非三角形、n\"); } 2 测试 测试 1 测试 2 测试 3 ","date":"2019-05-26","objectID":"/posts/judgetriangle/:0:0","tags":["黑盒测试","C"],"title":"判断三角形的黑盒测试","uri":"/posts/judgetriangle/"},{"categories":["Memo"],"content":" 目前 HustOj 在 GitHUb 地址是：https://github.com/zhblue/hustoj 安装时注意 ubuntu 版本，没条件的可以在自己 ubuntu 上尝试，或者虚拟机上（关注公众号回复ubuntu16.04获取 iso 镜像文件），也可以在云实验室的云服务器上做做实验。 更多说明及 ACM/NOIP 题库下载见官网博客 代码的那些事 | 程序员回忆录 13 快速安装 OJ 下载 wget https://raw.githubusercontent.com/zhblue/hustoj/master/trunk/install/install-ubuntu16+.sh 安装 sudo bash install-ubuntu16+.sh 等待中一路回车，当提示 done！则表示安装成功： 14 使用 HustOJ 打开网页/IP 地址 注册 admin 用 admin 作为用户名注册一个用户，将会自动成为管理员。 注册成功，会提示： 登录后台 登录账号，并点击右上角的管理： 添加测试题目 在后台选择添加题目，添加成功： 然后再提交代码测试判题机。 15 说明 安装后几个重要配置文件的位置 /home/judge/etc/judge.conf /home/judge/src/web/include/db_info.inc.php /etc/php5/fpm/php.ini 或 /etc/php7.0/fpm/php.ini /etc/nginx/sites-enabled/default ","date":"2019-05-17","objectID":"/posts/hustoj/:0:0","tags":["hustoj","ACM","ubuntu","linux"],"title":"HustOJ 基础搭建教程","uri":"/posts/hustoj/"},{"categories":["ACM"],"content":" 二进制最大公约数算法避免了欧几里得算法（辗转相除法）的大量取模操作，有效减少了时间消耗，且更为方便。 1 原理 本算法基于以下事实： 对于两个数的最大公约数 gcd(m, n)，有 m\u003cn 时，gcd(m, n)=gcd(n, m) m 偶 n 偶时，gcd(m, n)=2*gcd(m/2, n/2) m 偶 n 奇时，gcd(m, n)=gcd(m/2, n) m 奇 n 偶时，gcd(m, n)=gcd(m, n/2) m 奇 n 奇时，gcd(m, n)=gcd(n, m-n) 采用递归即可。 2 实现 inline int GCD(int x,int y) { int i,j; if(x==0) return y; if(y==0) return x; for(i=0;0==(x\u00261);++i)x\u003e\u003e=1; // 去掉所有的 2 for(j=0;0==(y\u00261);++j)y\u003e\u003e=1; // 去掉所有的 2 if(j\u003ci) i=j; while(1){ if(x\u003cy)x^=y,y^=x,x^=y; // 若 x \u003c y 交换 x, y if(0==(x-=y)) return y\u003c\u003ci; // 若 x == y，gcd == x == y（就是在辗转减，while(1) 控制） while(0==(x\u00261))x\u003e\u003e=1; // 去掉所有的 2 } } int get_lcm(int a,int b)///获得最小公倍数 { int x=a; int y=b; while(b) { int t=a; a=b; b=t%b; } return x/a*y; } ","date":"2019-05-17","objectID":"/posts/gcd-bit/:0:0","tags":["欧几里得","数学","数论","C"],"title":"最大公约数（二进制算法）","uri":"/posts/gcd-bit/"},{"categories":["Grocery"],"content":" ImgURL 是一个开源、免费的图床程序，ImgURL 2.x 之后对环境要求更高，尤其是 ImageMagick 组件的支持，很多朋友不清楚怎样安装这个组件，这篇文章分享宝塔面板安装 ImgURL 2.x 图床的过程（包括 ImgURL 2.x 需要的各种组件） 阅读原文 1 准备工作 已经安装宝塔面板 在宝塔后台创建一个站点 下载 ImgURL 2.x 上传到站点根目录并解压 2 设置伪静态 如果你宝塔面板安装的 Apache 则不需要再设置伪静态，直接跳过这个步骤，如果使用的 Nginx 环境，请继续往下看。 找到对应的站点 - 点击后面设置按钮 - 伪静态 - 添加下面的伪静态规则 location / { try_files $uri $uri/ /index.php?$query_string; } location ~* \\.(db3|json)$ { deny all; } location ~* ^/(temp|upload|imgs|data|application|static|system)/.*.(php|php5)$ { return 403; } 3 安装 fileinfo \u0026 imagemagick 在宝塔后台 - 软件管理 - 找到你站点对应的 PHP 版本 - 设置 PHP - 安装扩展 - 勾选fileinfo和imagemagick，如下截图。 4 安装 ImgURL 2.x 其它所需扩展宝塔默认已经支持，重点是安装fileinfo和imagemagick，扩展安装完毕后就可以访问你自己的域名安装 ImgURL 了，如果正常会看到 ImgURL 安装界面。 5 其它说明 如果安装遇到任何问题，请留言反馈或到 3T 官方社区 进行反馈 ImgURL 更多使用说明请参考帮助文档：https://dwz.ovh/imgurldoc ","date":"2019-05-16","objectID":"/posts/imgurl/:0:0","tags":["ImgURL","宝塔面板"],"title":"宝塔面板安装 ImgURL 图床","uri":"/posts/imgurl/"},{"categories":["Python"],"content":" 用 python 模拟 post 请求获取“麻小科技”示例酒店后台的数据，再打包发送至指定的微信群或者好友。 要求每天早上 8 点定时把每个酒店的数据发送至每个酒店的微信工作群。 1 背景 麻小科技： 麻小科技全名深圳市麻小科技有限公司，成立于 2017 年 1 月。是我高一的时候参加Peer 夏令营带我们一个玩的“老师”和他的朋友的创业公司，说老师有点奇怪，我们都是直接叫名字的，比如大家都叫我瑞豪，我也就叫他文捷哥，简称捷哥吧。他们公司主要的开发模式是，小程序前端+php 后端，然后做的是酒店小程序，为每个酒店定制小程序。这些小程序可以贴在客房中给访客提供一些服务，大大节省了成本也提高了效率。 然后每个酒店小程序都有独立的后台，后台会记录一些点击需求的数据。现在他们有一个需求需要把每个酒店小程序后台的数据在每天早上 9 点发送至对应酒店的微信群。 2 实现代码 缓存登录信息，短时间类无需重复登录，仅第一次需要扫码登录（相当于微信网页版），后面的登录只需在手机上确认登录信息。 #!/usr/bin/python import requests import json import time from wxpy import * ## 基本信息填写： ## 酒店 id，酒店名称及群名列表数据，格式：[\"xxx\",\"xxx\",\"xxx\"] ## 使用时请将以下三个列表一一对应 hotel=[\"xxxx\",\"xxxx\"] ## 酒店后台数据接口二级域名，已匿名 hotel_name=[\"增城宾馆\",\"百丽酒店\"] grouplist = [\"麻小\",\"富强民主文明和谐自由平等公正法治\"] ## post 请求发送的数据 postData = { ## 'username':'test', ## 'password':'123456', } def get_data(): result = [] #结果列表 i = 0 #计数器 for each in hotel: url=\"http://\"+each+\".maxiaokeji.com/xxx/xxxxxxx/xxx\" ## 为保护隐私及权益，这里不提供接口 r = requests.post(url,data=postData) ## print(r.text) ## 把结果转化为 json 字符串 response=json.dumps(r.json(),indent=4,ensure_ascii=False) #sort_keys=True ## 把 json 转换为 dict 字典作为中间结果，再取出昨日数据 midresult=json.loads(response) result.append(\"早上好！\"+hotel_name[i]+\"小程序昨日数据如下：\\n 访问数：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type1\"])+\"\\n 房间数：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type2\"])+\"\\n 需求量：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type3\"])+\"\\n 商品点击量：\"+str(midresult[\"data\"][\"yesterday_data\"][\"type4\"])) i+=1 ## print(result) return result def wechat_send(bot,result): ## my_friend = bot.friends().search('lrh')[0] ## my_friend.send(result) i = 0 ## 计数器 for group in grouplist: my_group = bot.groups().search(group)[0] #依次搜索每一个群名称，每次一个 my_group.send(result[i]) print(result[i]) print(\"已发送至群：\"+group) i+=1 def main(bot): ## 设置最大休眠时间，防止程序长时间占用系统资源 while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) ## 设置每天 8 点发送 if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"软件明天开始将在每天 8 点发送数据！\") result=get_data() ## 获取数据 wechat_send(bot,result) ## 发送数据 time.sleep(86400-int(now_min)*60) if __name__==\"__main__\": bot = Bot(cache_path=True) ## 初始化机器人，扫码登陆 main(bot); 3 测试结果 4 程序打包 使用 pyinstaller 工具打包成可执行文件即可。（可执行文件不可跨平台运行，分平台打包） 目前该程序已经上线测试中 … 暂未反馈问题 5 收获 第一次参与实际公司的项目开发，虽然只是一个小的需求设计，但是我在这个过程中也学到了很多，比如通过实际一两周的编程对 Python 的熟悉度远远好过以前在实验室看的一个月视频。 还有就是在此次开发中，也感受到了实际项目开发的团队合作重要性，刚开始拿到这个需求，由于我对 python 和后台，以及数据接口这些基本的操作都不懂，就拿数据获取来说，我一开始一位要自己模拟登陆后台（已知密码），一顿操作、百度等等失败告终，后来涛哥给了一个数据接口，加上涛哥耐心指点，我才终于拿到了数据。 还有在多人合作的项目中，为保持代码的可读性，要尽量的多些注释，还有函数方法的命名尽量具备可读性。比如我代码中的wechat_send()，一开始的命名是wxfs()，经捷哥指正我才改过来的。 ","date":"2019-05-11","objectID":"/posts/mx2wx/:0:0","tags":["Python","wxpy","pyinstaller","HTTP","JSON","Cron"],"title":"python 实战：模拟 post 请求定时获取后台数据并打包发送至微信","uri":"/posts/mx2wx/"},{"categories":["Grocery"],"content":" \u003c!--[if !IE]\u003e\u003c!--\u003e 除 IE 外都可识别 \u003c!--\u003c![endif]--\u003e \u003c!--[if IE]\u003e 所有的 IE 可识别 \u003c![endif]--\u003e \u003c!--[if IE 6]\u003e 仅 IE6 可识别 \u003c![endif]--\u003e \u003c!--[if lt IE 6]\u003e IE6 以及 IE6 以下版本可识别 \u003c![endif]--\u003e \u003c!--[if gte IE 6]\u003e IE6 以及 IE6 以上版本可识别 \u003c![endif]--\u003e \u003c!--[if IE 7]\u003e 仅 IE7 可识别 \u003c![endif]--\u003e \u003c!--[if lt IE 7]\u003e IE7 以及 IE7 以下版本可识别 \u003c![endif]--\u003e \u003c!--[if gte IE 7]\u003e IE7 以及 IE7 以上版本可识别 \u003c![endif]--\u003e \u003c!--[if IE 8]\u003e 仅 IE8 可识别 \u003c![endif]--\u003e \u003c!--[if IE 9]\u003e 仅 IE9 可识别 \u003c![endif]--\u003e 项目范例说明 ![if !IE]The NOT operator. This is placed immediately in front of the feature, operator, or subexpression to reverse the Boolean meaning of the expression. NOT 运算符。这是摆立即在前面的功能，操作员，或子表达式扭转布尔表达式的意义。lt [if lt IE 5.5] The less-than operator. Returns true if the first argument is less than the second argument. 小于运算符。如果第一个参数小于第二个参数，则返回 true。 lte[if lte IE 6]The less-than or equal operator. Returns true if the first argument is less than or equal to the second argument. 小于或等于运算。如果第一个参数是小于或等于第二个参数，则返回 true。 gt[if gt IE 5]The greater-than operator. Returns true if the first argument is greater than the second argument. 大于运算符。如果第一个参数大于第二个参数，则返回 true。 gte [if gte IE 7]The greater-than or equal operator. Returns true if the first argument is greater than or equal to the second argument. 大于或等于运算。如果第一个参数是大于或等于第二个参数，则返回 true。 ( )[if !(IE 7)]Subexpression operators. Used in conjunction with boolean operators to create more complex expressions. 子表达式运营商。在与布尔运算符用于创建更复杂的表达式。\u0026[if (gt IE 5)\u0026(lt IE 7)]The AND operator. Returns true if all subexpressions evaluate to true AND 运算符。如果所有的子表达式计算结果为 true，返回 true|[if (IE 6)|(IE 7)]The OR operator. Returns true if any of the subexpressions evaluates to true. OR 运算符。返回 true，如果子表达式计算结果为 true。 \u003c!--[if lt IE 9]\u003e 加载 CSS1 \u003c!--[else]\u003e 加载 CSS2 \u003c![endif]--\u003e 这样有效是有效，但是用 HTML VALIDATOR 里，报错，因为这个不符合 XHTML 1.1 的规范， 如果把 ELSE 语句去掉，则正确。 加载 CSS2 \u003c!--[if lt IE 9]\u003e 加载 CSS1（可以把要重写的写在这里）. \u003c![endif]--\u003e ","date":"2019-05-10","objectID":"/posts/ifzhushi/:0:0","tags":["HTML","他山之石"],"title":"条件注释判断浏览器版本\u003c!--[if lt IE 9]\u003e;","uri":"/posts/ifzhushi/"},{"categories":["Python"],"content":" 第一次运行根据程序执行时间，判断程序休眠的时间，尽最大可能休眠，节省系统资源。 第二次运行后直接休眠一天，到每天早上 8 点执行任务。 （该程序需要一直挂着，保持网络不断） import time while True: now_hour = time.strftime(\"%H\", time.localtime()) now_min = time.strftime(\"%M\", time.localtime()) if now_hour \u003c \"08\": rest = 8 - int(now_hour) sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour \u003e \"08\": rest = 8 - int(now_hour) + 24 sleeptime = (rest-1)*3600 + (60-int(now_min))*60 print(\"启动时北京时间为：\"+time.strftime(\"%H:%M\", time.localtime()),\"\\t 软件将在\",rest-1,\"小时\",int((sleeptime-(rest-1)*3600)/60),\"分钟后发送数据\") time.sleep(sleeptime) elif now_hour == \"08\": print(\"启动时北京时间为：\" + time.strftime(\"%H:%M\", time.localtime()), \"\\t 软件将在每天 8 点发送数据！\") # 以下为定时任务 print(\"数据\") time.sleep(86400-int(now_min)*60) ","date":"2019-05-09","objectID":"/posts/pysettime/:0:0","tags":["Python","Cron"],"title":"python 设置程序每天 8 点定时执行任务","uri":"/posts/pysettime/"},{"categories":["Python"],"content":" 用过命令pip install pyinstaller安装失败，此包依赖于 pywin32，安装前需要先pip install pywin32, 我安装了还是出错，稍微百度了一下也没有看到解决办法。 这里通过手动下载安装解决的，记录一下。 1 下载 去官网下载 pyinstaller 安装包：https://pypi.org/project/PyInstaller/#files 2 解压 我这里解压到E:\\应用、Python37\\Lib\\site-packages\\PyInstaller-3.4 3 安装 cmd 也进入到上面的路径下，然后执行Python setup.py install，等待安装完毕 4 pyinstaller 简介 pyinstaller 将 Python 脚本打包成可执行程序，使在没有 Python 环境的机器上运行。 最新版是 pyinstaller 3.4，可运行在 Windows，Mac 和 Linux 操作系统下。但它不是跨编译的，也就是说在 Windows 下用 PyInstaller 生成的 exe 只能运行在 Windows 下，在 Linux 下生成的只能运行在 Linux 下。 5 打包 打包的 app 里并不包含任何源码，但将脚本的 .pyc 文件打包了。 基本语法： pyinstaller options myscript.py 常用的可选参数如下： --onefile 将结果打包成一个可执行文件 --onedir 将所有结果打包到一个文件夹中，该文件夹包括一个可执行文件和可执行文件执行时需要的依赖文件（默认） --paths=DIR 设置导入路径 --distpath=DIR 设置将打包的结果文件放置的路径 --specpath=DIR 设置将 spec 文件放置的路径 --windowed 使用 windows 子系统执行，不会打开命令行（只对 windows 有效） --nowindowed 使用控制台子系统执行（默认）（只对 windows 有效） --icon=\u003cFILE.ICO\u003e 将 file.ico 添加为可执行文件的资源（只对 windows 有效） 如pyinstaller --paths=\"D:\\\" test.py 6 CSDN 访问量脚本实例 比如，拿以前写的一个刷 csdn 访问量工具 csdn.py（放在桌面上），代码详见 在 cmd 进入桌面路径，输入如下命令 pyinstaller --onefile --nowindowed csdn.py ","date":"2019-05-09","objectID":"/posts/pyinstallererror/:0:0","tags":["Python","pyinstaller"],"title":"安装 pyinstaller 出错的解决办法及 csdn 工具实例打包","uri":"/posts/pyinstallererror/"},{"categories":["Java"],"content":" 实现一个简单的基于单线程的资源下载器，如图所示，用户可以任意指定下载资源的链接地址，系统根据该地址判断资源是否存在，如果存在，则将该资源下载到本地。 1 GUI 设计基本流程 先记录一下 GUI 设计的基本流程： 根据需要从相应的顶层容器继承（如果创建窗体就继承 JFrame，对话框就继承 JDialog），新建一个子类。 然后设置顶层容器的属性，包括大小、位置、标题和关闭事件等。 设置界面上 GUI 组件的事件响应。 public void actionPerformed(ActionEvent e) {} 向顶层容器上添加 GUI 组件，并设置布局。（通常利用 JPanel 组件先作为微型容器） 创建新建子类的实例，调用 setVisible(true) 方法显示页面。（也可以直接在子类中设置 setVisible(true)） 2 实现代码 package cn.lruihao.base; import java.awt.FlowLayout; import java.awt.Font; import java.awt.HeadlessException; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.FileOutputStream; import java.io.InputStream; import java.net.URL; import java.net.URLConnection; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JTextField; public class SingleThreadDown extends JFrame implements ActionListener { private final JPanel panel=new JPanel(); private final JLabel label1=new JLabel(\"网络资源的单线程下载：\"); private final JLabel label2=new JLabel(\"网络资源的网址：\"); JButton StartButton = new JButton(\"单击开始下载\"); JButton resetButton = new JButton(\"清空\"); JButton exitButton = new JButton(\"退出\"); JTextField urlField = new JTextField(20); public SingleThreadDown() { panel.setLayout(new FlowLayout()); //布局管理器 label1.setFont(new Font(\"雅黑\",Font.BOLD,15)); panel.add(label1); panel.add(label2); panel.add(urlField); panel.add(StartButton); panel.add(resetButton); panel.add(exitButton); setContentPane(panel); setSize(400,200); setLocation(400,400); setVisible(true); //面板可视化，也可以在 main 中通过 JFrame 子类对象调用方法设置 setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //默认关闭事件 StartButton.addActionListener(this);//添加点击事件，传入 ActionListener 对象，由于子类继承了 ActionListener 接口，所以 this resetButton.addActionListener(this); exitButton.addActionListener(this); } public void download(String address) throws Exception { URL url = new URL(address); URLConnection urlcon = url.openConnection(); urlcon.connect(); InputStream in=urlcon.getInputStream();//获取的字节流对象 String filePath = url.getFile(); int pos=filePath.lastIndexOf(\"/\"); //\"/\"分割的最后一个串的下标 String fileName = filePath.substring(pos+1); FileOutputStream out = new FileOutputStream(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\\"+fileName); byte[] b = new byte[1024]; int len=0; while((len=in.read(b,0,1024))!=-1) { out.write(b,0,len); } out.close(); in.close(); JOptionPane.showMessageDialog(this, \"下载完毕\"); } @Override public void actionPerformed(ActionEvent e) { if(e.getSource()==StartButton) { if(\"\".equals(urlField.getText())){ JOptionPane.showMessageDialog(this, \"请输入资源地址\"); } String url = urlField.getText(); try { download(url); } catch (Exception e1) { JOptionPane.showMessageDialog(this, \"资源地址有误，请检查~\"); e1.printStackTrace(); } }else if(e.getSource()==resetButton) { urlField.setText(\"\"); }else { System.exit(0); } } public static void main(String[] args) { new SingleThreadDown(); } } 3 运行结果测试 通过https://github.com/Lruihao/Grocery/raw/master/fonts/MMT_last.ttf下载沐目体 ttf 字体文件，稍微等待一下弹出对话框“下载完毕”，经检查下载内容正常。 ","date":"2019-05-08","objectID":"/posts/singlethreaddown/:0:0","tags":["GUI","URLConnection","HTTP","Java"],"title":"java 实现一个单线程的资源下载器","uri":"/posts/singlethreaddown/"},{"categories":["Python"],"content":" Json（JavaScript Object Notation）它是一种轻量级的数据交换格式，具有数据格式简单，读写方便易懂等很多优点。许多主流的编程语言都在用它来进行前后端的数据传输，大大的简化了服务器和客户端的开发工作量。相对于 XML 来说，更加的轻量级，更方便解析，因此许多开发者都遵循 Json 格式来进行数据的传输和交换。今天我们详细介绍一下 Python 在 Json 的编解码方面的知识。 1 json 的数据格式 在 json 中，遵循“键值对”的这样一种方式，比如：“{“name”:“tom”}”, 就是一个 json 格式的数据，json 的格式归纳下来，一般有以下几点： 对象通过键值对表现； 键通过双引号包裹，后面跟冒号“:”，然后跟该键的值； 值可以是字符串、数字、数组等数据类型； 对象与对象之间用逗号隔开； “{}”用来表达对象； “[]”用来表达数组； 我们看一个略为复杂一点的例子： 上例则是一个典型的 json 格式的数据，强大的 Python 提供了一个“json”模块，可以方便的将各种零散的数据通过模块的内置函数编码形成一个 json 格式的数据，也可以将一个 json 格式的数据解码形成自己需要的数据，非常好用，下面我们就来介绍一下。 2 json.dumps() json 模块里的 dumps 函数是对数据进行编码，形成 json 格式的数据，我们看一下下面的例子： 通过输出的结果很容易看出，通过 dumps 方法使字典转换成为了 json 格式，虽然它们非常相似。其中，在 dumps 里的参数“sort_keys=True”，使得输出 json 后对 key 和 value 进行 09、a z 的顺序排序，如果不填，则按照无序排列。有时候，通过排序可以方便地比较 json 中的数据，因此，适当的排序是很有必要的。 此外，“Indent”参数表示缩进的意思，它可以使得输出的 Json 看起来更加整齐好看，可读性更强，例如： 下面列举一下 dumps（）的可填参数： skipkey：默认为 False，当 dict 对象里的数据不是 Python 的基本数据类型；（str,unicode,int,long,float,bool,None）时，当 skipkey 为 False，就会报错，如果 skipkey 为 True，则可以跳过这类 key； indent：如果填 0 或者不填，则按照一行进行打印，否则按照 indent 的数值显示前面的空格（正整数形式）； separators：分隔符，默认为“(’,’,’:’)”，它表示 key 之间用“,”隔开，key 和 value 之间用“:”隔开； encoding：编码格式，默认值是 UTF-8； sort_keys：对 key、value 进行排序，默认值是 False，即不排序； ensure_ascii：默认为 True，如果 dict 对象里含有 none-ASCII 的字符，则显示、uXX 的格式，如果为 False，则能正常显示出来； 3 json.loads() 和 dumps 相反，loads 函数则是将 json 格式的数据解码，转换为 Python 字典，我们看一下下面的例子： 有时候，输出结果遇到中文的时候，会出现编码格式不一样的情况，显示出为 Unicode 的编码格式，使得不易读懂，解决办法是添加参数“encoding”参数，即上面的改写成这样：d1 = json.loads(data1,encoding=‘utf-8’) 即可。 4 json.dump() 和 json.load() 相对于上面所讲的 dumps 和 loads 来说，dump 和 load 函数的功能类似，只不过前者是用来处理字符串类型的，而后者是用于处理文件类型的，如下所示： 上例列举出了 json 的四个方法：dumps（）和 dump（）、loads（）和 load（）的简单使用方法，可见，Python 对于 json 的处理相当方便，不像 c++那样（谁用谁知道）。 ","date":"2019-05-07","objectID":"/posts/jsoninfo/:0:0","tags":["Python","JSON","他山之石"],"title":"Python 如何操作 Json？","uri":"/posts/jsoninfo/"},{"categories":["Python"],"content":" 通过 requests 可以向某个地址发送请求，可以用来做一些接口的测试；主要有两个方法： requests.get() requests.post() 最近帮朋友的项目做一个小需求，需要把后台数据定期打包发送到微信群，麻小科技涛哥给了我一个接口，post 访问。 #!/usr/bin/python import requests \"\"\" 通过 requests 可以向某个地址发送请求 requests.post(url,json date) post 方法还有其他参数，如 header 等 \"\"\" # post 发送的数据 postData = { # 'username':'test', # 'password':'123456', # 'salary':2000, } # 接口这里不便公开 r = requests.post('http://demo.maxiaokeji.com/xx/xxxxx/xxxx',data=postData) # print(r.text) response=r.json() print(response) 运行后会在屏幕打印出返回的 json 数据 ","date":"2019-05-07","objectID":"/posts/posttest/:0:0","tags":["Python","HTTP"],"title":"python 发送 post 请求进行简单的接口测试","uri":"/posts/posttest/"},{"categories":["Java"],"content":" 该例中首先生成一个 URL 对象 lrh，指向 RUI 豪小栈，然后再调用 lrh.openStream() 方法生成该 URL 的一个输入流，这是一个字节流，在此基础上进一步通过 InputStreamReader 和 BufferedReader 构造一个带缓冲功能的字符流，并通过这个字符流对象读取该 URL 的 html 内容，进而输出到桌面文件和控制台屏幕。URLConnection 类也可以用来对由 URL 引用的资源进行读写操作，前提是先通过 connect() 方法建立连接，然后再去获取响应头信息或响应内容。 package cn.lruihao.base; import java.io.BufferedReader; import java.io.File; import java.io.FileWriter; import java.io.InputStreamReader; import java.net.URL; import java.net.URLConnection; public class URLReader { public static void main(String[] args) throws Exception{ try { URL lrh=new URL(\"https://www.lruihao.cn\"); File file=new File(\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\lrh.html\"); FileWriter fout=new FileWriter(file); BufferedReader in =new BufferedReader(new InputStreamReader(lrh.openStream()));//字节流转化成字符流，再构建缓冲字符流 String inputLine; while((inputLine=in.readLine())!=null) { System.out.println(inputLine); fout.write(inputLine); } in.close(); fout.close(); //获取响应 header 信息 URLConnection conn=lrh.openConnection(); conn.connect(); System.out.println(\"获取到的响应长度：\"+conn.getContentLength()); System.out.println(\"响应类型：\"+conn.getContentType()); //用 BufferedReader 读取 URL 的响应 in =new BufferedReader(new InputStreamReader(conn.getInputStream())); String line; String result=null; while((line=in.readLine())!=null) { result+=line; } System.out.println(result); } catch (Exception e) { e.printStackTrace(); } } } ","date":"2019-05-06","objectID":"/posts/java-urlreader/:0:0","tags":["URLConnection","Java"],"title":"java 通过 URL 和 URLConnection 访问网页资源","uri":"/posts/java-urlreader/"},{"categories":["Java"],"content":" 基本功能：给定一个密钥，读取文件内容，加密后，输出到另外一个文件。 这里使用文件输入流读取文件内容，然后每个字节和密码进行异或简单加密。加密完成，使用文件输出流写入另一个文件中。解密和加密方法一样。利用的是对同一个数异或两遍其值不变的性质。因此一个程序可以完成加密和解密功能。只需修改文件名即可。 1 文件加密解密 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class EncryptFile { public static void main(String[] args) throws IOException { byte pwd=123;//加密/解密密码 FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/EncryptFile.java\");//待加密文件 FileOutputStream fout=new FileOutputStream(\"encrypted.txt\");//已加密文件 System.out.println(\"开始加密。\"); int n=f.available()/5; byte[] b=new byte[n];//以一个字节数组的长度读取和复制 int count=0; while((count=f.read(b,0,n))!=-1) { //写入之前先加密/解密 for(int i=0;i\u003ccount;i++) { b[i]=(byte)(b[i]^pwd);// } fout.write(b,0,count); } System.out.println(\"完成加密\"); f.close(); fout.close(); // f=new FileInputStream(\"encrypted.txt\"); // fout=new FileOutputStream(\"unencrypted.txt\"); // System.out.println(\"开始解密。\"); // n=f.available()/5; // b=new byte[n];//以一个字节数组的长度读取和复制 // count=0; // while((count=f.read(b,0,n))!=-1) { // //写入之前先加密/解密 // for(int i=0;i\u003ccount;i++) { // b[i]=(byte)(b[i]^pwd); // } // fout.write(b,0,count); // } // System.out.println(\"完成解密\"); // f.close(); // fout.close(); } } 2 文件复制 package cn.lruihao.base; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class FileStreamCopy { public static void main(String[] args) throws IOException { int size; FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/FileStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); System.out.println(\"总长度：\"+(size=f.available())); int n=size/10; System.out.print(\"使用单字节方法读取后：\"); for(int i=0;i\u003cn;i++) { fout.write(f.read()); } System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取一个字节数组后：\"); byte b[]=new byte[n]; f.read(b); fout.write(b); System.out.println(\"剩余长度：\"+f.available()); System.out.println(\"读取余下数据：\"); int count=0; while((count=f.read(b,0,n))!=-1) { //System.out.println(count); fout.write(b,0,count); } System.out.println(\"剩余长度：\"+f.available()); f.close(); fout.flush(); fout.close(); } } package cn.lruihao.base; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; public class BufferedStreamCopy { public static void main(String[] args) throws IOException { FileInputStream f=new FileInputStream(\"src/cn/lruihao/base/BufferedStreamCopy.java\"); FileOutputStream fout=new FileOutputStream(\"copy-of-file.txt\"); BufferedInputStream bis=new BufferedInputStream(f); BufferedOutputStream bos=new BufferedOutputStream(fout); System.out.println(\"开始复制。\"); int n=f.available()/5; byte[] b=new byte[n]; int count=0; while((count=bis.read(b,0,n))!=-1) { bos.write(b,0,count); } System.out.println(\"复制完成\"); bis.close(); bos.flush(); bos.close(); f.close(); fout.flush(); fout.close(); } } ","date":"2019-05-02","objectID":"/posts/byteio/:0:0","tags":["Java"],"title":"文件加密解密（字节流）","uri":"/posts/byteio/"},{"categories":["Java"],"content":"1 实现代码 这里的异常主要是InputMismatchException, 可以直接捕获该异常，我直接捕获了父类异常。 package cn.lruihao.Exception; import java.util.Scanner; /** * @author 李瑞豪 * 借书系统（异常练习） */ public class ExceptionDemo { private final Book[] books = { new Book(\"数据结构\"), new Book(\"Java\"), new Book(\"php\"), new Book(\"c\") }; public static void main(String[] args) { System.out.println(\"欢迎来到借书系统！\"); ExceptionDemo jieshu= new ExceptionDemo(); jieshu.menu(); } public void menu() { System.out.println(\"输入命令：1. 书名查找；\\t2. 序号查找；\"); //初始化并捕获用户输入 Scanner sc = new Scanner(System.in); // 捕获异常 try { int id =sc.nextInt(); if(id==1||id==2) { inquire(id); }else { System.out.println(\"输入错误！请根据提示输入~~\");//输入非 1，2 的数字情况 menu(); } }catch (Exception e) {//输入字符为非数字 e.printStackTrace(); System.out.println(\"输入错误，请输入数字命令~~\"); menu(); }finally{ sc.close(); } } private void inquire(int id) { Scanner sc = new Scanner(System.in); if(id==1) { System.out.println(\"请输入要查找的书名！\"); String name=sc.nextLine(); int num=FindName(name); if(num==0?false:true) {//验证书名是否存在 存在则打印 System.out.println(\"book:\"+name+\"\\t 序号：\"+num); //menu();//回到访问起点 也可以去掉终止程序 }else{ System.out.println(\"图书不存在\"); menu(); } sc.close(); }else if(id == 2) { System.out.println(\"请输入您要查找的序号：\"); int id2=sc.nextInt(); FindNum(id2); sc.close(); } } private void FindNum(int num) { try { if(num\u003e=0\u0026\u0026num\u003cbooks.length) { System.out.println(books[num].getName()); //menu();//回到访问起点 也可以去掉终止程序 }else{ System.out.println(\"图书不存在\"); menu(); } }catch (Exception e) { e.printStackTrace(); System.out.println(\"输入有误！~~\"); } } private int FindName(String name) { int num=0; for(Book i:books) { String name1=i.getName(); if(name1.equals(name)) { return num; } num++; } return 0; } } package cn.lruihao.Exception; public class Book { private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } public Book(String name) { this.name = name; } } 2 大致运行效果 ","date":"2019-05-01","objectID":"/posts/javaexception/:0:0","tags":["Java"],"title":"模拟借书系统（java 异常练习）","uri":"/posts/javaexception/"},{"categories":["瞎折腾","Python"],"content":" Python 二维码生成器是 github 上@sylnsfar 开源的一个 python 生成二维码工具。有 python, 网页及 exe 版本，详见 sylnsfar/qrcode，本文主要介绍记录一下 python 版本使用。exe 可以去 项目开源地址 下载，公众号文章后台回复关键词“qrcode”获取链接。 可生成_普通二维码_、带图片的艺术二维码（黑白与彩色）、动态二维码（黑白与彩色）。 1 示例 from MyQR import myqr import os version, level, qr_name = myqr.run( words='https://lruihao.cn', version=1, level='H', picture='2.jpg', colorized=True, contrast=1.0, brightness=1.0, save_name=None, save_dir=os.getcwd() ) # help(myqr) # https://github.com/sylnsfar/qrcode/ ''' Positional parameter words: str # 链接或者文字 Optional parameters version: int, from 1 to 40 # 控制边长 level: str, just one of ('L','M','Q','H') # 控制纠错水平，从左到右依次升高。 picutre: str, a filename of a image # 图片，需在同路径，默认 None colorized: bool # 是否彩色 默认 False constrast: float # 对比度 默认 1.0 brightness: float # 亮度 默认 1.0 save_name: str, the output filename like 'example.png' #控制文件名，默认 None,'qrcode.png' save_dir: str, the output directory # 储存路径 ''' 2 安装 # 通过 pip pip(3) install myqr(or MyQR) 3 使用方法 3.1 命令行方式 （提示：如果你尚未安装 MyQR ，以下内容请使用python(3) myqr.py 而非myqr 。） # 概括 myqr Words [-v {1,2,3,...,40}] [-l {L,M,Q,H}] [-n output-filename] [-d output-directory] [-p picture_file] [-c] [-con contrast] [-bri brightness] 普通二维码 介绍了 Words, -v, -l, -n, -d 艺术二维码 介绍了 -p, -c, -con, -bri 动态 GIF 二维码 介绍了动态的生成方法和注意点 3.1.1 普通二维码 #1 Words myqr https://github.com 在命令后输入链接或者句子作为参数，然后在程序的当前目录中产生相应的二维码图片文件，默认命名为“qrcode.png”。 #2 -v, -l myqr https://github.com -v 10 -l Q 默认边长是取决于你输入的信息的长度和使用的纠错等级； 而默认纠错等级是最高级的 H。 自定义：如果想要控制边长和纠错水平就使用 -v 和 -l 参数。 -v 控制边长，范围是1 至 40，数字越大边长越大； -l 控制纠错水平，范围是L、M、Q、H，从左到右依次升高。 #3 -n, -d myqr https://github.com -n github_qr.jpg -d .../paths/ 默认输出文件名是“qrcode.png “，而默认存储位置是当前目录。 自定义：可以自己定义输出名称和位置。注意同名文件会覆盖旧的。 -n 控制文件名，格式可以是 .jpg， .png ，.bmp ，.gif ； -d 控制位置。 3.1.2 艺术二维码 #1 -p myqr https://github.com -p github.jpg 参数-p 用来将 QR 二维码图像与一张同目录下的图片相结合，产生一张黑白图片。 #2 -c myqr https://github.com -p github.jpg -c 加上参数 -c 可以使产生的图片由黑白变为彩色的。 #3 -con, -bri myqr https://github.com -p github.jpg [-c] -con 1.5 -bri 1.6 参数-con 用以调节图片的对比度，1.0 表示原始图片，更小的值表示更低对比度，更大反之。默认为 1.0。 参数 -bri 用来调节图片的亮度，其余用法和取值与 -con 相同。 3.1.3 动态 GIF 二维码 动态二维码与上述的带图片的二维码的生成方法没什么区别，你只要采用 .gif 格式的图片即可生成黑白或者彩色的动态二维码。但注意如果使用了 -n 参数自定义输出的文件名，切记其格式也必须是 .gif 格式。 3.2 作为导入文件 # 安装模块后 from MyQR import myqr version, level, qr_name = myqr.run( words, version=1, level='H', picture=None, colorized=False, contrast=1.0, brightness=1.0, save_name=None, save_dir=os.getcwd() ) 以下各个参数已经在上文命令行方式有所介绍 # help(myqr) Positional parameter words: str Optional parameters version: int, from 1 to 40 level: str, just one of ('L','M','Q','H') picutre: str, a filename of a image colorized: bool constrast: float brightness: float save_name: str, the output filename like 'example.png' save_dir: str, the output directory 4 使用提示 请采用正方形或近似正方形的图片 建议在图片尺寸大的时候使用 -v 的值也应该适当变大。 5 可用字符 数字 0 到 9 大小写的英文字母 常用英文标点符号和空格 · , . : ; + - * / \\ ~ ! @ # $ % ^ \u0026 ` ' = \u003c \u003e [ ] ( ) ? _ { } | and (space) 6 依赖库 pillow numpy imageio 7 运行环境 Linux, Python 3 Windows, Python 3 Mac, Python 3 ","date":"2019-04-27","objectID":"/posts/qrcode/:0:0","tags":["pillow","numpy","imageio","Python"],"title":"用 MyQR 制作专属动态二维码 (py 和 exe 版本）","uri":"/posts/qrcode/"},{"categories":["thoughts"],"content":" 时间过得真快，一下从大一到了大三，马上就要实习毕业等等了。 Success 富士康在学校有一个春招的机会，我和朋友抱着侥幸的心理去试了试。 虽然深知自己还身有很多缺点，但是不面试不知道，一面试都暴露出来了，以下记录一下自己的不足之处： php 和 sql 的经典组合虽然有所接触了解，但是确实什么都会，得花时间学 html/css 等虽然平时折腾博客这些应用的比较多，但是今天竟然紧张地忘记了 margin 和 padding 都不会写了 如上一条，公众表现能力有待加强。正如当今“酒香也怕巷子深”，何况“不香”。 惊喜的事说来就来，本来知道自己这么多缺点，这么菜后，觉得这个实习的 offer 是没戏了，没想到下午技术主管微信发来消息，说录用了。当场懵逼，受宠若惊的感觉！非常谢谢面试官老师！ 无论生活还是学习，希望以后的自己一定要保持一颗谦逊爱学的心，早日实现全栈工程师的梦想，还有早点存钱把大学学费的贷款还掉！ ","date":"2019-04-24","objectID":"/posts/1thintervivew/:0:0","tags":["面试"],"title":"第一次面试经历","uri":"/posts/1thintervivew/"},{"categories":["瞎折腾","Python"],"content":" 以下程序对 该网址 内的手写体图片进行爬取！这个手写体是我在手机上通过《手迹造字》app 书写的，大概 6886 个字符，历时两年多，目前仍在修改中。字体效果查看 1 思路设计 通过观察目标网页中字符图片的链接，很容易发现每个字符图片的直链是由两部分组成。 固定链接 图片文件编号 其中固定连接为https://image.xiezixiansheng.com/users/2010/700/unzip/579767/, 图片文件为xxxxx.png@50q，如果去掉@50q，获取到的图片就是透明背景的不然就是白色背景。然后发现编号大多是 5 位数的形式，但是还有一些是 4 位的，甚至还有 2-3 位的数字。仔细看看 127 前的编号都是一些国际符号诸如英文和数字等。比对一下发现正是 ASCII 码对应的命名方式。可想而知中文自然也是通过编码来命名的。一个标准的字库文件至少包含 6763 个汉字，也就是我书写的这个GB2312-80, 范围： 0xA1A1 - 0xFEFE，其中汉字范围： 0xB0A1 - 0xF7FE。两个 16 进制位对应一个字节，一个汉字至少由两个字节组成，这样理解，范围自然是 4 个 16 进制位。所以转换成 10 进制，范围大致在 65278 以下。要了解更加具体一点的范围还需要去查一下汉字编码的分区等。这里暂时不必了解，因为本来就打算暴力下载。 说了这么多，既然图片链接这么简单，所以我是想暴力遍历，搜索图片，判断链接状态码，然后下载图片。 2 源码设计 大致分为三个范围吧 英文字符 中文符号 汉字范围 我主要分这几个区间查找 33 ~ 126 8212 ~ 8243 12289 ~ 12305 19968 ~ 40864 65281 ~ 65509 磨刀不误砍柴工，分析观察了这么久，终于可以运行程序了，F5 后就静静等待吧，可以去看看 java，或者打一把王者 hhhhh! import os import requests path=\"C:\\\\Users\\\\李瑞豪、\\Desktop\\\\MMT_images\\\\\" #下载路径：绝对或者相对路径比如。/image/ os.makedirs(path+\"0\\\\\", exist_ok=True) ## 创建文件夹 os.makedirs(path+\"1\\\\\", exist_ok=True) ## 下载图片 def urllib_download(url,num): ## （下载链接，图片编号） from urllib.request import urlretrieve urlretrieve(url,path+num+\".png\") ## 判断状态码 def get_status(url): r = requests.get(url, allow_redirects = False) return r.status_code def main(): BASE_URL = \"https://image.xiezixiansheng.com/users/2010/700/unzip/579767/\" n=33 total=0 print(\"正在爬取第 1 张图片！\") while n \u003c 65510: #分段爬取，不然会超时！！！## 33 ~ 126 ## 8212 ~ 8243 ## 12289 ~ 12305 ## 19968 ~ 40864 ## 65281 ~ 65509 if n == 127: n = 8212 continue elif n == 8244: n = 12289 continue elif n ==12306: n = 19968 continue elif n == 40865: n = 65281 continue ## for n in range(37341,40865): num = str(n) IMAGE_URL = BASE_URL+num+\".png\" ## xxx.png 是透明背景，xxx.png@50q 是白色背景，分别存放在 0，1 文件夹 p 是中小 w 是小图 if(get_status(IMAGE_URL)==200): ## 同时下载透明和白色背景的图片 total+=1 urllib_download(IMAGE_URL,\"0\\\\\"+num) IMAGE_URL += \"@50q\" urllib_download(IMAGE_URL,\"1\\\\\"+num) print(\"Downloaded \"+num+\".png\") print(\"正在爬取第\",total+1,\"张图片！\") n+=1 print(\"\\n 爬取完毕！共爬取\",total,\"张图片！\") print(\"图片存放路径：\"+path) print(\"作者博客：lruihao.cn\") if __name__==\"__main__\": main(); 3 爬取过程及结果 文件夹左下角数目变化 爬取过程 危险 说实话看着控制台不停地输出提示信息有没有很爽，对于强迫症来说真的是很治愈了！但是爬取第 6042 张图片的时候，我打开了一下目标网页发现无法加载图片了，就想这应该也算是一次 Dos 攻击了吧！打开控制台果然停了，相当于访问了近两万次！唉，还是太暴力了！！还差 800 多张，只好又重新接着写上次的位置爬！不慎造成目标网站服务器压力，实在对不起！ 错误提示 一个半小时左右后终于下载完了，一共是 6886 张；程序是同时下载了透明和白色背景的图片的！分别在 0,1 子文件夹！ 爬取完毕 4 其他思路 模拟浏览器载入 html 文件，获取源码，查找到所有\u003cimg\u003e标签内链接，必要时配合正则表达式，然后下载图片。 ","date":"2019-04-22","objectID":"/posts/mmtimgpy/:0:0","tags":["Python"],"title":"python 爬取网站图片（图片链接相似）","uri":"/posts/mmtimgpy/"},{"categories":["瞎折腾","Python"],"content":" 文中涉及的图片涉及个人隐私，仅做举例，请勿传播 查看微信好友男女比例 查看好友地区分布 群性别统计 1 前期准备 wxpy pyecharts（百度 echarts） 2 查看微信好友男女比例 from wxpy import * from pyecharts import Pie bot = Bot(cache_path = True) #定义一个微信机器人 friends = bot.friends(update=False) #获取更新好友列表 male = female = other = 0 for i in friends[1:]: #[1:] 自己是第一个，排除掉 sex = i.sex if sex == 1: male += 1 elif sex == 2: female += 1 else: other += 1 total = len(friends[1:]) #计算总数 #下面为分析 attr = [\"男性\",\"女性\",\"其他\"] v1 = [float(male),float(female),float(other)] pie = Pie(\"饼图 - 圆环图示例\", title_pos='center') pie.add(\"\", attr, v1, radius=[40, 75], label_text_color=None, is_label_show=True, legend_orient='vertical', legend_pos='left') pie.render(\"sex.html\") 3 查看好友地区分布 from wxpy import * from pyecharts import Map #因为获取的列表城市都没有带市字，而 pyecharts 需要带个市字 b = '市' def s(x): return x+b #只提取湖南的 bot = Bot(cache_path = True) friends = bot.friends(update=False).search(province = '湖南') citys = [] for f in friends : city = f.city citys.append(city) r = map(s,citys) cityss = list(r) #为城市计数 a = {} for i in cityss: a[i] = cityss.count(i) a.pop('市') #把字典进行有序拆分为 2 个列表 attrs = [] values = [] for value, attr in a.items(): values.append(attr) attrs.append(value) #开始绘图 map = Map(\"湖南地图示例\", width=1200, height=600) map.add(\"\", attrs, values, maptype='湖南', is_visualmap=True, visual_text_color='#000') map.render(\"city.html\") 以上参考简书 陈思煜 4 统计所有群男女数目 统计结果会自动发送到所有群聊 男女人数和不一定等于总数（有些人不显示性别） #encoding=utf-8 from wxpy import * import numpy def removeAll(the_list, val): return [value for value in the_list if value != val] def stats_text(target_group, group_name): print(group_name + \"群共有：\" + str(len(target_group)) + \"人，其中：\") all_stats_text = [] all_dict = {} ## 乱序先整理一份省份 + 地点的列表 for user in target_group.members: trimed_data = user.province.replace(' ', '') + user.city.replace(' ', '') if trimed_data != '': all_stats_text.append(trimed_data) ## 计数 for data in all_stats_text: if all_stats_text.count(data) != 0: all_dict[data] = all_stats_text.count(data) all_stats_text = removeAll(all_stats_text, data) final_dict = {} for i in sorted(all_dict.keys()): final_dict[i] = all_dict[i] return final_dict def stats_sex(target_group): male = 0 female = 0 other = 0 for user in target_group.members: if user.sex == 1: male = male + 1 if user.sex == 2: female = female + 1 else: other = other + 1 print(\"男的有：\" + str(male) + \"人\") print(\"女的有：\" + str(female) + \"人\") msg = \"男的有：\" + str(male) + \"人、n\" + \"女的有：\" + str(female) + \"人、n\" return msg bot = Bot() target_group = bot.groups(update=True, contact_only=False) for curr_group in target_group: ## 小于 10 人的群过滤掉 if len(curr_group) \u003c 10: continue curr_group.update_group(members_details=True) print(curr_group.name + \"一共有：\" + str(len(curr_group)) + \"人、n\") msg = stats_sex(curr_group) curr_group.send(curr_group.name + \"群，一共有：\" + str(len(curr_group)) + \"人、n\" + msg) ","date":"2019-04-20","objectID":"/posts/wxpy1/:0:0","tags":["Python","wxpy","pyecharts","jieba","他山之石"],"title":"python 玩微信：初探 wxpy","uri":"/posts/wxpy1/"},{"categories":["瞎折腾","Python"],"content":" Python 通过 wxpy 登录微信网页版，爬取好友所有头像并拼接成一张大图。然后删除所有子图。（注释相关代码可以不删除） 文中涉及的图片涉及个人隐私，仅做举例，请勿传播 文中编码由 Sunbelife 提供，来自他的同名微信公众号，本博仅用于学习，侵删 1 依赖 wxpy（Pythone 登录微信） pillow（拼接头像） os（文件夹操作） math（数学计算） wxpy: wxpy 在 itchat 的基础上，通过大量接口优化提升了模块的易用性，并进行丰富的功能扩展。 PIL： Python Imaging Library，已经是 Python 平台事实上的图像处理标准库了。PIL 功能非常强大，但 API 却非常简单易用。由于 PIL 仅支持到 Python 2.7，加上年久失修，于是一群志愿者在 PIL 的基础上创建了兼容的版本，名字叫 Pillow，支持最新 Python 3.x，又加入了许多新特性，因此，我们可以直接安装使用 Pillow。 2 安装 pip install -U wxpy -i \"https://pypi.doubanio.com/simple/\" pip install pillow 3 运行 如果在 Python IDE 运行出错，可能是因为微信好友的 id 是特殊字符，在 IDE 打印出错，注释掉代码 36 行即可。 from wxpy import * import math import PIL.Image as Image import os import sys import shutil # ### 获取文件所在的绝对路径 def get_dir(sys_arg): sys_arg = sys_arg.split(\"/\") dir_str = \"\" count = 0 for cur_dir in sys_arg: if count == 0: count = count + 1 if count == len(sys_arg): break dir_str = dir_str + cur_dir + \"/\" count = count + 1 return dir_str curr_dir = get_dir(sys.argv[0]) bot = Bot() ## 机器人账号自身 myself = bot.self my_friends = bot.friends(update=True) if not os.path.exists(curr_dir + \"group-images/\"): os.mkdir(curr_dir + \"group-images/\") count = 0 for friend in my_friends: print(friend.nick_name) friend.get_avatar(curr_dir + \"group-images/\" + str(count) + \".jpg\") count = count + 1 ## 获取下载的头像文件 ls = os.listdir(curr_dir + 'group-images') ## 去除非 .jpg 文件 for filter_ls in ls: if \".jpg\" in filter_ls: continue else: ls.remove(filter_ls) ## 排序 ls.sort(key=lambda x:int(x[:-4])) ## 头像墙尺寸 image_size = 2560 each_size = math.floor(image_size/math.floor(math.sqrt(len(ls)))) x_lines = math.ceil(math.sqrt(len(ls))) y_lines = math.ceil(math.sqrt(len(ls))) image = Image.new('RGB', (each_size * x_lines, each_size * y_lines)) x = 0 y = 0 for file_names in ls: try: img = Image.open(curr_dir + \"group-images/\" + file_names) print(\"正在处理\" + file_names.split('.jpg')[0] + \"/\" + str(len(ls))) except IOError: continue else: img = img.resize((each_size, each_size)) image.paste(img, (x * each_size, y * each_size)) x += 1 if x == x_lines: x = 0 y += 1 img = image.save(curr_dir + \"all.jpg\") try: shutil.rmtree(curr_dir + \"group-images/\") print(\"收尾，清理临时文件\") except FileNotFoundError: print(\"没什么好删的\") print(\"！！！\\n 生成完毕了，放在了目录\" + curr_dir + \"，去看看吧。\") print(\"工具作者：@Sunbelife（新浪微博）\") print(\"公众号：Sunbelife\") print(\"感谢使用\") print(\"v1.2\") print(\"2019.4.18\") 4 群友全家福 修改 11 行群名称 import itchat import math import PIL.Image as Image import os import shutil ## 变量 itchat.auto_login(hotReload=True,enableCmdQR=False) roomslist = itchat.get_chatrooms(update=True)[0:] itchat.dump_login_status() ## 显示所有的群聊信息，默认是返回保存到通讯录中的群聊 myroom=itchat.search_chatrooms(name=u'绥宁一中高 396 班') #群聊名称 gsq=itchat.update_chatroom(myroom[0]['UserName'], detailedMember=True) num = 0 if not os.path.exists(\"./group-images/\"): os.mkdir(\"./group-images/\") for i in gsq['MemberList']: print(i[\"UserName\"]) img = itchat.get_head_img(userName=i[\"UserName\"],chatroomUserName=myroom[0]['UserName']) fileImage = open(\"./group-images/\" + str(num) + \".jpg\",'wb') fileImage.write(img) fileImage.close() num += 1 ls = os.listdir('./group-images') each_size = int(math.sqrt(float(640*640)/len(ls))) lines = int(640/each_size) image = Image.new('RGBA', (640, 640)) x = 0 y = 0 for i in range(0,len(ls)+1): try: img = Image.open(\"./group-images/\" + str(i) + \".jpg\") except IOError: print(\"Error\") else: img = img.resize((each_size, each_size), Image.ANTIALIAS) image.paste(img, (x * each_size, y * each_size)) x += 1 if x == lines: x = 0 y += 1 image.save(\"all.png\") shutil.rmtree(\"./group-images\") 绥宁一中高 396 班 加个列表，加个循环实现自动爬取所有群聊头像并发送 import itchat import math import PIL.Image as Image import os import shutil ## 变量 itchat.auto_login(hotReload=True,enableCmdQR=False) roomslist = itchat.get_chatrooms(update=True)[0:] itchat.dump_login_status() ## 显示所有的群聊信息，默认是返回保存到通讯录中的群聊 for room in roomslist: print(room['UserName']) gsq=itchat.update_chatroom(room['UserName'], detailedMember=True) num = 0 if not os.path.exists(\"./group-images/\"): os.mkdir(\"./group-images/\") for i in g","date":"2019-04-20","objectID":"/posts/wximgpy/:0:0","tags":["wxpy","pillow","Python"],"title":"基本 python 实现的爬取微信好友头像，并拼接成大图","uri":"/posts/wximgpy/"},{"categories":["Java"],"content":" 之所以用记事本来写不是为了装 X 或者什么的。反而恰恰是返璞归真，因为在用 java 语言进行程序开发时，首先是以纯文本的方式编写所有的 java 源程序，并保存成以.java为后缀的文件；然后将这些源程序用javac编译成.class后缀名的字节代码文件；字节代码不是被本地处理器执行的代码，而是能够被 java 虚拟机（JVM）执行的代码。最后用 java 运行工具在 JVM 执行 java 应用程序。 由于 JVM 可以运行在不同的操作系统上，因此同一个字节代码文件可以跨平台运行。 javac java 1 编写 java 用记事本编辑 java 文件，并且把后缀改成.java，文件名和类名要一样。 public class HelloWorld{ public static void main(String[] args){ System.out.println(\"Hello World!\"); } } 2 打开 cmd ","date":"2019-04-19","objectID":"/posts/hellojava/:0:0","tags":["Java"],"title":"用记事本编写第一个 java 程序","uri":"/posts/hellojava/"},{"categories":["Java"],"content":"1 邮箱 import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexDemo { public static void main(String[] args) { // Pattern 类 正则表达式的编译表示。 Pattern pattern = Pattern.compile(\"^[a-zA-Z0-9_!#$%\u0026'*+/=?`{|}~^.-]+@[a-zA-Z0-9.-]+$\"); String[] emails = {\"admin@lruihao.cn\", \"lruihao.cn\"}; for (String email : emails) { //Matcher 通过解释 Pattern 对字符序列执行匹配操作的引擎 Matcher matcher = pattern.matcher(email); System.out.println(email + \"匹配结果：\" + matcher.matches()); } } } admin@lruihao.cn 匹配结果：true lruihao.cn 匹配结果：false 2 电话 package base; import java.util.Scanner; import java.util.regex.Matcher; import java.util.regex.Pattern; public class RegexTest { public static void main(String[] args) { Pattern patter=Pattern.compile(\"^[1][3,4,5,7,8][0-9]{9}$\"); Scanner sc=new Scanner(System.in); String telnum=sc.nextLine(); sc.close(); Matcher matcher=patter.matcher(telnum); System.out.println(telnum+\"匹配结果： \"+matcher.matches()); } } /** * 获取当前的 httpSession * @return */ public static HttpSession getSession() { return getRequest().getSession(); } /** * 手机号验证 * @param str * @return 验证通过返回 true */ public static boolean isMobile(final String str) { Pattern p = null; Matcher m = null; boolean b = false; p = Pattern.compile(\"^[1][3,4,5,7,8][0-9]{9}$\"); // 验证手机号 m = p.matcher(str); b = m.matches(); return b; } /** * 电话号码验证 * @param str * @return 验证通过返回 true */ public static boolean isPhone(final String str) { Pattern p1 = null, p2 = null; Matcher m = null; boolean b = false; p1 = Pattern.compile(\"^[0][1-9]{2,3}-[0-9]{5,10}$\"); // 验证带区号的 p2 = Pattern.compile(\"^[1-9]{1}[0-9]{5,8}$\"); // 验证没有区号的 if (str.length() \u003e 9) { m = p1.matcher(str); b = m.matches(); } else { m = p2.matcher(str); b = m.matches(); } return b; } 3 身份证 /* 身份证正则表达式 16 或 18 */ public static final String IDCARD=\"((11|12|13|14|15|21|22|23|31|32|33|34|35|36|37|41|42|43|44|45|46|50|51|52|53|54|61|62|63|64|65)[0-9]{4})\" + \"(([1|2][0-9]{3}[0|1][0-9][0-3][0-9][0-9]{3}\" + \"[Xx0-9])|([0-9]{2}[0|1][0-9][0-3][0-9][0-9]{3}))\"; ","date":"2019-04-18","objectID":"/posts/java-regex/:0:0","tags":["regex","Java"],"title":"java 正则表达式练习","uri":"/posts/java-regex/"},{"categories":["Java"],"content":"1 StringBuffer/StringBuilder（掌握） 1.1 StringBuffer 是线程安全的可变字符串 StringBuilder 是线程不安全的可变字符串。 和 StringBuffer 的功能一样。就是效率高一些，但是不安全。 1.2 构造方法 StringBuffer sb = new StringBuffer(); StringBuffer sb = new StringBuffer(50); StringBuffer sb = new StringBuffer(“hello”); 1.3 成员方法：（自己补齐方法和意思） 添加功能 public StringBuffer append(String str): 追加字符串 public StringBuffer insert(int offset,String str): 在指定位置插入字符串 删除功能 public StringBuffer deleteCharAt(int index): 删除指定位置字符 public StringBuffer delete(int start,int end): 删除从指定开始到结束的字符，左闭右开 替换功能 public StringBuffer replace(int start,int end,String str): 以字符串替代从指定开始到结束的字符 反转功能 public StringBuffer reverse(): 反转 截取功能 public String substring(int start): 从指定索引到末尾的字符串 public String substring(int start,int end): 从指定索引开始到指定索引结束的字符串 1.4 案例 String 和 StringBuffer 的相互转换，通过构造即可。 把数组转成指定的字符串格式 把字符串反转 判断一个字符串是否是对称字符串 2 数组高级部分（理解） 2.1 排序 冒泡排序 相邻元素，两两比较，大的往后放。 public static void bubbleSort(int[] arr) { for(int x=0; x\u003carr.length-1; x++) { for(int y=0; y\u003carr.length-1-x; y++) { if(arr[y]\u003earr[y+1]) { int temp = arr[y]; arr[y] = arr[y+1]; arr[y+1] = temp; } } } } 选择排序 从 0 开始，依次和后面的比较，小的往前放。 public static void selectSort(int[] arr) { for(int x=0; x\u003carr.length-1; x++) { for(int y=x+1; y\u003carr.length; y++) { if(arr[y] \u003c arr[x]) { int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; } } } } public static void selectSort(int[] a) { int min=0; int temp=0; if((a==null)||(a.length==0)) return; for(int i=0;i\u003ca.length-1;i++) { min=i;//无序区的最小数据数组下标 for(int j=i+1;j\u003ca.length;j++) { //在无序区中找到最小数据并保存其数组下标 if(a[j]\u003ca[min]) { min=j; } } //将最小元素放到本次循环的前端 temp=a[i]; a[i]=a[min]; a[min]=temp; } } 2.2 查找 基本查找 数组无序 二分查找 数组有序 public static int getIndex(int[] arr,int value) { int max = arr.length-1; int min = 0; int mid = (max+min)/2; while(arr[mid] != value) { if(arr[mid] \u003e value) { max = mid - 1; }else if(arr[mid] \u003c value) { min = mid + 1; } if(max \u003c min) { return -1; } mid = (max+min)/2; } return mid; } 3 Arrays 工具类（掌握） 3.1 Arrays 是针对数组进行操作的工具类，提供了排序和查找等功能 3.2 成员方法：（自己补齐方法和意思） 把数组转成字符串 public static String toString(): 将任意类型数据转换成字符串 排序 public static void sort()： 二分查找 public static int binarySearch(int[] arr,int key) 3.3 案例 把字符串中的字符进行排序 4 基本类型包装类（掌握） 4.1 为了让我们对基本类型进行更多的操作，java 针对每种基本类型提供了对应的包装类类型 4.2 分别是哪些呢？ byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 特殊：void Void 4.3 Integer 构造方法 Integer i = new Integer(100); Integer i = new Integer(“100”); 成员方法（自己补齐方法和意思） 把字符串转成 int 类型 String-\u003eint: Integer.parseInt() int-\u003eString: String.valueOf() 或 Integer.toString() JDK5 的新特性 自动装箱： int --\u003e Integer //Integer.valueOf() 自动拆箱： Integer --\u003e int //Integer.intValue() 请解释： Integer i = 100; i+=200; System.out.println(i); byte 缓存池面试题 byte,short,char—\u003e小于 127，否则报 -6 的错误（查看 JDK) 4.4 Character 构造方法 Character ch = new Character(‘a’); 成员方法（自己补齐方法和意思） 判断字符是否是大写字母 public boolean isUpperCase(char ch) 判断字符是否是小写字母 public boolean isLowerCase(Char ch) 判断字符是否是数字字符 public boolean isDigit(Char ch) 把字符转成大写 public Char toUpperCase(Char ch) 把字符转成小写 public Char toLowerCase(Char ch) ","date":"2019-04-14","objectID":"/posts/stringbuffer/:0:0","tags":["StringBuffer","sort","Java"],"title":"java 常用类","uri":"/posts/stringbuffer/"},{"categories":["ACM"],"content":"1 题目大意 题目链接 老鼠有 M 磅猫食 , 有 N 个房间 , 每个房间前有一只猫 , 房间里有老鼠最喜欢的食品 J[i] , 若要得到房间的食物 , 必须付出相应的猫食 F[i] , 当然这只老鼠没必要每次都付出所有的 F[i]，若它付出 F[i] 的 a%，则得到 J[i] 的 a%，求老鼠能吃到的最多的食物。 1.1 Sample Input 5 3 7 2 4 3 5 2 20 3 25 18 24 15 15 10 -1 -1 1.2 Sample Output 13.333 31.500 2 分析 老鼠要用最少的猫粮来换取最多的食物 , 也就是 J[i]/F[i] 越大越好 , 所以按照 J[i]/F[i] 进行降序排列 , 然后依次用猫粮来换取食物 , 当所剩下的猫粮不足以完全换取食物 , 能换多少是多少。 #include\u003cstdio.h\u003e #include\u003calgorithm\u003e using namespace std; struct node{ double j; double f; double s; }a[1005]; int cmp(node x,node y){ return x.s\u003ey.s; } int main(){ int m,n,i; while(scanf(\"%d%d\",\u0026m,\u0026n)\u0026\u0026(m!=-1\u0026\u0026n!=-1)){ memset(a,0,sizeof(a)); for(i=0;i\u003cn;i++){ scanf(\"%lf%lf\",\u0026a[i].j,\u0026a[i].f); a[i].s=a[i].j/a[i].f; } sort(a,a+n,cmp); double sum=0; for(i=0;i\u003cn;i++){ if(m\u003e=a[i].f){ sum+=a[i].j; m-=a[i].f; }else{ sum+=a[i].s*m; m=0; } if(m\u003c=0) break; } printf(\"%.3lf\\n\",sum); } return 0; } ","date":"2019-04-12","objectID":"/posts/hdu1009/:0:0","tags":["ACM","贪心","HDU"],"title":"HDU 1009 FatMouse' Trade（贪心）","uri":"/posts/hdu1009/"},{"categories":["OS"],"content":" 一直都想在自己电脑上搭建一个网站或者把自己的电脑做成服务器，今天终于简单实现了。还有很多知识需要学习，简单记录一下。 1 搭建环境 我的电脑是ubuntu+windows双系统的，所以我先在 ubuntu 上面装了一个宝塔面板，方便通过 web 管理电脑，宝塔安装好后安装相关的环境mysql,php,nginx等。我们现在只能通过本地 ip127.0.0.1:8888访问面板。 2 ngrok 穿透 去 ngrok 注册登录，购买隧道（有免费的），然后绑定端口，绑定域名，这里我们拿端口8888和域名test.lruihao.cn做实验，也就是宝塔面板的端口，这样我们就可以透过域名远程访问本地服务器，这样是不是开始有云服务器的感觉了。然后宝塔面板设置也绑定好域名test.lruihao.cn,dns 服务商那里做好相应的解析。 然后在 ngrok 那里下载 sunny 客户端文件，我们是 ubuntu 选择linux-64bits版本。解压后在 ubuntu 打开终端进入 sunny 文件目录，权限给到 755，运行命令./sunny clientid xxxxxxx 后面的你的隧道订单的 id。 现在就可以通过互联网访问我的 ubuntu 服务器了。 3 搭建网站 前面两步搞定，搭建网站就没问题了。 我们只要把网站的端口按第二步的在 ngrok 设置好就可以穿透了。 4 注意 访问本地网站的必要条件是你的电脑得是开机状态而且有网络。 ","date":"2019-04-03","objectID":"/posts/ngrok/:0:0","tags":["ngrok","linux","宝塔面板","server","ubuntu"],"title":"本地搭建网站服务器并穿透内网","uri":"/posts/ngrok/"},{"categories":["Memo"],"content":" 原文链接 “卓越班”到了大三突然掀起一股毕业慌，一部分人投身于考研的热潮中，一部分人选择了培训机构学习技术。而我出于种种原因既不考研也不培训，选择自学 java 和 web 相关的知识，也希望因此能在以后谋得一份心仪的工作。 如果文章中有出现纰漏、错误之处，还请看到的小伙伴多多指教，先行谢过 9 HTML 9.1 1. Doctype 作用，HTML5 为什么只需要写 \u003c!DOCTYPE HTML\u003e doctype 是一种标准通用标记语言的文档类型声明，目的是告诉标准通用标记语言解析器要使用什么样的文档类型定义（DTD）来解析文档。\u003c!DOCTYPE\u003e声明必须是 HTML 文档的第一行，位于 html 标签之前 HTML5 不基于 SGML，所以不需要引用 DTD。在 HTML5 中\u003c!DOCTYPE\u003e只有一种 SGML: 标准通用标记语言，是现时常用的超文本格式的最高层次标准 9.2 2. 行内元素有哪些，块级元素有哪些，空 (void) 元素有那些 行内元素：a span i img input select b 等 块级元素：div ul ol li h1~h6 p table 等 空元素：br hr link 等 9.3 3. 简述一下你对 HTML 语义化的理解 简单来说，就是合适的标签做合适的事情，这样具有以下好处： 有助于构架良好的 HTML 结构，有利于搜索引擎的建立索引、抓取，利于 SEO 有利于不同设备的解析 有利于构建清晰的机构，有利于团队的开发、维护 9.4 4. 常见的浏览器内核有哪些，介绍一下你对浏览器内核的理解 Trident 内核：IE Gecko 内核：NETSCAPE6 及以上版本，火狐 Presto 内核：Opera7 及以上。[Opera 内核原为：Presto，现为：Blink;] Webkit 内核：Safari，Chrome 等。[Chrome 的：Blink（WebKit 的分支）] 浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。 渲染引擎主要负责取得网页的内容、整理讯息、计算网页的显示方式等，JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果。 9.5 5. html5 有哪些新特性 语义化标签：header footer nav section article aside 等 增强型表单：date（从一个日期选择器选择一个日期） email（包含 e-mail 地址的输入域） number（数值的输入域） range（一定范围内数字值的输入域） search（用于搜索域） tel（定义输入电话号码字段）等 视频和音频：audio video Canvas 绘图 SVG 绘图 地理定位：Geolocation 拖放 API：drag web worker：是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能 web storage: localStorage sessionStorage WebSocket: HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议 9.6 6. 描述一下 cookie，sessionStorage 和 localStorage 的区别 特性 Cookie localStorage sessionStorage 生命周期 可设置失效时间，没有设置的话，默认是关闭浏览器后失效 除非被手动清除，否则将会永久保存 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除 存放数据大小 4KB 左右 可以保存 5MB 的信息 可以保存 5MB 的信息 http 请求 每次都会携带在 HTTP 头中，如果使用 cookie 保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信 仅在客户端（即浏览器）中保存，不参与和服务器的通信 9.7 7. 如何实现浏览器内多个标签页之间的通信 使用 localStorage: localStorage.setItem(key,value)、localStorage.getItem(key) websocket 协议 webworker 多个标签页之间的通信 9.8 8. HTML5 的离线存储怎么使用，解释一下工作原理 HTML5 的离线存储 9.9 9. src 与 href 的区别 区别：src 用于替代这个元素，而 href 用于建立这个标签与外部资源之间的关系 \u003clink href=\"style.css\" rel=\"stylesheet\" /\u003e浏览器加载到这里的时候，html 的渲染和解析不会暂停，css 文件的加载是同时进行的 \u003cscript src=\"script.js\"\u003e\u003c/script\u003e当浏览器解析到这句代码时，页面的加载和解析都会暂停直到浏览器拿到并执行完这个 js 文件 9.10 10. 表单提交中 Get 和 Post 方式的区别 Get 一般用于从服务器上获取数据，Post 向服务器传送数据 Get 传输的数据是拼接在 Url 之后的，对用户是可见的；Post 的传输数据对用户是不可见的 Get 传送的数据量较小，不能大于 2KB。Post 传送的数据量较大，一般被默认为不受限制 Get 安全性非常低，Post 安全性较高 在 FORM 提交的时候，如果不指定 Method，则默认为 Get 请求 10 CSS 10.1 1. css 盒子模型，box-sizing 属性的理解 css 的盒模型由 content（内容）、padding（内边距）、border（边框）、margin（外边距）组成。但盒子的大小由 content+padding+border 这几部分决定 box-sizing 是一个 CSS3 属性，与盒子模型有着密切联系。即决定元素的宽高如何计算，box-sizing 有三个属性： box-sizing: content-box|border-box|inherit: content-box 使得元素的宽高即为内容区的宽高（默认模式） border-box: 计算方式 content + padding + border = 本身元素大小，即缩小了 content 大小 inherit 指定 box-sizing 属性的值，应该从父元素继承 10.2 2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法 浮动的元素是脱离文档标准流的，如果我们不清楚浮动，那么就会造成父元素高度塌陷，影响页面布局。 清除浮动的方式： 为父元素设置高度 为父元素添加overflow:hidden 伪元素 .fix::after { content: ''; display: block; clear: both; } 使用伪元素的好处：不增加冗余的 DOM 节点，符合语义化 overflow:hidden 可以触发 BFC 机制。BFC：块级格式化上下文，创建了 BFC 的元素就是一个独立的盒子，它规定了内部如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素，计算 BFC 的高度时，浮动元素也参与计算 10.3 3. 如何让一个不定宽高的盒子水平垂直居中 定位的方式 .father { position: relative; } .son { position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto; } css3 属性 .father { position: relative; } .son { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } flex 布局 .father { display: flex; justify-content: center; align-items: center; } 10.4 4. px 和 em 和 rem 的区别 px: 像素，相对长度单位。像素px是相对于显示器屏幕分辨率而言的 em的值并不是固定的，会继承父级元素的字体大小，代表倍数 rem的值并不是固定的，始终是基于根元素 \u003chtml\u003e 的，也代表倍数 10.5 5. position 的值有哪些 static：默认值。没有定位，元素出现在正常的流中 relative（相对定位）：生成相对定位的元素，相对于其正常（原先本身）位置进行定位 absolute（绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位 fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位 10.6 6. display:none 与 visibility：hidden 的区别 区别 display:none visibility：hidden 的 是否占据空间 不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中） 该元素空间依旧存在 是否渲染 会触发 reflow（回流），进行渲染 只会触发 repaint（重绘），因为没有发现位置变化，不进行渲染 是否是继承属性 不是继承属性，元素及其子元素都会消失 是继承属性，若子元素使用了 visibility:visible，则不继承，这个子孙元素又会显现出 10.7 7. CSS 中 link 和@import 的区别 link 属于 XHTML 标签，@import 完全是 CSS 提供的一种方式，只能加载","date":"2019-03-30","objectID":"/posts/ms-html-css/:0:0","tags":["HTML","CSS"],"title":"前端面试题 - HTML+CSS","uri":"/posts/ms-html-css/"},{"categories":["ACM"],"content":" 我国古代数学家张丘建在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？ 设公鸡，母鸡，小鸡数目分别为 x,y,z(x\u003c=20,y\u003c=33,z\u003c=100) 1 约束条件 x+y+z=100 5x+3y+z/3=100 2 算法分析 若依次枚举 x,y,x, 则至少尝试 21*34*100=71400 次，显然效率太低。 在 x,y 的数目确定后，z 的数目也就确定下来了 100-x-y，无须再进行枚举，此时约束条件只有一个 5x+3y+z/3=100. 只需枚举 x,y，共 21*34=714 次。 3 算法设计 #include\u003cstdio.h\u003e int main(){ int x,y,z; for(x=0;x\u003c=20;x++) //21*34=714 for(y=0;y\u003c=33;y++){ z=100-y-x; if(z%3==0 \u0026\u0026 (5*x+3*y+z/3)==100){//限定 z 能被 3 整除，进一步提高效率 printf(\"cock number:%d\\t\",x); printf(\"hen number:%d\\t\",y); printf(\"chick number:%d\\n\",z); } } return 0; } 运行解 cock number:0 hen number:25 chick number:75 cock number:4 hen number:18 chick number:78 cock number:8 hen number:11 chick number:81 cock number:12 hen number:4 chick number:84 ","date":"2019-03-30","objectID":"/posts/bqbj/:0:0","tags":["ACM"],"title":"百钱百鸡（枚举法）","uri":"/posts/bqbj/"},{"categories":["ACM"],"content":" 大数乘法 c 版 (基础写法) #include\u003cstdio.h\u003e #include\u003cstring.h\u003e #define N 202 int main() { int a[N] = {0}, b[N] = {0}, c[404] = {0}, la, lb, i, j,k, d = 0, n1, n2;//202 位数相乘，最长 404 位数 int get(int *p); void change(int *a, int *b, int n); la = get(a); lb = get(b); n1 = la \u003e lb ? la : lb;//较长的数长 n2 = la \u003c lb ? la : lb;//较短的数长 if (la \u003c lb) change(a, b, lb); //模拟乘法运算过程（进位等考虑） for (i = 0; i \u003c n2; i++) { for (j = 0; j \u003c n1; j++) { c[j + i] += (b[i] * a[j] + d)%10; d = (b[i] * a[j] + d) / 10; if (c[j+i]\u003e9){ d++; c[j+i]%=10; } if (a[j+1]==0\u0026\u0026d!=0){ k=j+i+1; c[k]=d; } } d=0; } k=k\u003e(j+i-2)?k:j+i-2; for (i = k; i \u003e= 0; i--)//将倒序装入的结果打印 printf(\"%d\", c[i]); return 0; } //输入字符串作为数字，并返回数字去除前导 0 后的长度 int get(int *p) { char x[N]; int l, i, ex = 0; scanf(\"%s\", x); l = strlen(x); while (x[ex] == '0') ex++; for (i = ex; i \u003c l; i++) //提取字符串数字到 int 数组，倒序排列 *(p + l - i - 1) = x[i] - '0'; return l - ex; } void change(int *a, int *b, int n) { int i, t; for (i = 0; i \u003c n; i++) { t = a[i]; a[i] = b[i]; b[i] = t; } } 程序运行结果 1234567890123456789 98765432109876543210 121932631124517831023715309991126352690 ","date":"2019-03-28","objectID":"/posts/dacheng/:0:0","tags":["数学","大数运算","ACM","C"],"title":"大数乘法","uri":"/posts/dacheng/"},{"categories":["Grocery"],"content":" 记录自己在配置 vps 及博客 SSL 证书时遇到的问题。 1 强制重定向 https 有一种情况相信很多人都遇到过，就是虽然我们配置了 ssl 证书，但是 https 和 http 地址都是各自都可以单独访问。我们应该也见过类似于 github 的代码托管网站有强制 https 的开关。如果是这种情况我们还可以通过 js 进行 301 定向。 \u003cscript\u003e var targetProtocol = \"https:\"; var host = \"lruihao.cn\"; if (window.location.host == host \u0026\u0026 window.location.protocol != targetProtocol){ window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); } \u003c/script\u003e 2 腾讯云 CDN 配置 这个博客后来是转到了腾讯云的 cos 桶存储。当时在桶内静态网站设置的时候，设置强制 https 发现会出错。而且还接入了 CDN，所以今天在 CDN 设置那里也看到了 https 的设置，打开强制 https 就 OK 了。这天在三丰云撸了一个免费的主机，搭了一个 WordPress（想试试 wp 的感觉），然后 vps 的 SSL 问题现在也很简单了，第一步，到腾讯云申请免费证书；第二步，配置 CDN，按步骤来，其中接入方式选择自有源站；第三步，强制 https（可选）。 ","date":"2019-03-28","objectID":"/posts/http2https/:0:0","tags":["SSL","redirect","CDN","JavaScript","server"],"title":"vps 配置 ssl 及 https 重定向","uri":"/posts/http2https/"},{"categories":["Memo"],"content":"基于 hexo-theme-next 6.0+的 Pisces 模板做的 DIY 扩展性设计","date":"2019-03-21","objectID":"/posts/hexo-theme-next/","tags":["Hexo","Node.js","他山之石"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Memo"],"content":" 危险 如无必要，不再更新！（2019.09.13） 今晚我做出了一个慎重的决定，由于博主时间精力有限，需要更多的时间来工作和学习。所以我将放弃对 next 的主题的自定义修改，next 主题官方已经更新到了 7.0+的版本，喜欢 next 主题风格的朋友可以在 github 更新。 我这也算是上古版本了，版本差距实在过大，所以我也将放弃博客使用主题的更新。 以下仍为当前博客使用主题，lib 资源已打包 github。 next 基于 hexo-theme-next 6.0+ 的 Pisces 模板做的 DIY 扩展性设计（部分兼容 next 其他几种模板）。主要是一些 custom style 还有一些第三方的 js。修改的地方太多也有点小乱就不提 PR 了。 modified 官方 Demo =\u003e https://theme-next.org 记录一下折腾过程，以后备份恢复博客也好方便自己。本文之前的美化修改请见 hexo 标签。 主题中若有遗漏第三方插件或应用的 key 及 id 值等请修改为自己对应的值 主要的几个自定义文件 _config.swig #主题配置文件 相关账户信息自己注册替换 \\layout\\custom\\head.swig #在头部自定义加入标签 \\layout\\custom\\google_adsense.swig #谷歌广告模块，内有注释暂时弃用 \\layout\\_layout.swig #主布局 \\layout\\_macro\\post.swig #文章布局 \\layout\\_macro\\post-copyright.swig #文章版权 \\layout\\_macro\\siderbar.swig #侧栏模板 \\layout\\_third-party\\copy-code.swig #复制按钮 \\layout\\_partials\\comments.swig #评论主模板 \\layout\\_partials\\footer.swig #底部模板#该模块在 layout.swig 引入，用于在 body 自定义标签 \\layout\\_partials\\footer_custom.swig #footer 自定义文件 \\layout\\_third-party\\custom.swig #该模块在 layout.swig 引入用于在 body 自定义标签 \\source\\css\\_custom\\customs.styl #主要用户自定义样式表 \\source\\fonts\\ #引入了一些我的手写体及外部字体 \\scripts\\qcloudcdn.js #腾讯云 cos 桶刷新缓存的脚本，不需要可删掉 [^1] ^1 9 初步安装 安装整个改过的主题，然后下载相应的 lib 资源解压放入 source 文件夹 cd hexo git clone https://github.com/Lruihao/hexo-theme-next themes/next 主题配置文件_config.yml, 选择主题 theme: next lib 下载 http://github.com/Lruihao/hexo-theme-next/releases/tag/v6.9.1 10 更新内容 更多自定义详见源码 10.1 links 模板 自定义友链模板，打开hexo\\themes\\next\\layout\\新建links.swig文件，写下以下内容后保存。 {% extends '_layout.swig' %} {% import '_macro/sidebar.swig' as sidebar_template %} {% block title %}{# #}{% set page_title_suffix = ' | ' + title %}{# #}{% if page.type === \"categories\" and not page.title %}{# #}{{ __('title.category') + page_title_suffix }}{# #}{% elif page.type === \"tags\" and not page.title %}{# #}{{ __('title.tag') + page_title_suffix }}{# #}{% elif page.type === \"photos\" and not page.title %}{# #}{{ __('title.photos') + page_title_suffix }}{# #}{% else %}{# #}{{ page.title + page_title_suffix }}{# #}{% endif %}{# #}{% endblock %} {% block page_class %}page-post-detail{% endblock %} {% block content %} \u003cdiv id=\"posts\" class=\"posts-expand\"\u003e {##################} {#### PAGE BLOCK ###} {##################} \u003cdiv class=\"post-block page\"\u003e {% include '_partials/page-header.swig' %} {#################} {#### PAGE BODY ###} {#################} \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003cdiv class=\"post-body{% if theme.han %} han-init-context{% endif %}{% if page.direction \u0026\u0026 page.direction.toLowerCase() === 'rtl' %} rtl{% endif %}\"\u003e \u003cdiv class=\"links-list\"\u003e {% for svg,link in site.data.links %} \u003cdiv class=\"card-box\" title=\"{{ link.info }}\"\u003e \u003ca href=\"{{ link.site }}\" target=\"_blank\"\u003e {% if link.avatar %} \u003cimg class=\"card-avatar\" data-original=\"{{ link.avatar }}\" alt=\"{{ link.nickname }}\"/\u003e {% else %} \u003csvg class=\"card-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{svg+1}}\"\u003e\u003c/use\u003e \u003c/svg\u003e {% endif %} \u003cspan title=\"{{ link.nickname }}\"\u003e@{{ link.nickname }}\u003c/span\u003e \u003c/a\u003e \u003c/div\u003e {% endfor %} \u003c/div\u003e {{ page.content }} \u003c/div\u003e \u003cstyle\u003e /* @Author: lruihao.cn */ .links-list { margin-top: 1rem; display: flex; flex-direction: row; justify-content: space-between; flex-wrap: wrap; } .card-box { width: 150px; height: 200px; font-size: 1rem; text-align: center; background: rgba(255,255,255,0.3); box-sizing: border-box; box-shadow: 3px 3px 5px #aaa; border-radius: 5px; transition-duration: 0.3s; margin-bottom: 1rem; display: flex; flex-direction: column; } .card-box:hover { background: #fff; transform: scale(1.03); box-shadow: 0 0 3px #aaa; } .card-box a { border:none; } .card-avatar { width: 100%!important; height: 150px!important; border-radius: 5px; margin: 0; padding: 0; } .card-box span{ display: block; position: relative; bottom: 1rem; align-self: flex-end; color: #2bbc8a; font-weight: bold; max-width: 100%; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; margin-top: 15px; } .card-box span:hover { color: #d480aa; } \u003c/style\u003e {#####################} {#### END ","date":"2019-03-21","objectID":"/posts/hexo-theme-next/:0:0","tags":["Hexo","Node.js","他山之石"],"title":"hexo-theme-next @modified LRH","uri":"/posts/hexo-theme-next/"},{"categories":["Java"],"content":" 摘要：Java 基本的对象初始化过程，子类的初始化，以及涉及到父类和子类的转化时可能引起混乱的情况。 1 基本初始化过程 对于一个简单类的初始化过程是： static 修饰的模块（static 变量和 static 块） =\u003e 按照代码顺序依次执行。 ↓ 实例变量 及非 static 模块 =\u003e 按照代码顺序依次执行。 ↓ 构造函数 =\u003e 执行对应的构造函数。 2 子类的初始化过程 父类 static 修饰的模块 ↓ 子类 static 修饰模块 ↓ 父类实例变量和非 static 块 ↓ 父类对应构造函数。当子类对应构造函数中没有显示调用时调用的是父类默认的构造函数。 ↓ 子类实例变量和非 static 块 ↓ 子类构造函数 package code0507; public class Demo { public static void main(String[] args) { Sub sub = new Sub(); System.out.println(sub); } } class Super { int a = 6; public Super() { test(); //被子类同名函数覆盖，优先访问子类 test } int b=9; public void test() { System.out.println(a); } } class Sub extends Super { int a = 8; public Sub() { test(); } public void test() { System.out.println(a); } } 运行结果 0 8 ","date":"2019-03-21","objectID":"/posts/substatus/:0:0","tags":["Java"],"title":"Java 父类子类的对象初始化过程","uri":"/posts/substatus/"},{"categories":["OS"],"content":" 双系统默认启动项是 Ubuntu，而日常使用最多的还是 Windows，所以说很不方便，一不小心就开机到 Ubuntu 去了。今天来设置一下。 1 修改/etc/default/grub文件 同时按住键盘上的“Ctrl Alt T”三个键（即快捷键“Ctrl+Alt+T”），打开终端窗口。在终端内输入 sudo gedit /etc/default/grub 按 Enter 键确认，提示输入用户密码，输入的用户密码是看不见的，不要管它，输入完成确认即可打开 grub 文件。 把 grub 文件中的 GRUB_DEFAULT=0 中的 0 改为 saved, 把 GRUB_TIMEOUT=10 中的 10 改为 5。（这里的 5 表示开机时等待选择操作系统是时间是 5 秒） 在文件末尾添加 GRUB_SAVEDEFAULT=true后保存文件并退出。 2 更新启动配置文件 在终端输入 sudo update-grub 按 Enter 键确认 3 重启 sudo reboot或者点击重启，重启到启动菜单时，选择你要更改为默认启动项的系统，按 Enter 键确认启动即可，下次启动时刚刚选择的系统即为默认启动系统，直到你手动选择启动其他的系统为止。以后可以轻松的来回切换默认系统了。 ","date":"2019-03-21","objectID":"/posts/windefault/:0:0","tags":["linux","windows","ubuntu"],"title":"ubuntu + windows 双系统默认启动项设置","uri":"/posts/windefault/"},{"categories":["瞎折腾","PHP"],"content":" 宅音乐播放器，HTML5 网页播放器，集成后台管理及 API 调用，目前正在开发中，敬请关注~ 原项目 由 IT 技术宅 开源，使用 thinkPHP 开发后台。 fork 地址 是我个人学习模仿的库，也是相当于备份源码。 注：插件修改于明月浩空免费版，仅用于学习交流，无商业价值，如发现商业传播，将禁止软件的免费使用。 17 技术栈 后端：thinkphp 5.1 前端：layui 数据库：mysql 18 演示站 已兼容移动端，测试账号仅供测试请勿修改密码！ test test123 https://player.ilt.me/ https://player.lruihao.cn/ 19 安装 19.1 视频安装教程 https://www.bilibili.com/video/av46476706 19.2 依赖 composer php 5.6+ mysql 5.5+ 19.3 步骤 安装 php 依赖包 composer install 配置数据库，配置链接数据库名以及用户名密码 /config/database.php 创建数据库 字符编码：utf8 -- UTF-8 Unicode 导入数据库脚本，脚本位置 extend/database 19.4 伪静态配置 19.4.1 nginx location / { index index.htm index.html index.php; #访问路径的文件不存在则重写 URL 转交给 ThinkPHP 处理 if (!-e $request_filename) { rewrite ^/(.*)$ /index.php?s=$1 last; break; } } 19.4.2 apache 项目自带 apache 静态化无需配置 19.5 启动项目 添加 public 为 web 根目录 若为 apache 服务器则默认伪静态，nginx 可自行配置伪静态 20 预览 20.1 首页 20.2 登陆页面 20.3 后台首页 20.4 后台播放器管理页面 20.5 后台歌单管理页面 ","date":"2019-03-19","objectID":"/posts/player/:0:0","tags":["PHP","ThinkPHP","Layui","MySQL"],"title":"宅音乐播放器","uri":"/posts/player/"},{"categories":["OS"],"content":"极速方便的一键配置与管理，免除繁琐的命令行操作，通过 Web 面板一键即可操作实现。可选择安装 lamp 或者 lnmp 环境，可创建及管理网站，可创建及管理数据库，可创建及管理 FTP 等等。宝塔官网介绍 1 系统要求 操作系统：全新系统（支持 CentOS、Ubuntu、Debian、Fedora、Deepin)， 确保是干净的操作系统，没有安装过其它环境带的 Apache/Nginx/php/MySQL 宝塔 Linux6.0 版本是基于 centos7 开发的，强烈建议使用 centos7.x 系统 内存要求：内存要求最低 512MB，推荐 768MB 以上，纯面板约占系统 60MB 内存。 2 安装方法 官方号称 2 分钟装好面板，一键管理服务器。 使用 SSH 连接工具，如宝塔远程桌面助手连接到你的 Linux 服务器后，挂载磁盘，根据系统执行相应命令开始安装（大约 2 分钟完成面板安装）： yum install -y wget \u0026\u0026 wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 sh install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 sudo bash install.sh wget -O install.sh http://download.bt.cn/install/install-ubuntu_6.0.sh \u0026\u0026 bash install.sh wget -O install.sh http://download.bt.cn/install/install_6.0.sh \u0026\u0026 bash install.sh 3 搭建 ftp 和云盘服务器 可以很傻瓜式的搭建自己的云盘，和平时用的比较多的 ftp 服务器。搭建静态网站也可以用 ftp 来上传文件。 ","date":"2019-03-18","objectID":"/posts/bt/:0:0","tags":["linux","server","宝塔面板"],"title":"宝塔面板安装","uri":"/posts/bt/"},{"categories":["Memo"],"content":" 下面一些 web 开发的一些总结，还有一些常用到的代码，脚本等！ 9 front-end 9.1 html HTML+CSS 9.1.1 oblique 和 intalic 的区别 这两个都是font-style属性的值，这两个值都能实现倾斜的效果，但是有区别的。 intalic: 这个是字体的倾斜，相当于斜体，字体必须有倾斜属性。 oblique: 这个准确地说是让文字倾斜。相当于斜字，字体不一定要有倾斜属性。 9.1.2 title 显示换行 使用\u0026#10;或使用\u0026#13; \u003ca href=\"#\" title=\"第一行\u0026#10; 第二行\u0026#10; 第三行\"\u003e使用`\u0026#10;`\u003c/a\u003e \u003ca href=\"#\" title=\"第一排\u0026#13; 第二排\u0026#13; 第三排\"\u003e使用`\u0026#13;`\u003c/a\u003e 9.1.3 图片类型选择 图片类型选择 9.2 css 9.2.1 flexbox Flex 布局将成为未来布局的首选方案，比如说常见的 bootstrap4 的版本就用 flex 替代了 float 来进行排版。 我在网上看到几个很好的教程，图文并茂，一目了然。 A Complete Guide to Flexbox Flex 布局教程：语法篇 实在懒癌发作，笔记本上手抄了笔记我就不写学习总结了，还有网友 Demo 也写了。 9.3 javascript 9.3.1 keydown 和 keypress keydown：按下键盘键 keypress：紧接着keydown事件触发（只有按下字符键时触发） 如果用户按下了一个字符键不放，就会重复触发keydown和keypress事件，直到用户松开该键为止。 如果用户按下了一个非字符键不放，就会重复触发keydown事件，直到用户松开该键为止。 详解键盘事件 (keydown，keypress，keyup) 9.3.2 textContent、innerText 和 innerHTML 的区别 设置标签中的文本内容，应该使用textContent或innerText（更老）属性，区别在于浏览器支援程度 innerHTML能够获得元素内的所有标签内容，也可以设置标签使之生效。（注意防止 XSS 注入） 如果某个属性在浏览器中不支持，那么这个属性的类型是undefined，判断这个属性的类型是不是undefined，就知道浏览器是否支持。 \u003cscript\u003e // 设置任意的标签中间的任意文本内容 function setInnerText(element, text) { //判断浏览器是否支持这个属性 if (typeof element.textContent == \"undefined\") {//不支持 element.innerText = text; } else {//支持这个属性 element.textContent = text; } }; \u003c/script\u003e 9.4 图床方案 自行搭建 比如使用开源图床 ImgURL 搭建的img.lruihao.cn（需要服务器） 使用上传工具加第三方免费空间，比如PicGo + 腾讯云 COS（无需服务器） 使用各大图床 诸如 sm.ms，腾讯云 COS，阿里云 OSS，七牛云，又拍云，Github，微博图床，ImgURL 图床等等 9.5 font-awesome 现在使用 5 的版本，可以使用webfont+css或svg+js \u003clink rel=\"stylesheet\" href=\"https://cdn.staticfile.org/font-awesome/4.7.0/css/font-awesome.css\"\u003e 其他的图标 js \u003cscript src=\"//at.alicdn.com/t/font_578712_g26jo2kbzd5qm2t9.js\"\u003e\u003c/script\u003e \u003csvg class=\"card-avatar\" aria-hidden=\"true\"\u003e \u003cuse xlink:href=\"#icon-{{n+1}}\"\u003e\u003c/use\u003e \u003c!--n 为一个数字--\u003e \u003c/svg\u003e 9.6 响应式（自适应） \u003clink rel=\"stylesheet\" href=\"https://apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css\"\u003e \u003cscript src=\"https://apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0,user-scalable=0\"\u003e .col-xs- 超小屏幕 手机 \u003c768px .col-sm- 小屏幕 平板 \u003e=768px .col-md- 中等屏幕 \u003e=992px .col-lg- 大屏幕 \u003e1200px css3 写法 @media（宽度具体调整） /* 手机等小屏幕手持设备 */ @media screen and (min-width: 320px) and (max-width: 480px) { /*手机端 css 样式表*/ } /* 平板之类的宽度 1024 以下设备 */ @media only screen and (min-width: 321px) and (max-width: 1024px) { /*电脑端 css 样式表*/ } link 引入不同 css \u003c!--手机端--\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"style_phone.css\" media=\"screen and (max-width: 960px)\"/\u003e \u003c!--电脑端--\u003e \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"style_PC.css\" media=\"screen and (min-width: 960px)\"/\u003e 9.7 jquery \u003cscript src=\"https://code.jquery.com/jquery-3.3.1.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://lib.sinaapp.com/js/jquery/2.0.2/jquery-2.0.2.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"http://cdn.bootcss.com/jquery/1.11.0/jquery.min.js\"\u003e\u003c/script\u003e //还有其他的源 ... 9.8 QQ 推广链接 QQ 推广 QQ 群 \u003ca target=\"_blank\" href=\"https://wpa.qq.com/msgrd?v=3\u0026uin=1074627678\u0026site=qq\u0026menu=yes\"\u003e\u003cimg border=\"0\" src=\"http://wpa.qq.com/pa?p=2:1074627678:51\" alt=\"点击这里给我发消息\" title=\"点击这里给我发消息\"/\u003e\u003c/a\u003e 9.9 Google fonts https://fonts.google.com/ 一般选用国内源镜像替代（待补充 ...） + https://fonts.loli.net + //fonts.lug.ustc.edu.cn 9.10 fancybox github 介绍 fancybox 源 \u003clink href=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css\" rel=\"stylesheet\"\u003e \u003cscript src=\"https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js\"\u003e\u003c/script\u003e 10 back-end 更多学习内容见 学习课件 练习作业 源码+Demo ","date":"2019-03-18","objectID":"/posts/webbiji/:0:0","tags":["JavaScript"],"title":"web 汇总","uri":"/posts/webbiji/"},{"categories":["Java"],"content":" 泛型方法，它在修饰符后，返回值类型前增加了类型参数 (\u003c\u003e) 类型通配符一般使用问号?代替具体的类型实参，注意不是类型形参。 1 代码 package code0507; public class WildCardTest { public static void main(String[] args) { Box\u003cString\u003ename=new Box\u003cString\u003e(\"hello\"); Box\u003cInteger\u003eage=new Box\u003cInteger\u003e(12); Box\u003cDouble\u003enumber=new Box\u003cDouble\u003e(210.50); Box\u003cInteger\u003epoint=new Box\u003cInteger\u003e(); getData(name); getData(age); getData(number); point.printpoint(520, 1314); point.printpoint(\"me\", \"too\"); } public static void getData(Box\u003c?\u003edata){//类型通配符 System.out.println(\"data:\"+data.getData()); } } class Box\u003cT\u003e{ private T data; public Box() {}//构造方法重载 public Box(T data) { setData(data); } public T getData() { return data; } public void setData(T data) { this.data = data; } //定义泛型方法 public\u003cT1,T2\u003evoid printpoint(T1 x,T2 y){ T1 m=x; T2 n=y; System.out.println(\"This point is:\"+m+\",\"+n); } } 2 运行结果 data:hello data:12 data:210.5 This point is:520,1314 This point is:me,too ","date":"2019-03-16","objectID":"/posts/fanxing/:0:0","tags":["泛型","Java"],"title":"java 泛型 test","uri":"/posts/fanxing/"},{"categories":["Memo"],"content":"1 基本使用 A: 选择一个工作空间 D:\\develop\\eclipse-SDK-3.7.2-win64\\workspace B: 如何写一个 HelloWorld 案例（代码以项目为基本单位） a: 创建项目（工程） *File -- New -- Java Project *在左边空白处，直接右键 -- New -- Java Project 键入项目名称后直接 Finish。 b: 所有的 java 文件必须写到 src 下面才有效 c: 创建一个包 cn.lruihao d: 在包下创建一个类 HelloWorld 同时让它帮我们写好了 main 方法。 e: 在 main 方法中写内容即可 f: 编译程序 自动编译，在保存的那一刻帮你做好了 g: 运行程序 选择要运行的文件或者在要运行的文件内容中 右键 -- Run as - Java Application 即可 h: 内容显示 在 Console 控制台显示内容 2 Eclipse 的基本设置 A: 程序的编译和运行的环境配置（如果你的 Eclipse 启动没有问题，就不要配置了） B: 去掉默认注释（可以不用改） C: 行号的显示和隐藏 显示：在代码区域的最左边的空白区域，右键 -- Show Line Numbers 即可。 隐藏：把上面的动作再做一次。 D: 字体大小及颜色 a:Java 代码区域的字体大小和颜色： window -- Preferences -- General -- Appearance -- Colors And Fonts -- Java 修改 -- Java Edit Text Font b: 控制台 window -- Preferences -- General -- Appearance -- Colors And Fonts -- Debug -- Console font c: 其他文件 window -- Preferences -- General -- Appearance -- Colors And Fonts -- Basic -- Text Font E: 窗体给弄乱了，怎么办 window -- Reset Perspective F: 控制台找不到了 Window--Show View—Console 3 快捷键的使用 A: 内容辅助键 Alt+/ 起提示作用 main+alt+/,syso+alt+/, 给出其他提示 B: 快捷键 格式化 ctrl+shift+f 导入包 ctrl+shift+o 注释 ctrl+/ ctrl+shift+/,ctrl+shift+\\ 代码上下移动 选中代码 alt+上/下箭头 查看源码 选中类名 (F3 或者 Ctrl+鼠标点击） 4 Eclipse 中如何提高开发效率 A: 自动生成构造方法 a: 无参构造方法 在代码区域右键--source--Generate Constructors from Superclass b: 带参构造方法 在代码区域右键--source--Generate Constructors using fields.. -- finish B: 自动生成 get/set 方法 在代码区域右键--source--Generate Getters and Setters... ","date":"2019-03-15","objectID":"/posts/eclipseuse/:0:0","tags":["eclipse","Java"],"title":"eclipse 的基本使用","uri":"/posts/eclipseuse/"},{"categories":["Java"],"content":" java 中匿名类用的最多的地方就是可视化界面设计中，特别是将事件监听器注册到某个组件上的时候。 1 代码 package cn.lruihao; import java.awt.event.*; import javax.swing.*; public class QFrame extends JFrame { public QFrame() { JButton jbtnew=new JButton(\"New\");//新建按钮 JPanel panel=new JPanel();//面板容器 panel.add(jbtnew);//添加组件 add(panel); jbtnew.addActionListener(new ActionListener() { //新建一匿名类，并将该对应的事件监听器注册到“新建”按钮 就 jbtnew 上 @Override public void actionPerformed(ActionEvent e) { JOptionPane.showMessageDialog(null, \"单击了新建按钮\"); System.out.println(\"lruihao.cn\"); } }); } public static void main(String[] args) { JFrame frame=new QFrame(); frame.setTitle(\"QFrame\"); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); frame.pack(); frame.setVisible(true); } } 创建一个可视化界面，界面中有一个按钮，单击按钮显示“单击了新建按钮”。 2 结果 3 参考 JOptionPane 的使用 ","date":"2019-03-15","objectID":"/posts/qframe/:0:0","tags":["GUI","Java"],"title":"匿名类在可视化界面中的应用","uri":"/posts/qframe/"},{"categories":["JavaScript"],"content":" 模仿知乎的卡片式链接，idea 来自 [兰州小红鸡] 1 源码 2021/10/2 1:29 更新 这是一种后加载，创建linkcard.js放到source/js/src/，然后在next\\layout\\_macro\\post.swig中引用 function cardLink() { let $cardLinks = document.querySelectorAll('.card-link'); if ($cardLinks.length === 0) { return; } //插入样式 let $linkStyle = document.createElement('style'); $linkStyle.innerHTML = '.card-link,.card-link:hover{text-decoration:none;border:none!important;color:inherit!important}.card-link{position:relative;display:block;margin:1em auto;width:390px;box-sizing:border-box;border-radius:12px;max-width:100%;overflow:hidden;color:inherit;text-decoration:none}.ztext{word-break:break-word;line-height:1.6}.card-link-backdrop{position:absolute;top:0;left:0;right:0;bottom:0;background-image:url(/images/card-link-bg.jpg);background-repeat:no-repeat;-webkit-filter:blur(20px);filter:blur(20px);background-size:cover;background-position:center}.card-link,.card-link:hover{text-decoration:none;border:none!important;color:inherit!important}.card-link-content{position:relative;display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:inherit;background-color:rgba(246,246,246,0.88)}.card-link-text{overflow:hidden}.card-link-title{display:-webkit-box;-webkit-line-clamp:2;overflow:hidden;text-overflow:ellipsis;max-height:calc(16px * 1.25 * 2);font-size:16px;font-weight:500;line-height:1.25;color:#1a1a1a}.card-link-meta{display:flex;margin-top:4px;font-size:14px;line-height:20px;color:#999;white-space:nowrap}.card-link-url{display: inline-flex;align-items: center;}.card-link-imageCell{margin-left:8px;border-radius:6px}.card-link-image{display:block;width:60px;height:60px;border-radius:inherit}'; document.querySelector('body').appendChild($linkStyle); //渲染 DOM for (let $cardLink of $cardLinks) { $cardLink.innerHTML = `\u003cspan class='card-link-backdrop'\u003e\u003c/span\u003e\u003cspan class='card-link-content'\u003e\u003cspan class='card-link-text'\u003e\u003cspan class='card-link-title'\u003e${$cardLink.innerText}\u003c/span\u003e\u003cspan class='card-link-meta'\u003e\u003cspan class='card-link-url'\u003e\u003csvg class='Zi Zi--InsertLink' fill='currentColor' viewBox='0 0 24 24' width='17' height='17'\u003e\u003cpath d='M6.77 17.23c-.905-.904-.94-2.333-.08-3.193l3.059-3.06-1.192-1.19-3.059 3.058c-1.489 1.489-1.427 3.954.138 5.519s4.03 1.627 5.519.138l3.059-3.059-1.192-1.192-3.059 3.06c-.86.86-2.289.824-3.193-.08zm3.016-8.673l1.192 1.192 3.059-3.06c.86-.86 2.289-.824 3.193.08.905.905.94 2.334.08 3.194l-3.059 3.06 1.192 1.19 3.059-3.058c1.489-1.489 1.427-3.954-.138-5.519s-4.03-1.627-5.519-.138L9.786 8.557zm-1.023 6.68c.33.33.863.343 1.177.029l5.34-5.34c.314-.314.3-.846-.03-1.176-.33-.33-.862-.344-1.176-.03l-5.34 5.34c-.314.314-.3.846.03 1.177z' fill-rule='evenodd'\u003e\u003c/path\u003e\u003c/svg\u003e\u003c/span\u003e${$cardLink.href}\u003c/span\u003e\u003c/span\u003e\u003cspan class='card-link-imageCell'\u003e\u003cimg class='card-link-image' alt='card-link icon' src='/images/linkicon.png'\u003e\u003c/span\u003e\u003c/span\u003e`; } } window.onload = () =\u003e { cardLink(); }; 2 使用 \u003c!--知乎卡片链接--\u003e \u003cscript type=\"text/javascript\" src=\"/js/src/card-link.js\"\u003e\u003c/script\u003e html 链接写法，a 标签加上class=\"card-link\" \u003ca href=\"https://github.com/Lruihao/lruihao.github.io\" target=\"_blank\" class=\"card-link\"\u003eLruihao 博客\u003c/a\u003e Lruihao 博客 https://github.com/Lruihao/lruihao.github.io ","date":"2019-03-15","objectID":"/posts/linkcard/:0:0","tags":["Hexo","JavaScript"],"title":"模仿知乎卡片式链接","uri":"/posts/linkcard/"},{"categories":["OS"],"content":" 我的 Ubuntu 和 Windows 双系统是 Ubuntu 是第一启动项，所以总是开机忘记点下键，一进 Ubuntu 系统时间就不对了（总是少了 8 小时），回到 Windows 时间也是错的。知道是错的调整一下还好。忘记调了有时候真的会误事。比如说 git 版本控制提交会遇到问题种种等。 1 原因 在安装 Ubuntu 和 Windows 双系统的情况下，Ubuntu 的时间总会和 Windows 的时间相差 8 小时，原因在于 widows 认为 BIOS 时间是本地时间，Ubuntu 认为 BIOS 时间是 UTC 时间，即协调世界时，(Universal Time Coordinated) 英文缩写，是由国际无线电咨询委员会规定和推荐，并由国际时间局 (BIH) 负责保持的以秒为基础的时间标度。UTC 相当于本初子午线（即经度 0 度）上的平均太阳时，过去曾用格林威治平均时 (GMT) 来表示。北京时间比 UTC 时间早 8 小时，以 1999 年 1 月 1 日 00:00 UTC 为例，UTC 时间是零点，北京时间为 1999 年 1 月 1 日早上 8 点整。)，所以我们在时间上面相隔了 8 个小时。这个时候 bios 的时间和系统的时间当然是不一致，一个代表 utc 时间，一个代表 cst（＋ 8 时区），即我们常用的时间。 2 方法一 在 Windows 下 进行如下修改：（博主 win10,win7 自测） 以管理员身份运行 CMD（win+x 后选择 Windows Powershell（管理员） Reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\TimeZoneInformation /v RealTimeIsUniversal /t REG_DWORD /d 1 重启看看时间发现 ok 了。 3 方法二 老版 Ubuntu（Ubuntu10 左右）： 修改 /etc/default/rcS 文件 编辑 /etc/default/rcS 将 UTC=yes改成 UTC=no 。 新版 Ubuntu（Ubuntu16.04）： 新版本的 Ubuntu 使用 systemd 启动之后，时间也改成了由 timedatectl 来管理，此方法就不适用了。 $sudo timedatectl set-local-rtc 1 先在 ubuntu 下更新一下时间，确保时间无误： $sudo apt-get install ntpdate $sudo ntpdate time.windows.com 然后将时间更新到硬件上： $sudo hwclock --localtime --systohc 重新进入 windows10，发现时间恢复正常了！ ","date":"2019-03-15","objectID":"/posts/ubuntutime/:0:0","tags":["ubuntu","linux","windows"],"title":"win10,ubuntu 双系统时间不一致","uri":"/posts/ubuntutime/"},{"categories":["JavaScript"],"content":" 以前在 QQ 里面聊天的时候发现，有些链接是卡片式的链接，像知乎里那些一样，就好奇为啥我的域名没有生成卡片。 查了一下百度知道了大概就是 qq 没有抓取到你的网站的 xml。并在其他教程中得到了一个强制提交抓取的 url https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url= 于是就有了脚本刷新的想法。简陋的写了一下。 1 批量式刷新 //设置刷新前缀 url=首页地址（最好使用 https） var base_src = 'https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url=https://lruihao.cn'; //用户地址 //var custom_src = \"https://lruihao.cn\"; //初始化工作地址 var new_src = ''; function createArrayAndOpenWindow() { //alert(\"number function\"); //定义数组存储后缀 var numberArray = new Array(4); //存储后缀 numberArray[0] = '/about/'; numberArray[1] = '/categories/'; numberArray[2] = '/tags/'; numberArray[3] = '/archives/'; //numberArray[4] = \"/guestbook/\"; //遍历 for (var i = 0; i \u003c numberArray.length; i++) { new_src = base_src + numberArray[i]; //打开该地址 open_new(); //清空后缀 new_src = ''; } } //负责打开窗口，并关闭 function open_new() { var new_window = window.open(new_src, '', 'width=400,height=200'); setTimeout(function () { //开启后 200ms（单页）关闭，速度自行把握数组越大时间越多 new_window.close(); }, 2000); } window.onload = function () { createArrayAndOpenWindow(); //设置定时函数，疯狂刷新直到 xml 出现内容 var timer = setInterval('createArrayAndOpenWindow()', 2000); }; 2 单链接刷新 \u003cdiv style=\"text-align: center;\"\u003e \u003cinput type=\"text\" id=\"input\" value=\"\" /\u003e \u003cinput type=\"button\" value=\"疯狂刷新\" onclick=\"yanzheng()\" /\u003e \u003c/div\u003e //设置刷新前缀 url=首页地址（最好使用 https）https://lruihao.cn var base_src = 'https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshareget_urlinfo?url='; //用户地址 var custom_src = ''; //初始化工作地址 var new_src = ''; //负责打开窗口，并关闭 function open_new() { var new_window = window.open(new_src, '', 'width=400,height=200'); setTimeout(function () { //开启后 200ms 关闭 new_window.close(); }, 200); } // 获取验证用户输入 function yanzheng() { var Input = document.getElementById('input'); var oValue = Input.value; custom_src = oValue; new_src = base_src + custom_src; if (oValue == 0) { alert('请输入地址'); } else { var timer = setInterval('open_new()', 200); } } 3 demo 线上 demo 仅做参考请自行下载 效果 ","date":"2019-03-08","objectID":"/posts/qqxml/:0:0","tags":["JavaScript"],"title":"QQ 强制生成卡片式链接","uri":"/posts/qqxml/"},{"categories":["OS"],"content":"1 外存的组织方式 1.1 连续组织方式 连续组织方式的优点 顺序访问容易 顺序访问速度快 连续组织方式的缺点 分配连续的存储空间 必须知道文件长度 删除与插入数据不灵活 动态增长的文件分配空间问题 1.2 链接组织方式 隐式链接 显式链接 1.3 FAT 技术 FAT12 早期的 FAT12 文件系统 以簇为单位的 FAT12 文件系统 FAT16 FAT32 1.4 NTFS 的文件组织方式 NTFS 新特征 磁盘组织 文件的组织 1.5 索引组织方式 单级索引组织方式 多级索引组织方式 增量式索引组织方式 增量式索引组织方式的基本思想 UNIX System V 的组织方式 直接地址 一次间接地址 多次间接地址 2 文件存储空间的管理 2.1 空闲表法和空闲链表法 空闲表法 空闲表 存储空间的分配与回收 空闲链表法 空闲盘块链 空闲盘区链 2.2 位示图法 位示图 盘块的分配（步骤） 顺序扫描示图 转换盘块号 修改位示图 盘块的回收（步骤） 盘块号转换成行列号 修改位示图 2.3 成组链接法 空闲盘块的组织 空闲盘块的分配与回收 3 提高磁盘 I/O 速度的途径 3.1 磁盘高速缓存 数据交付方式 数据交付 指针交付 置换算法 周期性地写回磁盘 3.2 提高磁盘 I/O 速度的其他方法 提前读 延迟写 优化物理块的分布 虚拟盘 3.3 廉价磁盘冗余阵列 (RAID) 并行交叉存取 RAID 的分级 RAID 0 级 RAID 1 级 RAID 2 级 RAID 3 级 RAID 4 级 RAID 5 级 RAID 6 级和 RAID 7 级 RAID 的优点 可靠性高 磁盘 I/O 速度高 性价比高 4 提高磁盘可靠性的技术 4.1 第一级容错技术 SFT-Ⅰ 双份目录和双份文件分配表 热修复重定向和写后读校验 热修复重定向 写后读校验方式 4.2 第二级容错技术 SFT-Ⅱ 磁盘镜像 磁盘双工 4.3 基于集群技术的容错功能 双机热备份模式 双机互为备份模式 公用磁盘模式 4.4 后备系统 磁带机 硬盘 移动磁盘 固定硬盘驱动器 光盘驱动器 CD-ROM 和 DVD-ROM 刻录机 5 数据一致性控制 5.1 事务 事务的定义 事务记录 恢复算法 undo \u003cTi\u003e redo \u003cTi\u003e 5.2 检查点 检查点的作用 新的恢复算法 5.3 并发控制 利用互斥锁实现“顺序性” 利用互斥锁和共享锁实现顺序性 5.4 重复数据的数据一致性问题 重复文件的一致性 链接数一致性检查 ","date":"2019-03-04","objectID":"/posts/cipanadmin/:0:0","tags":["OS","磁盘"],"title":"磁盘存储器的管理","uri":"/posts/cipanadmin/"},{"categories":["JavaScript"],"content":" 请点击验证码处：↑ 验证码 JS 来源互联网 \u003cscript type=\"text/javascript\"\u003e //设置一个全局的变量，便于保存验证码 var code; function createCode(){ //首先默认 code 为空字符串 code = ''; //设置长度，这里看需求，我这里设置了 4 var codeLength = 4; var codeV = document.getElementById('code'); //设置随机字符 var random = new Array(0,1,2,3,4,5,6,7,8,9,'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R', 'S','T','U','V','W','X','Y','Z'); //循环 codeLength 我设置的 4 就是循环 4 次 for(var i = 0; i \u003c codeLength; i++){ //设置随机数范围，这设置为 0 ~ 36 var index = Math.floor(Math.random()*36); //字符串拼接 将每次随机的字符 进行拼接 code += random[index]; } //将拼接好的字符串赋值给展示的 Value codeV.value = code; } //下面就是判断是否== 的代码，无需解释，也可以结合 ajax 在后台做判断 function validate(){ var Input = document.getElementById('input'); var oValue = Input.value.toUpperCase(); if(oValue ==0){ alert('请输入验证码'); }else if(oValue != code){ Input.value = ''; alert('验证码不正确，请重新输入'); createCode(); }else{ Input.value = ''; alert('验证码正确！');//window.open('http://lruihao.cn','_self'); } } //设置此处的原因是每次进入界面展示一个随机的验证码，不设置则为空 window.onload = function (){ createCode(); } \u003c/script\u003e ","date":"2019-03-04","objectID":"/posts/js-vcode/:0:0","tags":["JavaScript"],"title":"JS 验证码","uri":"/posts/js-vcode/"},{"categories":["thoughts"],"content":" 这不是英国作家哈代的《The Return of Native》, 而是我们这辈的父母所经历的常态。 逢近年关，邻居家的王婶又在等她的儿子了。 她的儿子大抵有五年未曾回家了。记得去年，他同王婶说好了回家过年，王婶便从腊月二十直直地等到腊月三十，准备好一桌的年夜饭，最后却只是她一个人随便地扒拉了几口。 我尚且还记得那日，王婶与我母亲一同去河边处理鸡鸭，我也随了去。母亲同王婶说：“源子怎地还不回来？”王婶道：“许是买的车票晚了些，他早前和我说回家过年的，想来还在回来的路上。” 到晚上，万家灯火渐起，都说热热闹闹团圆饭，王婶家却格外冷清。王婶嫁过来时，家中便只有王叔一人，早些年，王叔随人去炸山取石，人也不幸被石头砸死，家中便只有王婶和她儿子二人。王源也知家中境况，自大学毕业后在外工作，至今，除了前年我暑假时回来过一次，其中便从未回来过。 人倒是挺奋进，这些年，王婶家从小木屋变成了三层小洋房，家里也添置了许多家具和电器。王婶倒像一个门卫，守着这栋房子，看着这个家。 不过别家事总归别家事。 王婶是个十分随和的人，也常常和村里人打趣逗乐，常见她笑眼眯眯。一年到头，也唯有这“头”让她难展笑颜。 “王婶子，源哥还没回来吗？” “快了，快了……” 王婶又坐在门口，纳着新鞋，常常一纳就是一天。 我们常听到一个词——衣锦还乡，其实，于父母而言，他们所看重的从来都只是还乡。而所谓衣锦，不过是死要面子者拿来的托辞。衣锦若无，无便无罢，衣锦若有，有便有罢。 衣锦随意，还乡就好。 戊戌年腊月廿七于家中。 ","date":"2019-02-01","objectID":"/posts/renative/:0:0","tags":["随笔","他山之石"],"title":"还乡","uri":"/posts/renative/"},{"categories":["GitHub"],"content":"Lruihao/hexo theme next: Elegant and powerful theme for Hexo.","date":"2019-01-31","objectID":"/projects/lruihao/hexo-theme-next/","tags":[],"title":"Elegant and powerful theme for Hexo.","uri":"/projects/lruihao/hexo-theme-next/"},{"categories":["GitHub"],"content":"hexo-theme-next 如无必要，不再更新！（2019.09.13） 今晚我做出了一个慎重的决定，由于博主时间精力有限，需要更多的时间来工作和学习。所以我将放弃对next的主题的自定义修改，next主题官方已经更新到了7.0+的版本，喜欢next主题风格的朋友可以在github更新。 我这也算是上古版本了，版本差距实在过大，所以我也将放弃博客使用主题的更新。 以下仍为当前博客使用主题，lib资源已打包github。 基于hexo-theme-next 6.0+的Pisces模板做的DIY扩展性设计。主要是一些custom stlye还有一些第三方的js。修改的地方太多也有点小乱就不提PR了。 官方Demo =\u003e https://theme-next.org 记录一下折腾过程，修改内容以博採眾長为准，以后备份恢复博客也好方便自己。本文之前的美化修改请见hexo分类。 主题中若有遗漏第三方插件或应用的key及id值等请修改为自己对应的值 主要的几个自定义文件 _config.swig #主题配置文件 相关账户信息自己注册替换 \\layout\\custom\\head.swig #在头部自定义加入标签 \\layout\\custom\\google_adsense.swig #谷歌广告模块，内有注释暂时弃用 \\layout\\_layout.swig #主布局 \\layout\\_macro\\post.swig #文章布局 \\layout\\_macro\\post-copyright.swig #文章版权 \\layout\\_macro\\siderbar.swig #侧栏模板 \\layout\\_third-party\\copy-code.swig #复制按钮 \\layout\\_partials\\comments.swig #评论主模板 \\layout\\_partials\\footer.swig #底部模板#该模块在layout.swig引入，用于在body自定义标签 \\layout\\_partials\\footer_custom.swig #footer自定义文件 \\layout\\_third-party\\custom.swig #该模块在layout.swig引入用于在body自定义标签 \\source\\css\\_custom\\customs.styl #主要用户自定义样式表 \\source\\fonts\\ #引入了一些我的手写体及外部字体 \\scripts\\qcloudcdn.js #腾讯云cos桶刷新缓存的脚本，不需要可删掉[^1] ^1 初步安装 安装整个改过的主题,然后下载相应的lib资源 cd hexo git clone https://github.com/Lruihao/hexo-theme-next themes/next 更新内容 更多自定义详见源码 links模板 自定义友链模板，打开hexo\\themes\\next\\layout\\新建links.swig文件，写下links.swig内容后保存。 若未使用懒加载请将模板中的data-original属性改为src 若懒加载无法加载预览图请手动添加src=\"/images/loading.gif\" 若fancybox显示alt内容请更换fancybox2或者将alt属值删除 然后hexo n page links新建一个页面文章配置写下如下内容： --- title: 友情链接 layout: links --- 然后在links页面文件夹下面新建文件夹_data，再在里面新建links.yml，内容如下 - nickname: 博採眾長 avatar: http://lruihao.cn/images/avatar.png site: http://lruihao.cn info: 一个菜鸟的博客 - nickname: #友链名称 avatar: #友链头像 site: #友链地址 info: #友链说明 备案信息自定义 # ------------------------------------------------------------- # footer_custom Settings # ------------------------------------------------------------- beian: enable: true gov: 湘公网安备 43030402000254号 recordcode: 43030402000254 icp: 湘ICP备18020535号 文字抖动特效 \u003cdiv class=\"shaky\"\u003e(づ●'◡'●)づ ❥内容区\u003c/div\u003e 左下角微信公众号 \\source\\css\\_custom\\customs.styl 相关文章收纳 加入H5标签，实现可收纳功能，点击查看详情。 Chat Services 共chatra,tidio,daovoice三个选项，三选一 # Chatra Support # See: https://chatra.io # Dashboard: https://app.chatra.io/settings/general chatra: enable: false async: true id: # visit Dashboard to get your ChatraID #embed: # unfinished experimental feature for developers, See: https://chatra.io/help/api/#injectto # Tidio Support # See: https://www.tidiochat.com # Dashboard: https://www.tidiochat.com/panel/dashboard tidio: enable: false key: # Public Key, get it from Dashboard, See: https://www.tidiochat.com/panel/settings/developer #在线客服 daovoice: true daovoice_app_id: xxxx # http://www.daovoice.io/ pdf和Mermaid解析模块 pdf传送门 pdf: enable: false # Default height height: 500px pdfobject: cdn: //cdn.jsdelivr.net/npm/pdfobject@2/pdfobject.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js # Mermaid tag mermaid: enable: false # Available themes: default | dark | forest | neutral theme: forest cdn: //cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js #cdn: //cdnjs.cloudflare.com/ajax/libs/mermaid/8.0.0/mermaid.min.js 模仿csdn转发样式 ... \u003ca class=\"post-title-link\" href=\"{{ url_for(post.path) }}\" itemprop=\"url\"\u003e + {% if post.repost %} + \u003cspan class=\"repost\"\u003e转\u003c/span\u003e + {% endif %} {{ post.title | default(__('post.untitled'))}} \u003c/a\u003e {% else -%} + {% if post.repost %} + \u003cspan class=\"repost\"\u003e转\u003c/span\u003e + {% endif %} {{- post.title -}} ... .repost { color: #5acc79; border: 1px solid #e7f4df; border-radius: 20px; padding: 2px 5px; font-size: 15px; font-weight: 500; } --- title: xxxx repost: true --- 预览 热度页面 打开hexo\\themes\\next\\layout新建top.swig文件，写下如下内容保存： 其中第36行改成你自己的leancloud的appid和appkey,比如我的是在主题配置文件里面的valine配置下，所以我就写成theme.valine.appid。和我一样就不需要修改，其他自行配置。 然后hexo n page top新建一个页面文章配置写下如下内容，limit表示显示篇数： --- title: 热度 layout: top limit: 20 --- 复制按钮样式 本来只想简单美化一下变成night样式的，后来写完发现3dbtn也挺喜欢的。 codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1 border_radius: 5 # Add copy button on codebloc","date":"2019-01-31","objectID":"/projects/lruihao/hexo-theme-next/:0:0","tags":[],"title":"Elegant and powerful theme for Hexo.","uri":"/projects/lruihao/hexo-theme-next/"},{"categories":["Java"],"content":" 引用 继承的好处： 提高了代码的复用性 提高了代码的维护性 让类与类之间产生了关系，是多态的前提 继承的弊端：类的耦合性很强 设计原则：低耦合，高内聚。 耦合：类与类的关系。 内聚：自己完成事情的能力。 1 java 中的继承特点 Java 只支持单继承，不支持多继承。Java 支持多层继承（继承体系） class A { } class B extends A { } /* class C extends A,B { } */ class C extends B { } class ExtendsDemo { public static void main(String[] args) { } } 2 java 中的继承注意事项 子类只能继承父类所有非私有的成员（成员方法和成员变量） 子类不能继承父类的构造方法，但是可以通过 super 关键字去访问父类构造方法。 不要为了部分功能而去继承 那么，我们什么时候考虑使用继承呢？ 继承中类之间体现的是：”is a”的关系。 如果两个类满足这个关系：xxx is a yyy，那么他们就可以使用继承。 Student,Person 对 Dog,Animal 对 Dog,Pig 错 3 继承 继承间的构造方法关系：创建子类对象，会先去访问父类的构造方法。对父类的数据进行初始化。 package jicheng; class Fu{ public int num = 10; public Fu(){ System.out.println(\"父类\"); } } class Zi extends Fu{ public int num = 20; public Zi(){ System.out.println(\"子类\"); } public void show(){ int num = 30; System.out.println(num);//30 System.out.println(this.num);//20 System.out.println(super.num);//10 } } public class test { public static void main(String[] args) { Zi z = new Zi(); z.show(); } } 程序运行结果 父类 子类 30 20 10 4 代码块 代码块的执行顺序：静态代码块 –\u003e 构造代码块 –\u003e 构造方法 代码的执行特点：静态代码块只执行一次，构造代码块每次调用构造方法都执行。 package jicheng; class Fu { static { System.out.println(\"父类静态代码块\"); } { System.out.println(\"父类构造代码块\"); } public Fu() { System.out.println(\"父类构造方法\"); } } class Zi extends Fu { static { System.out.println(\"子类静态代码块\"); } { System.out.println(\"子类构造代码块\"); } public Zi() { System.out.println(\"子类构造方法\"); } } public class test { public static void main(String[] args) { Zi z = new Zi(); Zi z2 = new Zi(); } } 程序运行结果： 父类静态代码块 子类静态代码块 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法 父类构造代码块 父类构造方法 子类构造代码块 子类构造方法 5 继承间的成员关系 成员方法 不同名称：非常简单，一看就知道调用谁 相同名称：先在子类找，再在父类找 … 找不到就报错。 成员变量： 名字不同：非常的简单，一看就知道使用的是谁。 名字相同：就近原则。 使用变量的时候，会先找局部范围。 如果想直接使用成员变量，加关键字：this 即可。 如果想直接使用父类的成员变量，加关键字：super 即可。 6 注意事项 子类中所有的构造方法默认都会访问父类中空参数的构造方法。为什么呢？因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。 ","date":"2019-01-24","objectID":"/posts/jicheng/:0:0","tags":["Java"],"title":"java 继承 test","uri":"/posts/jicheng/"},{"categories":["Memo"],"content":" 本以为 coding pages 与腾讯云合作后会更好，没想到正是这种初期 bug 不断，速度也是非常慢。比 gitee, 甚至 github 都要慢很多了。所以决定放弃 coding 了，本想挂到云服务器上，但是这个云服务器只续费了半年，可能不会再续费，前几天看到用腾讯云的 cos 桶 xml 制作动态相册的文章，知道了对象存储这个玩意，腾讯云 COS 提供免费 50G 的存储空间，还有 CDN 加速服务，我觉得是个不错的选择，部署后发现速度还挺好。 适用于 hexo, hugo 等静态博客的部署。 29 创建存储桶 打开腾讯云控制台–云产品–存储–对象存储，然后创建存储桶。 30 开启静态网站设置 在基础配置打开静态网站（关掉强制 https) 31 绑定域名 SSL 设置 32 域名解析，添加记录 去 dns 服务商添加域名解析记录 CNAME 指向上面的域名 33 hexo 设置 安装插件 npm install hexo-deployer-cos --save 站点配置文件 deploy: type: cos bucket: yourBucketName #cos 桶名称 appId: yourAppId #cos 桶名称后数字 secretId: yourSecretId #云 API 密钥 secretKey: yourSecretKey #云 API 密钥 region: yourRegion #所属地域 发布还是一样的 hexo clean hexo g -d 结果类似于 34 CDN 刷新 每次更新博客内容完后，都要登陆腾讯云 CDN–缓存刷新，手动刷新一下 CDN。 用脚本在每次更新后刷新 安装 npm install qcloud-cdn-node-sdk --save 创建qcloudcdn.js放入script文件夹 const qcloudSDK = require('qcloud-cdn-node-sdk'); qcloudSDK.config({ secretId: '你的 ID', secretKey: '你的密钥' }); qcloudSDK.request( 'RefreshCdnDir', { 'dirs.1': 'http://博客地址' }, (res) =\u003e { console.log(res); } ); 35 自动 CDN 刷新配置（推荐） 进入腾讯云，找到 函数计算 -\u003e CDN 缓存刷新函数 -\u003e 创建 CDN 缓存刷新函数 修改 index.js 内容后重新部署 'use strict'; const CosSdk = require('cos-nodejs-sdk-v5'); const CdnSdk = require('./common/CdnSdk'); const CdnRefreshTask = require('./common/CdnRefreshTask'); const { getParams, getObjectUrl, logger, getLogSummary } = require('./common/utils'); exports.main_handler = async (event, context, callback) =\u003e { /** * parse param from event and process.env */ const { objects, cdnHosts, secretId, secretKey, token } = getParams(event); logger({ title: 'param is parsed success, param as follow: ', data: { objects, cdnHosts, event } }); /** * init cos instance */ if (!secretId || !secretKey || !token) { throw new Error(`secretId, secretKey or token is missing`); } const cdnSdkInstance = new CdnSdk({ secretId, secretKey, token }); const cosInstance = new CosSdk({ SecretId: secretId, SecretKey: secretKey, XCosSecurityToken: token }); const taskList = objects.map(({ bucket, region, key }) =\u003e { /* 变更内容-START */ const purgeUrls = []; cdnHosts.forEach((host) =\u003e { const tempUrl = getObjectUrl({ cosInstance, bucket, region, key, origin: `${/^(http\\:\\/\\/|https\\:\\/\\/)/.test(host) ? '' : 'https://'}${host}` }); purgeUrls.push(tempUrl); // 如果以 /index.html 结尾，则增加目录首页/。 // 例如 https://www.xxxx.com/index.html, 则增加 https://www.xxxx.com/。 if (tempUrl.lastIndexOf('/index.html') == tempUrl.length - 11) { purgeUrls.push(tempUrl.substr(0, tempUrl.length - 10)); } }); return new CdnRefreshTask({ cdnSdkInstance, urls: purgeUrls }); /* 变更内容-END */ }); const taskResults = []; for (const task of taskList) { const results = await task.runPurgeTasks(); taskResults.push(...results); } logger({ title: 'cdn refresh full logs:', data: taskResults }); const { status, messages } = getLogSummary(taskResults); logger({ messages: messages.map((item) =\u003e item.replace(/\\,\\ /g, '\\n')) }); if (status === 'fail') { throw messages.join('; '); } else { return messages.join('; '); } }; ","date":"2019-01-22","objectID":"/posts/cos-hexo/:0:0","tags":["Hexo","hugo","对象存储","腾讯云 cos 桶"],"title":"利用腾讯云对象存储 COS 桶托管 hexo 博客","uri":"/posts/cos-hexo/"},{"categories":["Java"],"content":"1 主要方法 static type[] copyof(type[] original,int length) static int binarysearch(type[] a,type key) static boolean equals(type[] a,type[] b) static void fill(type[] a,type val) static void fill(type[] a,int fromindex,int toindex,type val) static void sort(type[] a) 2 实例代码 package Arrays; import java.text.Collator; import java.util.Arrays; import java.util.Comparator; public class ArraysDemo { public static void main(String agrs[]) { Integer arr[]=new Integer[9]; for(int i=0;i\u003c9;i++) arr[i]=(int)(Math.random()*100); //显示，排序数组 System.out.print(\"原内容：\"); display(arr); Arrays.sort(arr); System.out.print(\"排序后：\"); display(arr); //将值 -1 分配给数组 arr 中下标从 0 到 3-1 的位置 Arrays.fill(arr, 0,3,-1); System.out.print(\"fill() 后：\"); display(arr); //搜索 23 System.out.print(\"值 23 的位置：\"); int index =Arrays.binarySearch(arr, 23);//二分查找 System.out.print(index);//如果查找不到，index 为负 System.out.print(\"\\n 插入 0 在 3 号位置：\"); Arrays.fill(arr,3,4,0); display(arr); System.out.print(\"值 0 的位置：\"); index =Arrays.binarySearch(arr, 0); System.out.print(index); Integer arr2[]=new Integer[8]; arr2=Arrays.copyOf(arr, arr2.length); //复制 8 个 System.out.print(\"\\n 复制后的数组：\"); display(arr2); if(Arrays.equals(arr, arr2)) System.out.println(\"两数组相同！\"); else System.out.println(\"两数组不相同！\"); System.out.println(\"----------------------------------------\"); String[] str = {\"计算机\",\"黄桑\",\"通信\",\"李瑞豪\"}; Arrays.sort(str); for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); System.out.println(\"\"); //Collator 类是用来执行分语言环境的字符串比较，这里用的 CHINA Comparator com=Collator.getInstance(java.util.Locale.CHINA);//获取 Comparator 对象，参数表示按中文排序 //根据指定的 \"比较器\" 产生的顺序对 \"指定对象数组\" 进行排序 Arrays.sort(str,com);//sort(T[] a,Comparator\u003c?super T\u003ec) for(int i=0;i\u003cstr.length;i++) System.out.print(str[i]+\" \"); } static void display(Integer arr[]) { for(int i=0;i\u003carr.length;i++) System.out.print(arr[i]+\" \"); System.out.println(\"\"); } } 3 程序运行结果 原内容：41 0 44 96 49 96 30 6 87 排序后：0 6 30 41 44 49 87 96 96 fill() 后：-1 -1 -1 41 44 49 87 96 96 值 23 的位置：-4 插入 0 在 3 号位置：-1 -1 -1 0 44 49 87 96 96 值 0 的位置：3 复制后的数组：-1 -1 -1 0 44 49 87 96 两数组不相同！ ---------------------------------------- 李瑞豪 计算机 通信 黄桑 黄桑 计算机 李瑞豪 通信 ","date":"2019-01-18","objectID":"/posts/java-arrays/:0:0","tags":["Java","Collator","Comparator"],"title":"Arrays 类及基本使用","uri":"/posts/java-arrays/"},{"categories":["Memo"],"content":" 首先在主题配置文件添加以下关键字 recent_posts: enable: true search: true post: false sidebar: false icon: history title: 近期文章 layout: block 17 侧栏 在 next/layout/_macro/sidebar.swig 中的 if theme.links 对应的 endif 后面。 {% if theme.recent_posts.enable and theme.recent_posts.sidebar %} \u003cdiv class=\"links-of-blogroll motion-element {{ \"links-of-blogroll-\" + theme.recent_posts.layout }}\"\u003e \u003cdiv class=\"links-of-blogroll-title\"\u003e \u003ci class=\"fa fa-history fa-{{ theme.recent_posts.icon | lower }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul class=\"links-of-blogroll-list\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '3') %} \u003cli\u003e \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} 18 搜索结果处添加 找到路径H:\\hexo\\themes\\hexo-theme-next\\layout\\_partials\\search下localsearch.swig文件 把\u003cdiv id=\"local-search-result\"\u003e\u003c/div\u003e修改成以下内容（这里显示 15 篇） \u003cdiv id=\"local-search-result\"\u003e {% if theme.recent_posts.enable and theme.recent_posts.search %} \u003cdiv style=\"text-align: center;padding: 3px 0 0;\"\u003e \u003cdiv style=\"margin-top: 20px;font-size: 18px;font-weight: 600;border-bottom: 1px solid #ccc;\"\u003e \u003ci class=\"fa fa-{{ theme.recent_posts.icon }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul style=\"margin: 0;padding: 0;list-style: none;\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '15') %} \u003cli\u003e \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e \u003c/li\u003e {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} \u003c/div\u003e 19 文章尾部添加 把代码加在H:\\hexo\\themes\\hexo-theme-next\\layout\\_macro\\post.swig里的相应位置（我加在 tags 后） {% if not is_index and theme.recent_posts.enable and theme.recent_posts.post %} \u003cdiv style=\"text-align: center;padding: 10px 0 0;\"\u003e \u003cdiv style=\"margin: 60px 0px 10px;font-size: 18px;border-bottom: 1px solid #eee;\"\u003e \u003ci class=\"fa fa-{{ theme.recent_posts.icon }}\" aria-hidden=\"true\"\u003e\u003c/i\u003e {{ theme.recent_posts.title }} \u003c/div\u003e \u003cul style=\"margin: 0;padding: 0;list-style: none;font-size: 11px;\"\u003e {% set posts = site.posts.sort('-date') %} {% for post in posts.slice('0', '5') %} \u003ca href=\"{{ url_for(post.path) }}\" title=\"{{ post.title }}\" target=\"_blank\"\u003e{{ post.title }}\u003c/a\u003e\u0026emsp; {% endfor %} \u003c/ul\u003e \u003c/div\u003e {% endif %} 20 其他 可尝试将-date改为-update ","date":"2019-01-16","objectID":"/posts/recent-posts/:0:0","tags":["Hexo"],"title":"在搜索、文章底部、侧栏添加最近文章模块","uri":"/posts/recent-posts/"},{"categories":["Java"],"content":" 大一刚学 c 的时候以前写过 c 语言版 的。 Math: 针对数学进行运算的类 特点：没有构造方法，因为它的成员都是静态的 产生随机数： public static double random(): 产生随机数，范围 [0.0,1.0) 产生 1-100 之间的随机数 int number = (int)(Math.random()*100)+1; 猜数字小游戏案例 class MathDemo { public static void main(String[] args) { //获取随机数 //double d = Math.random(); //System.out.println(d); /* for(int x=0; x\u003c10; x++) { //System.out.println(Math.random()); System.out.println(Math.random()*100); } */ //我们如何获取 1-100 之间的随机数呢？ for(int x=0; x\u003c100; x++) { int number = (int)(Math.random()*100)+1; System.out.println(number); } } } 0.1 小游戏 该游戏可以由程序随机产生或由用户输入四个 0 到 9 之间的数字，且不重复。玩游戏者通过游戏提示输入八次来匹配上面所输入的数字。A 表示位置正确且数字正确，B 表示数字正确而位置不正确。 算法： 可以直接算出 A 类的数目，但是 B 类的数目直接算出或许会很麻烦，正好我们可以先算出 C 类数目恰好减去 A 类就是 B 类了。 package caishuzi; import java.util.Scanner; class Num { private int[] a= {0,0,0,0}; public Num() {} public void setx() { /*for(int i=0;i\u003c4;i++) { a[i]=(int)(Math.random()*10); }*/ //为了四个互不相同的随机数 a[0]=(int)Math.random()*10+1; for(int i=1;i\u003c4;i++) { int t=(int)(Math.random()*10); for(int j=0;j\u003ci;j++) { if(t==a[j]) { t=(int)(Math.random()*10); j=0; } } a[i]=t; } } public int[] getx() { return a; } public void show() { System.out.println(); for(int i=0;i\u003c4;i++) System.out.print(a[i]+\" \"); System.out.println(); } } public class caishuzi { public static void main(String agrs[]) { int a[] = {0,0,0,0},b[] = {0,0,0,0}; System.out.println(\"* * * *\\n 请输入 4 个数字！A 表示位置数字都正确，B 表示数字正确位置错误。\"); Scanner sc=new Scanner(System.in); Num n=new Num(); n.setx(); a=n.getx(); /*for(int i=0;i\u003c4;i++) System.out.print(a[i]+\" \"); n.show();*/ for(int k=0;k\u003c10;k++) {//猜测次数 int A=0,B=0,C=0; for(int i=0;i\u003c4;i++) { b[i]=sc.nextInt(); } sc.close(); for(int i=0;i\u003c4;i++){ if (b[i]==a[i])A++; for(int j=0;j\u003c4;j++){ C=b[i]==a[j]?++C:C;//C 表示猜测数内和随机数中 A 类和 B 类数的数目 if (b[i]==a[j])break; } } B=C-A;// 关键算法（感叹数学魅力） if(A==4) { System.out.println(\"恭喜猜对啦！\"); }else { System.out.println(A+\"A\"+B+\"B\"); } } } } 0.2 一次游戏过程 * * * * 请输入 4 个数字！A 表示位置数字都正确，B 表示数字正确位置错误。 0 1 2 3 0A1B 0 1 2 4 0A1B 0 1 2 5 1A1B 6 1 2 5 1A2B 1 6 2 5 3A0B 1 6 7 5 恭喜猜对啦！ ","date":"2019-01-15","objectID":"/posts/mathclass/:0:0","tags":["Java"],"title":"java 猜数字小游戏（Math 类）","uri":"/posts/mathclass/"},{"categories":["Java"],"content":"69 面向对象思想（理解） 面向对象是基于面向过程的一种编程思想 思想特点： A: 是一种更符合我们思考习惯的思想 B: 把复杂的问题简单化 C: 让我们从执行者变成了指挥者 举例： A: 洗衣服 B: 吃饭 C: 买电脑 举例并代码体现 把大象装进冰箱 70 类与对象（掌握） 我们学习编程是为了把现实世界的事物用编程语言描述来实现信息化。 现实世界事物是如何表达的呢？ 属性：外在特征 行为：内在行为 我们学习的是 java 语言，它最基本的单位是类。 所以我们要学会用类来体现一个事物。 类：是一组相关的属性和行为的集合 对象：是该类事物的具体个体。 举例： 学生 类 张三 对象 71 类的组成（掌握） 成员变量 其实就是变量，只不过定义在类中，方法外，并且可以不用初始化。 成员方法 其实就是方法，只不过不需要 static 了 案例： 学生类 class Student { String name; int age; public void study() {} } 72 类的使用（掌握） 创建对象 格式：类名 对象名 = new 类名 (); 使用成员 成员变量：对象名。变量名； 成员方法：对象名。方法名 (…); 73 成员变量和局部变量的区别（理解） 在类中的位置不同 A: 成员变量 类中，方法外 B: 局部变量 方法的形式参数，或者方法体中 在内存中的位置不同 A: 成员变量 在堆中 B: 局部变量 在栈中 生命周期不同 A: 成员变量 随着对象的存在而存在，随着对象的消失而消失 B: 局部变量 随着方法的调用而存在，随着方法的调用完毕而消失 初始化值不同 A: 成员变量 有默认初始化值 B: 局部变量 没有默认值，必须先声明，赋值，最后才能使用 74 形式参数问题（理解） 基本类型 基本类型作为形式参数，需要的是该基本类型的值。 引用类型 引用类型作为形式参数，需要的是该引用类型的地址值。（对象） 75 匿名对象（理解） 匿名对象：没有名字的对象。是对象的简化书写方式。 使用场景 A: 调用方法，仅仅只调用一次 B: 作为实际参数传递 76 封装（掌握） 隐藏实现细节，提供公共的访问方式 好处： A: 隐藏实现细节，提供公共的访问方式 B: 提高了代码的复用性 C: 提高了代码的安全性 使用原则 A: 把成员变量隐藏 B: 给出该成员变量对应的公共访问方式 77 private 关键字（掌握） 是一个权限修饰符 可以修饰类的成员（成员变量和成员方法） 仅仅在本类中可以访问，对外提供对应的 GetXXX()，SetXXX() 等方法 标准代码： class Student { private String name; private int age; public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { age = a; } public int getAge() { return age; } public void study() {} } 78 this 关键字（掌握） this：代表本类的对象 应用场景： 解决了局部变量隐藏成员变量的问题。 其他用法和 super 一起讲。 标准代码： class Student { private String name; private int age; public void setName(String name) {//局部变量 this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(\"姓名是：\"+name+\", 年龄是：\"+age); } public void study() { System.out.println(\"学生爱学习\"); } public void eat() { System.out.println(\"学生要吃饭\"); } public void sleep() { System.out.println(\"学生想睡觉\"); } } class StudentTest { public static void main(String[] args) { Student s = new Student(); s.setName(\"林青霞\"); s.setAge(28); s.show(); s.study(); s.eat(); s.sleep(); System.out.println(\"姓名是：\"+s.getName()); System.out.println(\"年龄是：\"+s.getAge()); } } 79 构造方法（掌握） 作用：对对象的数据进行初始化。 特点： A: 方法名和类名相同 B: 没有返回值类型 C: 没有返回值 注意事项 A: 如果我们没写构造方法，系统将默认给出无参构造方法 B: 如果我们写了构造方法，系统将不再给出默认无参构造方法 建议：我们自己手动给出无参构造方法 给成员变量赋值： A: 无参+setXxx() B: 带参 一个标准的代码： class Student { private String name; private int age; public Student() {} public Student(String name,int age) {//构造方法 this.name = name; this.age = age; } public void setName(String name) { this.name = name; } public String getName() { return name; } public void setAge(int age) { this.age = age; } public int getAge() { return age; } public void show() { System.out.println(\"姓名是：\"+name+\", 年龄是：\"+age); } } class StudentTest { public static void main(String[] args) { //无参+setXxx() Student s = new Student(); s.setName(\"林青霞\"); s.setAge(28); s.show(); //带参 Student ss = new Student(\"张曼玉\",20); ss.show(); } } 80 对象的初始化过程（理解） Student s = new Student(); 做了哪些事情 A: 加载 Student.class 文件进内存 B: 在栈中为 s 开辟空间 C: 在堆中为学生对象开辟空间 D: 为学生对象的成员变量赋默认值 E: 为学生对象的成员变量赋显示值 F: 通过构造方法给成员变量赋值 G: 对象构造完毕，把地址赋值给 s 变量 81 static 关键字（掌握） 是一个状态修饰符。静态的意思 它可以修饰成员变量和成员方法 特点： A: 随着类的加载而加载 B: 优先于对象存在 C: 被所有对象共享 这也是判断我们是不是该使用静态的条件 举例：饮水机（可共享 static) 和水杯例子。 D: 可以通过类名调用 静态修饰的内容，可以通过类名调用，也可以通过对象名调用 方法访问特点 A: 普通成员方法 可以访问静态成员变量，非静态成员变量，静态成员方法，非静态成员方法 B: 静态成员方法 只能访问静态成员变量，静态成员方法 简记：静态只能访问静态 注意： 静态中是不能有 this 的。 先进内存的不能访问后进内存的。反之可以。 /** * 班级编号应该是被班级每个人都共享的，所以定义一个就应该可以了。 * 而姓名和年龄，每个人应该是不一样的，所以，每个对象，都应该定义自己的。 * * 在 java 中，用什么来表示成员变量是被共享的呢？static */ class Student { //姓名 String name; //年龄 int age; //班级编号 //String classNumber; static String classNumber; public Student(String name,int age) { this.name = name; this.age = age; } public Student(String name,int age,String classNumber) { this.name = name; this.age = age; this.classNumber = classNumber; } public void show() { System.out.println(name+\"---\"+age+\"---\"+classNumber); } } class StudentDemo { public static void main(String[] args) { //创建学生对象 Student s1 = new Student(\"林青霞\",28","date":"2019-01-15","objectID":"/posts/duixiang/:0:0","tags":["面向对象","Java"],"title":"面向对象基础知识总结","uri":"/posts/duixiang/"},{"categories":["Java"],"content":" 水仙花数（Narcissistic number）也被称为超完全数字不变数（pluperfect digital invariant, PPDI）、自恋数、自幂数、阿姆斯壮数或阿姆斯特朗数（Armstrong number），水仙花数是指一个 3 位数，它的每个位上的数字的 3 次幂之和等于它本身（例如：13 + 53+ 3^3 = 153）。 1 定义 水仙花数只是自幂数的一种，严格来说 3 位数的 3 次幂数才称为水仙花数。 附：其他位数的自幂数名字 一位自幂数：独身数 两位自幂数：没有 三位自幂数：水仙花数 四位自幂数：四叶玫瑰数 五位自幂数：五角星数 六位自幂数：六合数 七位自幂数：北斗七星数 八位自幂数：八仙数 九位自幂数：九九重阳数 十位自幂数：十全十美数 package xunhuan; import java.util.Scanner; public class shuixianhua { public static void main(String[] agrs) { System.out.print(\"指定最大位数 N:\"); Scanner input = new Scanner(System.in); int N = input.nextInt(); input.close(); for (int i = 3; i \u003c= N; i++) { int a[] = new int[i]; int num = (int) Math.pow(10, i - 1) + 1; System.out.print(i + \"位的水仙花数有：\\t\"); while (num \u003c= Math.pow(10, i)) { int sum = 0; for (int j = 0; j \u003c i; j++) a[j] = (int) (num / Math.pow(10, j) % 10);//取各个位的数 for (int j = 0; j \u003c i; j++) sum = sum + (int) Math.pow(a[j], i); if (num == sum) System.out.print(num + \"\\t\"); num++; } System.out.print(\"\\n\"); } } } 由于 int 精度限制，最多算到 9 位，而且使用常规算法，算到 8，9 位的时候就特别慢了。 指定最大位数 N:10 3 位的水仙花数有：153 370 371 407 4 位的水仙花数有：1634 8208 9474 5 位的水仙花数有：54748 92727 93084 6 位的水仙花数有：548834 7 位的水仙花数有：1741725 4210818 9800817 9926315 8 位的水仙花数有：24678050 24678051 88593477 9 位的水仙花数有：146511208 ","date":"2019-01-14","objectID":"/posts/java-range/:0:0","tags":["水仙花数","Java"],"title":"java 水仙花数（循环）","uri":"/posts/java-range/"},{"categories":["Java"],"content":"1 记忆格式 (1) 导包： import java.util.Scanner; 注意：位置在 class 的上面。 (2) 创建键盘录入对象： Scanner sc = new Scanner(System.in); (3) 获取数据 int i = sc.nextInt(); (4) 练习： A: 求两个数据的和 B: 获取两个数据中较大的值 C: 获取三个数据中较大的值 D: 比较两个数是否相等 2 实例 package helloworld; import java.util.Scanner; public class helloworld { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int i=sc.nextInt(),j=sc.nextInt(),k=sc.nextInt(); sc.close(); System.out.println(i+\"+\"+j+\"=\"+(i+j)); System.out.println(\"MAXij=\"+Max(i,j)); System.out.println(\"MAXijk=\"+Max(i,j,k)); } //Max() 方法重载 static int Max(int i,int j) { return i\u003ej?i:j; } static int Max(int i,int j,int k) { if(i==j) System.out.println(\"i 和 j 相等\"); else if(i==k) System.out.println(\"i 和 k 相等\"); else if(j==k) System.out.println(\"j 和 k 相等\"); return (i=i\u003ej?i:j)\u003ek?i:k; } } 结果 5 5 6 5+5=10 MAXij=5 i 和 j 相等 MAXijk=6 ","date":"2019-01-14","objectID":"/posts/java-input/:0:0","tags":["Java"],"title":"java 录入数据","uri":"/posts/java-input/"},{"categories":["Java"],"content":"1 标识符 给类，接口，方法或者变量起名字的符号 2 组成规则 A: 英文字母大小写 B: 数字 C:_和$ 3 注意事项 A: 不能以数字开头 B: 不能是 Java 中的关键字 C: 区分大小写 Student,student 这是两个名称 4 常见命名方式 A: 包 其实就是文件夹，用于解决相同类名问题 全部小写 单级：com 多级：cn.itcast B: 类或者接口 一个单词：首字母大写 Student,Person,Teacher 多个单词：每个单词的首字母大写 HelloWorld,MyName,NameDemo C: 方法或者变量 一个单词：全部小写 name,age,show() 多个单词：从第二个单词开始，每个单词首字母大写 myName,showAllStudentNames() D: 常量 一个单词：全部大写 AGE 多个单词：每个单词都大写，用_连接 STUDENT_MAX_AGE ","date":"2019-01-14","objectID":"/posts/biaoshi/:0:0","tags":["Java"],"title":"java 标识符","uri":"/posts/biaoshi/"},{"categories":["Memo"],"content":" 1 常见情况 1.1 由 and 或 both and 连接的并列主语，谓语动词一般用复数 English and chinese are two quite different languages. Both brother and sister tire of city life. 1.2 一但主语前被 no,every,each 所修饰时，谓语动词用单数 No desk and (no) chair is seen in the hall. All work and no play makes Jack a dull boy. They each have been to the Forbidden city. each 位于主语后，所以谓语动词用复数 1.3 当主语表示同一事物的两个部分，同一个人的两个身份（第二个名词前无冠词），谓语动词用单数 比如 the（a）horse and cart a watch and chain a knife and fork a cup and soucer the butter and bread The horse and cart has fallen down the cliff（悬崖）. Butter and bread is his favourate. The poet（诗人）and writer has been sentenced（判决）to death. The poet and the writer have been sentenced（判决）to death. 1.4 两数相加或相乘，单复皆可，相减或相除，只能用单数，量词做主语，用单数 等于：be,equal,be equal to,make 相加：and,plus 相减：minus 相乘：multily,time 相除：divided by One and one make(makes) two. 2 就近原则 not only…but also there/here be or,nor,either…or,neither…nor,not…but There is a desk and two chairs in the room. Are you or your sister fond of classical music? An apple or two lies on the desk.（数量词后用单数） One or two apples lie on the desk. Not he but you have come. 3 就远原则 两单体两结构三 with 四除外 like,including rather than,as well as with,together with,along with except,besides,but,in addition to The couple in addition to their child are mean. Lauren,rather than anyone else was chose his partener. A library together with 3000 books was destroyed in the fire. 4 时间，金钱，距离，温度，天气，重量等不可数名词，to do,doing, 从句做主语时，谓 v 用单数 To go to bed early and rise early is a good habit. What he says and behaives doesn’t concern me. 5 分数，百分数，the rest(+of+n) 做主语，用单数 谓语动词由 of 后面的名词决定，一般用单数。 分数用法：通常分子读基数，分母读序数，分子超过 1 时，分母加 s。即 基 + 序 (s)+of+n+谓 Most students are in favaour of the contract（契约）but the rest disagree. be favaour of: be for,approve of,support,agree with About two thirds of the earth’s surface is covered by water. 6 一些短语 one of+n 或 the only one of+n, 一般用单数（定从根据中心词在 of 前后） a number of+n（用复数） \u0026 the number of+n（用单数） one in 或 one out of+n（用单数） a large quantity of \u0026 large quantity of + 可、不可数 n a large amount of \u0026 large amounts of + 不可数 n He is one of the students who were awarded the other day. He is the only one of the students who was awarded the other day. One of his family was a traitor（卖国贼，叛徒）during the world war two. A number of teenagers are addicted to the Internet. The number of students who are addicted to the Internet is up to（接近于）15. Large amounts of power are foused on him alone.==a large amount of power is foused on him alone. 7 不定代词做主语，谓语动词用单数 all 修饰人，谓语动词用复数，修饰物，谓语动词用单数 All are present besides the professor. All that glitters（发光体）is not gold. not 与 all/both 等连用表部分否定 8 the +adj 表一类人做主语时，谓语动词用复数 The injured are taken good care of in hospital. The agreeable is not always the useful.（不表人） 9 成双成对的词做主语，用复数 trousers（裤子）,chopsticks,scissors（剪刀）,glasses Pants are what I want. The pair of glasses seems expensive.（谓语动词与表示计量单位的名词形式一致） Three set of fashionable socks are shown in today’s evening proper（恰当地）. 一系列：a piece/pair/set/suit/series of 10 以 s 结尾特殊专用名词，用单数 表学科，疾病，山脉，河流，书名，歌名，格言等 maths,physicsa（物理）,politics（政治）,classics,economics,Aids,SARs,diabetes（糖尿病）,arthritis（关节炎）,bronchitis（支气管炎）,Himalayas,Arabian Night Arabian Night sounds beautiful. 11 many a +单 n+单谓： “许多”more than one +单 n+单谓： “不止一个” Many a man thinks life is meaningless without a purpose/an aim. More than one student has put forward the suggestion. More students than one are against the proposal. More than 20% students were absent at the meeting yesterday.（不止） 12 police,people,cattle 做主语，用复数 It is reported that police are trying their best to capture the murder. 13 the Olympics \u0026 the Olympic games The Olympices is hold every four years. == The Olympic games are hold every four year. 14 集体名词做主语，表整体用单数，表成员用复数 family,class,group,team,army,public,crew,population The innovation experiment（革新实验）class consists of 24 students and enjoy chinese. Population in China is 1.4 billion or so(about) 20% (Population) have no access to clean water. 15 单复同形，sheep,deer,means,Chinese 等谓语动词依据情况而定 Ma","date":"2019-01-12","objectID":"/posts/subject-verb/:0:0","tags":["English"],"title":"英语语法--主谓一致","uri":"/posts/subject-verb/"},{"categories":["Memo"],"content":" 形式倒装，句子本不是本来的语序。 0.1 may 位于句首，标祝愿 例句 May you succeed. May you have a happy holiday. Long live chairman Mao.（毛主席万古长青） 0.2 whatever 直接做成分或放在名词之前，however 放在 adv,adj 之前或 many,much 等词之前 例句 Whatever the weather is,he sticks out（坚持）walking outside. Go to stamp sales and buy whatever you can offord. Whatever reasons you have,you should carry out your promise. However many difficulties(n.) you meet with,you should try to overcome them. Whatever difficulties(n.) you meet with,you should try to overcome them. However difficult(adj.) the problem is,we must work it out today. 0.3 the + 比较级，the + 比较级 --\u003e“越 … 越 …” 例句 The hander you study,the greater progress you will make. The more you listen to English,the easier it becomes. The older you grow,the more challenges you will meet. 0.4 感叹句 例句 What an interesting talk they had! How interesting the talk was! ","date":"2018-12-10","objectID":"/posts/inversion-3/:0:0","tags":["English"],"title":"英语语法--形式倒装","uri":"/posts/inversion-3/"},{"categories":["Memo"],"content":" 完全倒装：把整个谓语动词放到主语前。 0.1 表方位或时间的副词 (adv)、表地点的介词短语位于句首时 例句 Here comes the bus. In the lecture hall of a university sits a professor. Out rushed the children. Now comes your turn. Up jumped the cat and caught the mouse. Down came the rain and up went the umbrellas. Among the people stood his friend,Jim. (To be) South of the river lies a small factory. 但主语为表示人称的代词时无需倒装 Here are you. Away it flew. 0.2 表语（词/短语）位于句首时，adj/doing/done 例句 Written on the blackboard are the name of these who were late. Gone are the days when we worked together. Standing at the tree is a shy girl with two big eges. Present(adj) at the conference were all leaders of this city. Lying on the grassland is the boy who was injured in the fire. 0.3 存在句 there be 中，其中 be -\u003eexist/arise/follow/enter/appear/live 等表状态 vi 例句 There come shows for help from the river. There seems something wrong with machine. There remains nothing to be done. There happened an event last week. ","date":"2018-12-10","objectID":"/posts/inversion-2/:0:0","tags":["English"],"title":"英语语法--完全倒装","uri":"/posts/inversion-2/"},{"categories":["Memo"],"content":" 虽然我英语四级没过，词汇量也不很多，甚至下降了很多，但是对于英语的语法我还是很喜欢的，马上快四级了又，复习整理一下以前的语法笔记。以下内容纯手打！！ 先从倒装句开始吧！分为三大类，部分倒装，完全倒装和形式倒装。先复习第一种。 部分倒装：把谓语动词的一部分（助动词，be 动词，情态动词）提到主语前面。 0.1 xx 也如此，xx 也一样 表示前面的内容也适用于后者，用\"so/nor/neither + 动词 + 主语\"句型。表“xx 也如此，xx 也一样”。可用,、;、and隔开（注意情形）。 例句 They love having lots of friends, so dothe disabled.（这里the + 形容词表一类人） I have had a new idea; so hasmy friends. Lily can’t ride bicycle, nor/neither canlucy. The injured look disappointed（沮丧的）, so didsenior citizens.（老人） （否定前缀词 ≠ 否定） If you aren’t for the plan; nor/neither willI. , 或 ; 前的句子若为从句，先将主句补充出，其后再根据主句改。 这里主句应为：I will not be for the plan.(be for 同意） It is burning（燃烧）hot today, so it is（那确实） and/; so was (it)yesterday.（这里只用用 and 或；) Everyone is here and looks upset, so it is with Mary = it is the same withMary. 这个句型同样适用于前面的六个例子，但是前面是并列句必须用这个句型。 The truth is that no one is perfect.When all potential（潜在的）for ugliness in removed, so is all of the potential for beauty. 0.2 否定副词或含有否定的介词短位于句首 例句 Neither does Mr.Green know the matter（事件） nor does he care about it. neither……nor…… 既不也不 either……or……要么要么，不是就是 Not only did we lose our way but also (we) came close to losing our lives.(come close to 接近，差一点就） Not until I began to work hard did I realize how much time I had wasted. 从句不倒装，原句为： I didn’t realize how much time I had wasted until I began to work hard. No sooner had they arrived at the tomb than they fell ill.（一……就……) In no case will we give up half-way. Hardly does Jim think it possible to finish the task before/when dark. hardly…before/when 一……就…… 这里取\"几乎不\"释义应该更合适。 Not a (single) mistake has Mary made so far.（玛丽到目前为止一个错误也没犯。) not a (single) + 单数名词 表示“一个也没有”%} In no time（立刻马上） Jone worked out the figure（体积）. （无否定不倒装） 0.3 only + 状语位于句首 例句 Only in this way are you able to do it well. 倒装前： You are able to do it well only in this way. Only when they returned home did they understand what had happened. Only on such a trip will you gain a better appreciation（理解）of Eurepean literature. Only the teacher got the news that our school could have a 4-day holiday.（同位语从句，only+主语所以不倒装） 0.4 So/Such…that… 句型位于句首 So + adj + a/an + 单数名词 = Such + a/an + adj + 单数名词 如此 ... 以至于 ... so 侧重于 adj/adv such 侧重于 n. 比如，so many/much/few/little 例句 So crowded was the art gallery（展览会） that I couldn’t move about (it). Such good weather was it that we all went out last week. Such a lovely girl is kate that everyone likes her. So loudly did he speak that even people next room could hear him. 0.5 as 引导让步狀语从句 as 引导让步状语从句（虽然，即使，尽管，无论），把从句中的表语，动词，副词提至句首 (as 后不用再倒装了），当表语是名词时，提至句首时一律用零冠词（其中 as 可用 though 替代，倒装后省略 but,though,however,even,though,although 等） 例句 Child as he is,he knows a lot. Poor as King was,he tried his best to help others. Try as he may,he has never made his boss satisfied. Search as you would,you could find no body in the room. Much as I want to buy the car,I can’t afford（支付）it. 0.6 把虚拟语气从句中的 were,had,should 提至句首，并省略 if 例句 Had you followwed my advice,you couldn’t have made such a silly mistake. Were you not a boy,you could wear a dress. Should he invite me,I might take part in this party. 0.7 表肯定含义的时间频率词位于句首 always,often,many a time(many times 多次）,every + 时间，now and then（时不时的） 例句 Many a time has he offered me some good suggestions. Now and then does my class teacher warn us not yo use cellphones in the classroom. 0.8 疑问句用部分倒装 普通的疑问句： How do you do that? 除了： What is wrong? = What is the matter? … ","date":"2018-12-08","objectID":"/posts/inversion-1/:0:0","tags":["English"],"title":"英语语法--部分倒装","uri":"/posts/inversion-1/"},{"categories":["Memo"],"content":" 2021/10/2 更新 博客已迁移至 Hugo, 插件演示不适用，已删除。 让文章写的好看又简洁又好用的插件！hexo 完整的标签列表，next 插件列表 1 hexo 插件 1.1 hexo-lazyload-image npm install hexo-lazyload-image --save First add configuration in _config.yml from your hexo project. lazyload: enable: true onlypost: false loadingImg: # eg ./images/loading.gif 1.2 hexo-ruby-marks 不支持ruby新标签的浏览器将显示rp中的内容。 \u003cruby\u003e博採眾長\u003crp\u003e（\u003c/rp\u003e \u003crt\u003elruihao.cn\u003c/rt\u003e\u003crp\u003e）\u003c/rp\u003e\u003c/ruby\u003e 博採眾長（ lruihao.cn） 插件使用 npm i hexo-ruby-marks {% ruby _**base**_|_**top text**_ %} 1.3 hexo-pwa npm install --save hexo-pwa You can configure this plugin in _config.yml.（配置完即可使用不许单独设置manifest.json文件及配置，插件生成） pwa: manifest: path: /manifest.json body: name: hexo short_name: hexo icons: - src: /images/android-chrome-192x192.png sizes: 192x192 type: image/png - src: /images/android-chrome-512x512.png sizes: 512x512 type: image/png start_url: /index.html theme_color: '#ffffff' background_color: '#ffffff' display: standalone serviceWorker: path: /sw.js preload: urls: - / posts: 5 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /.*\\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\\// strategy: networkFirst priority: 5 1.4 hexo-tag-dplayer hexo-tag-dplayer npm install hexo-tag-dplayer --save {% dplayer key=value ... %} key can be dplayer options: 'autoplay', 'loop', 'screenshot', 'hotkey', 'mutex', 'dmunlimited' : bool options, use \"yes\" \"y\" \"true\" \"1\" \"on\" or just without value to enable 'preload', 'theme', 'lang', 'logo', 'url', 'pic', 'thumbnails', 'vidtype', 'suburl', 'subtype', 'subbottom', 'subcolor', 'subcolor', 'id', 'api', 'token', 'addition', 'dmuser' : string arguments 'volume', 'maximum' : number arguments container options: 'width', 'height' : string, used in container element style other: 'code' : value of this key will be append to script tag {% dplayer \"url=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.mp4\" \"addition=https://dplayer.daoapp.io/bilibili?aid=4157142\" \"api=https://api.prprpr.me/dplayer/\" \"pic=https://moeplayer.b0.upaiyun.com/dplayer/hikarunara.jpg\" \"id=9E2E3368B56CDBB4\" \"loop=yes\" \"theme=#FADFA3\" \"autoplay=false\" \"token=tokendemo\" %} 1.5 hexo-tag-aplayer more npm install --save hexo-tag-aplayer {% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %} 标签参数 title : 曲目标题 author: 曲目作者 url: 音乐文件 URL 地址 picture_url: （可选）音乐对应的图片地址 narrow: （可选）播放器袖珍风格 autoplay: （可选）自动播放，移动端浏览器暂时不支持此功能 width:xxx: （可选）播放器宽度（默认：100%) lrc:xxx: （可选）歌词文件 URL 地址 当开启 Hexo 的 文章资源文件夹 功能时，可以将图片、音乐文件、歌词文件放入与文章对应的资源文件夹中，然后直接引用： {% aplayer \"Caffeine\" \"Jeff Williams\" \"caffeine.mp3\" \"picture.jpg\" \"lrc:caffeine.txt\" %} {% aplayer \"你离开了南京，从此没人和我说话\" \"李志\" \"https://cdn-1256932288.cos.ap-chengdu.myqcloud.com/files/nanjing.mp3\" \"https://p2.music.126.net/UuSe-Vc6rS7JtRJSQgDU2g==/2323268069553116.jpg?param=300x300\" %} 1.6 hexo-pdf pdf 传送门 1.7 hexo-filter-flowchart（流程图） 语法 npm install --save hexo-filter-flowchart ```%flow #去掉%号 st=\u003estart: Start|past:\u003ehttps://lruihao.cn[blank] e=\u003eend: End:\u003ehttps://www.lruihao.cn[blank] op1=\u003eoperation: My Operation|past op2=\u003eoperation: Stuff|current sub1=\u003esubroutine: My Subroutine|invalid cond=\u003econdition: Yes or No?|approved:\u003e/hexo/nextplugin.html c2=\u003econdition: Good idea|rejected io=\u003einputoutput: catch something...|request st-\u003eop1(right)-\u003econd cond(yes, right)-\u003ec2 cond(no)-\u003esub1(left)-\u003eop1 c2(yes)-\u003eio-\u003ee c2(no)-\u003eop2-\u003ee ``` 1.8 hexo-spoiler npm install hexo-spoiler --save If hexo can’t detect this plugin automatically, you need to modify the plugins section of [path_to_your_site]/_config.yml manually, like: plugins: - hexo-spoiler {% spoiler [text] %} It will pixelate your text, and click to reveal. Click again to hide your text again. But you need to add \u003cbr\u003e manually if you want line breaks after/before it. When you writes: {% spoiler text %} {% spoiler ~~text~~ %} {% spoiler *text* %} {% spoiler **text** %}\u003cbr\u003e {% spoiler **hello welcome to 博採眾長！** %} 2 宅音乐侧栏播放器插件 体验 源码 目前在 next 中可能引起部分 css 冲突，建议在 next 中使用","date":"2018-11-24","objectID":"/posts/nextplugin/:0:0","tags":["Hexo"],"title":"hexo 插件及 next 内置样式集","uri":"/posts/nextplugin/"},{"categories":["OS"],"content":" 前面我有文章提到怎么提交本地文件到 github,coding 等远程仓库。每次可以分为三个步骤 git add * （添加需要提交的文件，这里全选） git commit -m “提交信息” git push 但是这样感觉很麻烦每次都要重复输入提交命令和提示信息。 这个时候可以用到 windows 批处理 bat 文件 (linux 的话可以用 shell 脚本）。用完发现好用到不行！ 17 新建文本文档 @echo off title Commit git add . set /p m=Message: git commit -m \"%m%\" git push 然后另存为commit.bat文件，只要后缀是bat就行了。 18 使用 把文件放到你原本需要提交代码的本地文件夹。双击运行，输入提交信息回车即可。 19 hexo 博客新姿势 hexo 提交也很麻烦，当然也要批处理一下呀 hexo clean\u0026\u0026hexo g -d 20 其他 20.1 死机脚本 (友情提醒千万不要在真机实验，请在虚拟机运行) start cmd ifconfig 另外也说一下 linux 死机命令。fork 炸弹。 死机无非是耗尽系统资源 _(){ _ | _ \u0026 }; _ 这个\u0026指后台运行的意思。 20.2 统计文件名 dir \\\\?\\%1 /a:-d /b /o /p /w \u003eFilelist.txt 将需要统计的文件夹拖到 bat 文件上。 ","date":"2018-11-17","objectID":"/posts/commit-bat/:0:0","tags":["bat"],"title":"通过 bat 批处理文件自动提交博客代码","uri":"/posts/commit-bat/"},{"categories":["Grocery"],"content":"0.1 介绍 使用 fusion app 对网页进行的封装。 功能： 浏览本博客，主页 私人网盘 2048 等小游戏 在线客服，QQ 等 pc 与移动浏览器标识切换 留言，打赏，博主日志等 分享功能，分享到 QQ，微信，浏览器打开等 app 内添加书签，自动记录历史记录，刷新等 配合博客的PWA + quicklink功能可实现离线浏览 0.2 下载 app 内也可以更新，不过就我自己用，懒得更新。 百度云，密码：479l github 下载 PWA 应用 地址栏输入：Chrome://flags 搜索并启用以下项目：Desktop PWAs（桌面 PWAs)、App Banners（应用横幅）、Experimental App Banners（实验性应用横幅） 重启浏览器使修改的设置生效 点击地址栏最右边按钮 安装“博採眾長” 0.3 部分源码 看到这些中文的函数总觉得怪怪的哈哈哈 😂 语言：lua 0.3.1 检测更新 --检查测当前是否最新版本 local dl=ProgressDialog.show(activity,nil,'更新检测中…') dl.show() local tt=Ticker() tt.start() packinfo=this.getPackageManager().getPackageInfo(this.getPackageName(),((32552732/2/2-8183)/10000-6-231)/9) version=tostring(packinfo.versionName) versioncode=tostring(packinfo.versionCode) url=\"https://share.weiyun.com/43fa66d8fc95db27141530ed2d006be2\"; function 过滤 (content) 版本名=content:match(\"【版本名】(.-)【版本名】\") 版本=content:match(\"【版本】(.-)【版本】\") 内容=content:match(\"【内容】(.-)【内容】\") 链接=content:match(\"【链接】(.-)【链接】\") if（版本名==nil) then 版本名=\"获取失败\" end if（版本==nil) then 版本=\"0\" end if（内容==nil) then 内容=\"获取失败\" end if（链接==nil) then 弹出消息 (\"服务器参数配置错误，请过段时间再次尝试\") end if（版本 \u003e versioncode) then dl.dismiss() tt.stop() 对话框 () . 设置标题 (\"检测到更新\") . 设置消息 (\"版本：\"..version..\"→\".. 版本名。.\"\\n 更新内容：\".. 内容） . 设置积极按钮 (\"下载更新\",function() 下载文件（链接） 弹出消息 (\"下载更新中…\") end) . 设置消极按钮 (\"取消更新\") . 显示 () else dl.dismiss() tt.stop() 弹出消息 (\"当前已是最新版本！\") end Http.get(url,nil,\"UTF-8\",nil,function(code,content,cookie,header) if(code==200 and content)then content=content:match(\"\\\"html_content\\\":(.-),\"):gsub(\"\\\\u003C/?.-%\u003e\",\"\"):gsub(\"\\\\\\\\\",\"\u0026revs;\"):gsub(\"\\\\n\",\"\\n\"):gsub(\"\u0026nbsp;\",\" \"):gsub(\"\u0026lt;\",\"\u003c\"):gsub(\"\u0026gt;\",\"\u003e\"):gsub(\"\u0026quot;\",\"\\\"\"):gsub(\"\u0026apos;\",\"'\"):gsub(\"\u0026revs;\",\"\\\\\"):gsub(\"\u0026amp;\",\"\u0026\"); 过滤 (content) else dl.dismiss() tt.stop() 弹出消息 (\"本地网络或服务器异常 \"..code) end end) 0.3.2 方向锁定 --flag 在程序启动事件声明的全局变量 if flag==1 then activity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_SENSOR); SetHSP=\"H\" else SetHSP=nil end if SetHSP==nil then --竖屏锁定 activity.setRequestedOrientation(1); flag=1 else flag=0 end 0.3.3 程序启动事件 弹出消息 (\"©2018 李瑞豪\") --自动，由物理感应器决定 import \"android.content.pm.ActivityInfo\" flag=1 --程序退出时执行对话框 function onKeyDown(key,event) if(key==4)then if(webView.canGoBack())then webView.goBack() else appinfo=this.getPackageManager().getApplicationInfo(this.getPackageName(),0) applabel=this.getPackageManager().getApplicationLabel(appinfo) 退出确认=对话框 () . 设置消息 (\"您确定要退出 \"..applabel..\" 吗？\") 退出按钮={ [1]=function() 退出确认 . 设置积极按钮 (\"确认\",function() 退出程序 () end ) . 设置中立按钮 (\"清除缓存\",function() 对话框 () . 设置消息 (\"清除缓存后再次运行程序将变得缓慢、n 您确定要清除 \"..applabel..\" 的缓存吗？\") . 设置积极按钮 (\"确定\",function() os.execute(\"pm clear \"..this.packageName) 退出程序 () end) . 设置消极按钮 (\"取消\",function() end) . 显示 () end ) . 设置消极按钮 (\"取消\") end } math.randomseed(tonumber(tostring(os.time()):reverse():sub(1, 6))) 退出按钮 [math.random(1,1)]() 退出确认。show() end return true end end --历史记录 lstads=\"/data/data/\"..activity.getPackageName()..\"/lst.lua\" lstwebads=\"/data/data/\"..activity.getPackageName()..\"/lstweb.lua\" --2. 序列化 function slz(obj) local lua = \"\" local t = type(obj) if t == \"number\" then lua = lua .. obj elseif t == \"boolean\" then lua = lua .. tostring(obj) elseif t == \"string\" then lua = lua .. string.format(\"%q\", obj) elseif t == \"table\" then lua = lua .. \"{\\n\" for k, v in pairs(obj) do lua = lua .. \"[\" .. slz(k) .. \"]=\" .. slz(v) .. \",\\n\" end local metatable = getmetatable(obj) if metatable ~= nil and type(metatable.__index) == \"table\" then for k, v in pairs(metatable.__index) do lua = lua .. \"[\" .. slz(k) .. \"]=\" .. slz(v) .. \",\\n\" end end lua = lua .. \"}\" elseif t == \"nil\" then return nil else error(\"can not serialize a \" .. t .. \" type.\") end return lua end function rslz(lua) local t = type(lua) if t == \"nil\" or lua == \"\" then return {} elseif t == \"number\" or t == \"string\" or t == \"boolean\" then lua = tostring(lua) else error(\"can not unserialize a \" .. t .. \" type.\") end lua = \"return \" .. lua local func = loadstring(lua) if func == nil then return nil end return func() end --3. 历史记录框布局 function hstshow() hstlayout={ Linear","date":"2018-11-12","objectID":"/posts/fas-app/:0:0","tags":["lua","fusion"],"title":"博採眾長 app","uri":"/posts/fas-app/"},{"categories":["Grocery"],"content":"21 安装 cd ~ curl https://getcaddy.com | bash -s personal http.filemanager 22 编写配置文件 vim Caddyfile 内容如下： :80 { filemanager / /sdcard timeouts none gzip } 这里的 8080 端口号可以随意指定，如果在手机 termux 等搭建，由于手机权限比较低，所以一般设置 1024 以上的端口。80端口可以直接通过 ip 访问。如118.24.217.167 如果用域名，先在域名服务商解析 ip, 再配置文件如下 https://pan.lruihao.cn { filemanager / /sdcard timeouts none tls admin@lruihao.cn gzip } 指定邮箱是为了申请 ssl, 实现 https. 23 demo 启动 caddy caddy 账号密码默认admin 24 设置定时器启动 caddy（好像没用，我不会） 为了断开 xshell 后 caddy 还在运行。 vim run.sh 编辑以下内容 #!/bin/bash caddy 加权 chmod +x run.sh 设置任务 参考 crontab -e 加入 * * * * * /root/run.sh service crond start 25 ？？？ 最后误打误撞开启了 caddy 昨晚双十一要抢裤子，加上湘潭天气太 tm 冷了，就上床了，接着用 termux 远程连接服务器继续搞。结果连接的时候命令输错了-_-! 本来是ssh root@118.24.217.167再输入密码就可以了。这次搞错了多写了个-T, 然后运行caddy,ctrl+c 再断开，意外地发现 filemanager 竟然可以访问了。 ssh -T root@118.24.217.167 caddy Ctrl+c ","date":"2018-11-11","objectID":"/posts/caddy-file/:0:0","tags":["云盘","caddy","server"],"title":"caddy-两步搭建超简单云盘","uri":"/posts/caddy-file/"},{"categories":["Memo"],"content":" 最新的 next 主题已经更新了支持 PDF 功能，写法也和链接写法一样，可是我没有更新，我按 github 上那个 readme 试了一下好像不可以，所以用了另外一种插件的方法。 13 iframe(推荐) \u003ciframe src=\"/posts/next-pdf/1.pdf\" style=\"width: 100%;height: 800px;\"\u003e\u003c/iframe\u003e 14 模板自带 今天（2019.4.3）又看了一下，改了写法，写法和插件一样，我在我的模板里也更新了。（插件模板二选一即可，个人更喜欢插件） 但是如果安装插件后，也是优先模板的 pdf 脚本解析 pdf，所以在我的模板中把模板的 pdf 脚本先注释了。要启用去掉注释即可。 /* 'use strict'; function pdf(args) { return `\u003cdiv class=\"pdf\" target=\"${args[0]}\" height=\"${args[1] || ''}\"\u003e\u003c/div\u003e`; } hexo.extend.tag.register('pdf', pdf, {ends: false}); */ 15 pdf 插件 (推荐) 15.1 安装 npm install --save hexo-pdf 15.2 使用 {% pdf url %} 比如本文 {% pdf /posts/next-pdf/1.pdf %} ","date":"2018-11-09","objectID":"/posts/next-pdf/:0:0","tags":["Hexo"],"title":"next 添加支持 pdf","uri":"/posts/next-pdf/"},{"categories":["JavaScript"],"content":"前端开发经常遇到需要判断用户的浏览设备，是 pc 端还是移动端，移动端使用的是什么手机系统？android、ios、ipad、windows phone 等等，有时候还需要知道用户浏览页面是在微信中打开还是在移动端浏览器中打开，等等一系列判断做一些相应的处理。 0.17 首先判断 pc 端还是移动端 function IsPC() { var userAgentInfo = navigator.userAgent; var Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; var flag = true; for (var v = 0; v \u003c Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u003e 0) { flag = false; break; } } return flag; } 0.18 判断用户移动端使用的系统平台 var u = navigator.userAgent; if (u.indexOf('Android') \u003e -1 || u.indexOf('Linux') \u003e -1) { //安卓手机 } else if (u.indexOf('iPhone') \u003e -1) { //苹果手机 } else if (u.indexOf('Windows Phone') \u003e -1) { //winphone 手机 } 0.19 判断用户是否在微信中打开 function isWeiXin(){ var ua = navigator.userAgent.toLowerCase(); if(ua.indexOf('micromessenger') != -1) { return true; } else { return false; } } 0.20 实际运用 根据 pc 或者移动端控制飘花数目，降低 cpu 消耗，减少卡顿。demo \u003cscript\u003e function sakuraInit() { $(document).snowfall('clear'); var userAgentInfo = navigator.userAgent; var Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; var flag = true; for (var v = 0; v \u003c Agents.length; v++) { if (userAgentInfo.indexOf(Agents[v]) \u003e 0) { flag = false; break; } } if (flag) { $(document).snowfall({image:\"images/1.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/2.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/3.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/4.png\", flakeCount:5, minSpeed:1, minSize:8, maxSize:15,}); } else { $(document).snowfall({image:\"images/1.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/2.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/3.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"images/4.png\", flakeCount:2, minSpeed:1, minSize:8, maxSize:15,}); } } window.onload = sakuraInit(); \u003c/script\u003e ","date":"2018-11-03","objectID":"/posts/js-device/:0:0","tags":["JavaScript","他山之石"],"title":"js 判断用户设备类型及平台","uri":"/posts/js-device/"},{"categories":["Memo"],"content":"9 备份 hexo 博客 //如果 themes/next（主题文件）下面有。git，请删除这个。git 文件夹。 cd hexo git init //初始化本地仓库 git add source themes scaffolds _config.yml package.json package-lock.json //将必要的文件依次添加 git commit -m \"blog hexo\" git branch hexo //新建 hexo 分支 git checkout hexo //切换到 hexo 分支上 git remote add origin git@github.com:username/username.github.io.git //将本地与 Github 项目对接 git push origin hexo //push 到 Github 项目的 hexo 分支上 10 在其他终端克隆和更新 hexo 博客 nodejs,git,hexo 已经安装好，即搭建完成 10.1 克隆 hexo 博客备份 git clone -b hexo git@github.com:username/username.github.io.git //将 Github 中 hexo 分支 clone 到本地 cd user.github.io npm install //注意，这里一定要切换到刚刚 clone 的文件夹内执行，安装必要的所需组件，不用再 init 这样我们的备份文件就会原封不动的拷贝到本地。 10.2 写新文章并备份和部署（备用操作） 其实源码拷下来了，这步不做我们也知道怎么做了，完全没必要按照教程死搬硬套。灵活一点就行了。 //进入 username.github.io 文件夹，应是 hexo 分支 git pull origin hexo //本地和远端的融合 hexo new post \"new post name\" //写新文章 git add source git commit -m \"xxx\" git push origin hexo //备份 hexo d -g //部署 参考 ","date":"2018-11-03","objectID":"/posts/blog-backup/:0:0","tags":["Git","Hexo","Node.js"],"title":"hexo 博客源码备份","uri":"/posts/blog-backup/"},{"categories":["Git"],"content":" 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage, 或 index。一般存放在 “.git 目录下” 下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录。git，这个不算工作区，而是 Git 的版本库。 1 介绍 https://git-scm.com/ 先通过几张图片来大致了解一下 Git 的工作原理吧！ 文章开头的流程图已经简单明了地说明了 Git 常用操作的工作流程，下图换种风格再展示一次： 提到 Git 就会联想到 github, 下图从 Git 的角度简单说明了一些 Github 常用操作的关系： 下面这个图则展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 \"index\" 的区域是暂存区（stage, index），标记为 “master” 的是 master 分支所代表的目录树。 HEAD 指针：每个 git 仓库有且仅有一个 HEAD 指针，它通常指向當前某个活動的本地分支指针（最初本地仓库 master)。也可以是某个提交记录、某个 tag，但这会让其处于 detached HEAD（游离头）状态，此状态下的所有提交都无效。 图中我们可以看出此时 \"HEAD\" 实际是指向 master 分支的一个\"游标\"。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的objects标识的区域为 Git 的对象库，实际位于 \".git/objects\" 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 \"git add\"命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的 ID 被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 \"git reset HEAD\" 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 \"git rm --cached \u003cfile\u003e\" 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 \"git checkout .\" 或者 \"git checkout -- \u003cfile\u003e\" 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 \"git checkout HEAD .\" 或者 \"git checkout HEAD \u003cfile\u003e\" 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 2 Git 配置 git config --global --list #查看全局配置 git config --local --list #查看本项目配置 # 第一次使用 git 的时候，需要设置用户信息和用户邮箱，用于辨识提交者身份 git config --global user.name \"用户名\" git config --global user.email \"邮箱\" git config --global alias.cm commit git config --global alias.br branch # 配置指令别名简写 git config --global credential.helper store # 输入一次账号密码后第二次就会记住账号密码 git config --global core.ignorecase false # 关闭忽略大小写 git config --system core.longpaths true # 配置长路径 git config --global http.sslVerify false # 禁用 SSL 验证 git config --global core.protectNTFS false # 关闭 NTFS 文件保护 git config --global url.\"https://\".insteadOf git:// # git:// 报错 2.1 基本操作 git init ## 把当前的目录变成可以用 git 进行版本控制的 git 仓库，生成隐藏。git 文件。 git add XX ## 把 xx 文件添加到暂存区去。 git add –A ## git add --all 的缩写，添加全部到暂存区 git add –u ## 把文件的删除和修改添加到暂存区（不包括新增） git add . ## 监控工作区的状态树，使用它会把工作时的所有变化提交到暂存区 git commit -m \"message\" ## 从暂存区提交到本地仓库 git commit -a -m \"message\" ## 相当于省略 git add，但是无法提交新增的文件 git push origin master ## Git 会把 master 分支推送到远程库对应的远程分支上 Tips Commit Message 内容尽量规范！ 当某一次提交后，突然想起漏提交了文件，或不小心提交了不满意的代码时， 可以使用git commit --amend -m \"message\"指令。它可以在不增加一个新的 commit-id 的情况下将新修改的代码追加到前一次的 commit-id 中。提交之后 message 也将被本次的 message 覆盖，所以还需要再次添加上次的 message。 2.2 push git push origin branch-name git push –u origin master git push origin --delete branch-name ## 删除远程分支 把当前 master 分支推送到远程库；-u表示记住分支和地址，下次使用git push即可。 2.3 remote git remote add origin reposityUrl ## 关联一个远程库 git remote ## 查看远程库的信息 git remote –v ## 查看远程库的详细信息 2.4 clone git clone reposityUrl ## 从远程库中克隆 git clone -b branchName reposityUrl ## 克隆指定分支 2.5 pull git pull 从远程仓库拉下来到本地库然后合并相当于git fetch+git merge。 一般 push 前先拉去最新版本，避免代码冲突，如果有冲突需要解决了冲突才能提交。 import repositories 同步更新 git pull 原链接 git push origin master 2.6 fetch git fetch ## 从远程库抓下最新版本，但是不合并 fetch 是从远程库到本地库，但是未在工作区，需要git merge 2.7 merge git merge dev ## 在当前的分支上合并 dev 分支 分支合并也是在本地完成 (从本地库到工作区)，新的分支只有在合并后才允许被删除。 如果分支合并是出现冲突需要解决了冲突才能合并，使用git status查看冲突文件。 2.8 branch,checkout git branch ## 查看当前所有的分支 git branch name ## 创建分支 git branch –r ## 看远程所有分支 git branch –a ## 查看本地远程分支 git branch –d name ## 删除分支 git checkout name ## 切换分支 git checkout –b name ## 创建并切换到 name 分支上 git checkout -- file git checkout -- file相当于取消对文档的修改，将最新的本地版本库的本文件复制覆盖它。（比较危险！） 2.9 reflog,log git log ## 显示所有提交过的版本信息：commit id，提交者，日期 git reflog ## 查看历史记录的 commit id Tips 想看到自己的操作记录，则可以使用 log 与 reflog，它两个的区别如下： git log命令可以显示所有提交过的版本信息； 如果感觉太繁琐，可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息。 git reflog可以查看所有分支的所有操作记录。（包括已经被删除的 commit 记录和 reset 的操作） 2.10 reset git reset --hard HEAD^ git reset --hard HEAD~ ## 回退到上一个版本 git reset --hard HEAD~100 ## 回退到 100 个版本 git reset head -- file ## 不加 file 则全部退回 git reset file ## 将本地仓库的当前版本退回至暂存区，相当于取消暂存 版本退回是从本地仓库到暂存区，如果已经提交远程库，此时的版本是低于最新的版本的会拒绝提交， 需要用git push -f origin master强制提交","date":"2018-10-30","objectID":"/posts/git/:0:0","tags":["Git"],"title":"Git 常用指令汇总","uri":"/posts/git/"},{"categories":["thoughts"],"content":" 备案 经过时间长达 20 多天的备案之旅今天终于结束了，也闭馆了 20 多天，也按相关要求把 ICP 备案号和公安备案号加载了网站和博客底部。只是今天去岳塘分局签网络安全告知书的时候不小心把身份证落在那个办公室了。亏我走之前一秒还在提醒自己，唉！不过那个办公室的大姐姐挺好的，前面跟我说好星期一来，我还今天上午提前给她打了电话，她还下楼给我开办公楼楼道的门禁，还有我身份证落在那里她说先帮我收着，有时间再去拿！总之，这个姐姐的服务态度五星好评！手动@岳塘分局 B204 的姐姐。 备案完成也算放下一块提着的石头，可以睡个好觉了！ZzZzzzz ","date":"2018-10-29","objectID":"/posts/beian/:0:0","tags":["随笔","网站备案"],"title":"网站备案之旅","uri":"/posts/beian/"},{"categories":["OS"],"content":"今天上机学了几个小命令 read echo if 然后自己写了一个小脚本觉得还挺有趣的 #!/bin/bash #liruihao #menu.sh #sudo apt curl install nyancat sl figlet toilet cowsay echo \"-------------菜-单--------------\" echo \"------------1-打印二维码--------\" echo \"------------2-彩虹猫------------\" echo \"------------3-小火切------------\" echo \"------------4-打字机------------\" echo \"------------5-小许牛------------\" echo \"----------Ctrl+c 暂停程序--------\" echo \"\" echo \"请输入序号！\" read i if test $i -eq 1 then echo \"请输入网址！\" read s1 echo $s1 |curl -F-=\\\u003c- qrenco.de fi if test $i -eq 2 then nyancat fi if test $i -eq 3 then sl fi if test $i -eq 4 then echo \"请输入字符串！\" read s2 echo \"选择样式：\" echo \"------样式 1-----\" echo \"------样式 2-----\" read j if test $j -eq 1 then figlet $s2 else toilet -f mono12 -F gay $s2 fi fi if test $i -eq 5 then echo \"请输入字符串！\" read s3 cowsay $s3 fi echo \"任意建继续！\" read x clear ./menu.sh ","date":"2018-10-29","objectID":"/posts/shell/:0:0","tags":["shell","linux"],"title":"shell 脚本初体验","uri":"/posts/shell/"},{"categories":["OS"],"content":"0.13 搭建 Apache web 服务 安装 Apache 超文本传输协议 (HTTP) 服务器的主程序 [root@VM_0_6_centos /]# yum install -y httpd 注意安装目录，可通过 cd 命令切换。 启动 HTTP 服务 [root@VM_0_6_centos /]# systemctl start httpd.service 如果启动失败，可通过 systemctl status httpd.service 查看错误原因。 启动成功，证明 http 服务已经可以使用，发现还需要把本地文件传到服务器。 默认根目录/var/www/html/ 0.14 使用 SSH 连接服务器 尝试了两种方式：PuTTY 和 Xshell（推荐） 0.14.1 Xshell 方式 官网下载安装 Xshell 打开，输入 ip 账号密码连接主机。 使用 lrzsz 方式上传下载文件 步骤 1：在服务器安装 lrzsz [root@VM_0_6_centos /]# yum -y install lrzsz 步骤 2：输入命令rz打开上传窗口（可以选择多个文件。) 使用sz文件名命令可打开从服务器下载文件的保存窗口。 0.15 修改 HTTP 配置 1.VIM 编辑器打开配置文件 [root@VM_0_6_centos /]# vim /etc/httpd/conf/httpd.conf 按I键进入编辑模式 找到并修改以下内容 ServerAdmin 管理员邮箱，用于浏览器请求报错时展示 DocumentRoot 访问根目录（默认：/var/www/html），如项目存放在其他地方，可修改为项目存放位置 \u003cDirectory \"/var/www/html\"\u003e 同 DocumentRoot 配置 ServerName 服务器 IP 或 域名 按下 ESC 键输入:wq保存退出 重启服务service httpd restart 打开浏览器，输入地址访问 如：我的项目索引 html 路径为 love/index.html，输入 http://IP 地址或域名/love/index.html 访问不成功，先检查网络，再查看 http 服务是否开启，最后检查配置； 访问成功，配置完成。 ","date":"2018-10-29","objectID":"/posts/web-server-yun/:0:0","tags":["server","linux","他山之石"],"title":"云服务器 CentOS 系统搭建 web 服务","uri":"/posts/web-server-yun/"},{"categories":["JavaScript"],"content":"0.9 获取链接（转） 传送门 在 WEB 开发中，时常会用到 javascript 来获取当前页面的 url 网址信息，在这里是我的一些获取 url 信息的小总结。 下面我们举例一个 URL，然后获得它的各个组成部分：http://i.cnblogs.com/EditPosts.aspx?opt=1 0.9.1 window.location.href（设置或获取整个 URL 为字符串） var test = window.location.href; alert(test); 返回：http://i.cnblogs.com/EditPosts.aspx?opt=1 0.9.2 window.location.protocol（设置或获取 URL 的协议部分） var test = window.location.protocol; alert(test); 返回：http: 0.9.3 window.location.host（设置或获取 URL 的主机部分） var test = window.location.host; alert(test); 返回：i.cnblogs.com 0.9.4 window.location.port（设置或获取与 URL 关联的端口号码） var test = window.location.port; alert(test); 返回：空字符（如果采用默认的 80 端口 (update: 即使添加了：80)，那么返回值并不是默认的 80 而是空字符） 0.9.5 window.location.pathname（设置或获取与 URL 的路径部分（就是文件地址）) var test = window.location.pathname; alert(test); 返回：/EditPosts.aspx 0.9.6 window.location.search（设置或获取 href 属性中跟在问号后面的部分） var test = window.location.search; alert(test); 返回：?opt=1 PS：获得查询（参数）部分，除了给动态语言赋值以外，我们同样可以给静态页面，并使用 javascript 来获得相信应的参数值。 0.9.7 window.location.hash（设置或获取 href 属性中在井号“#”后面的分段） var test = window.location.hash; alert(test); 返回：空字符（因为 url 中没有） 0.9.8 js 获取 url 中的参数值 0.9.8.1 正则法 function getQueryString(name) { var reg = new RegExp('(^|\u0026)' + name + '=([^\u0026]*)(\u0026|$)', 'i'); var r = window.location.search.substr(1).match(reg); if (r != null) { return unescape(r[2]); } return null; } // 这样调用： alert(GetQueryString(\"参数名 1\")); alert(GetQueryString(\"参数名 2\")); alert(GetQueryString(\"参数名 3\")); 0.9.8.2 split 拆分法 function GetRequest() { var url = location.search; //获取 url 中\"?\"符后的字串 var theRequest = new Object(); if (url.indexOf(\"?\") != -1) { var str = url.substr(1); strs = str.split(\"\u0026\"); for(var i = 0; i \u003c strs.length; i ++) { theRequest[strs[i].split(\"=\")[0]] = unescape(strs[i].split(\"=\")[1]); } } return theRequest; } var Request = new Object(); Request = GetRequest();\u003cbr\u003e// var id=Request[\"id\"]; // var 参数 1, 参数 2, 参数 3, 参数 N; // 参数 1 = Request['参数 1']; // 参数 2 = Request['参数 2']; // 参数 3 = Request['参数 3']; // 参数 N = Request['参数 N']; 0.9.8.3 指定取 比如说一个 url：http://i.cnblogs.com/?j=js, 我们想得到参数 j 的值，可以通过以下函数调用。 function GetQueryString(name) { var reg = new RegExp(\"(^|\u0026)\" + name + \"=([^\u0026]*)(\u0026|$)\", \"i\"); var r = window.location.search.substr(1).match(reg); //获取 url 中\"?\"符后的字符串并正则匹配 var context = \"\"; if (r != null) context = r[2]; reg = null; r = null; return context == null || context == \"\" || context == \"undefined\" ? \"\" : context; } alert(GetQueryString(\"j\")); 0.10 301 重定向（实践） 由于之前把 blog 和网站主页分开在两个仓库所以要想在 blog 中 menu 里跳转到站外链接就要做一些处理。以前一直百度不到。 其实想法早就有了，只要在 blog 首页或者网站首页检测到https://lruihao.cn/home这个链接，或者检测到 home 字段就自动跳转。想法很简单。可是对 js 真的一点都不了解，以前百度也找不到实际的效果案例。所以还是自己写吧！附上蹩脚代码。 var path = window.location.href; //alert(path); if (path=='https://lruihao.cn/home/') { window.location.replace(\"https://www.lruihao.cn\"); } 或者 var path = window.location.pathname; //alert(path); if (path=='/home/') { window.location.replace(\"https://www.lruihao.cn\"); } http 强制重定向 https \u003cscript\u003e var targetProtocol = \"https:\"; var host = \"lruihao.cn\"; //域名判断，因为 localhost 仅支持 http if (window.location.host == host \u0026\u0026 window.location.protocol != targetProtocol){ window.location.href = targetProtocol + window.location.href.substring(window.location.protocol.length); } \u003c/script\u003e ","date":"2018-10-28","objectID":"/posts/href-301/:0:0","tags":["redirect","JavaScript","他山之石"],"title":"使用 js 准确获取当前页面 url 网址信息及 301 重定向实战","uri":"/posts/href-301/"},{"categories":["Grocery"],"content":" 我用的 win10 0.1 打开控制面板 选择并进入“程序”，双击“启用或关闭 Windows 服务”，在弹出的窗口中选择“Internet Information Services”下面所有地选项，点击确定后，开始更新服务。 打开控制面板 0.2 查看 更新完成后，打开浏览器，输入http://localhost或者127.0.0.1回车，如果此时出现 IIS7 欢迎界面，说明 Web 服务器已经搭建成功。 查看 0.3 网站设置 当 web 服务器搭建成功后，我们下一步所要做的就是把我们开发的网站安装到 Web 服务器的目录中。一般情况下，当 Web 服务器安装完成后，会创建路径%系统根目录%inetpub/wwwroot，将我们开发的网站 COPY 到该路径下。即可实现本地访问该网站。 也可以更改根目录，搜索 IIS，点击网站，Default Web Site，基本设置修改物理路径（默认站点名称不要改） 我这里改到了 hexo 的 public 相当于 hexo 部署在本地服务器58.45.227.225 0.4 设置防火墙 让局域网当其它计算机也能访问本地网站资源。具体方法：打开控制面板，选择“系统和安全”，点击“允许程序通过 Windows 防火墙”，在弹出的对话框中勾选“万维网服务 HTTP”右侧的两个复选框，最后点击确定退出。 在局域网中其它计算机上，打开浏览器就可以通过你电脑的 ip 地址访问了（手机也可以） 本地 ip 可以通过 cmd 用 ipconfig 查看 ","date":"2018-10-26","objectID":"/posts/web-server-win/:0:0","tags":["server","windows"],"title":"windows 上搭建 web 服务器","uri":"/posts/web-server-win/"},{"categories":["Git"],"content":"0.17 config git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" 第一次使用 git 的时候需要设置提交者信息。 注意： 如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。 如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 0.18 生成 ssh 由于你的本地 Git 仓库和 GitHub 仓库之间的传输是通过 SSH 加密的，所以我们需要配置验证信息： 使用以下命令生成 SSH Key： ssh-keygen -t rsa -C \"youremail@example.com\" 后面的 your_email@youremail.com 改为你在 Github 上注册的邮箱，之后会要求确认路径和输入密码，我们这使用默认的一路回车就行。成功的话会在 C:\\Users\\用户名、或者~/ 下生成 .ssh文件夹，进去，打开 id_rsa.pub，复制里面的 key。去 github、coding 等平台配置 SSH 公钥（根据自己情况） 0.19 创建本地代码库 在本地创建一个文件夹，作为你上传代码的本地仓库，在这个文件夹内点击右键，选择 Git Bash Here，首先要初始化本地仓库： git init 接下来进行远程代码库克隆（事先在 coding 等中建立一个项目，就是你需要链接的仓库） git clone https://github.com/Lruihao/Lruihao.github.io.git 克隆时会出现输入账号密码的环节正确输入即可。 0.20 代码推送（重点） git status git add * git commit -m \"代码备注随便写\" git push origin master Gearn Git Branching ","date":"2018-10-26","objectID":"/posts/gituse/:0:0","tags":["Git"],"title":"使用 Git 上传代码到 github, coding 等仓库","uri":"/posts/gituse/"},{"categories":["Memo"],"content":" 前面有一篇文章写到一些，在 Android 上搭建 hexo 博客 本文当初摘要自 国光个人博客 如若作者博客 IP 被墙，可前往国光第三方博客诸如 csdn 等。备用 1 初始化 下载并初始化 termux 1.1 安装 vim 安装编辑器 vim pkg install vim 1.2 解决中文乱码问题 在 home 目录下，新建 .vimrc 文件 vim .vimrc 添加内容如下： set fileencodings=utf-8,gb2312,gb18030,gbk,ucs-bom,cp936,latin1 set enc=utf8 set fencs=utf8,gbk,gb2312,gb18030 然后 source 下变量： source .vimrc 1.3 修改启动问候语 vim $PREFIX/etc/motd 按 i 然后编辑，比如 www.lruihao.cn 李瑞豪 Esc 然后：wq 退出 1.4 管理员权限 手机已经 root, 安装 tsu, 这是一个 su 的 termux 版本，用来在 termux 上替代 su: pkg install tsu 然后终端下面输入： tsu 即可切换 root 用户，这个时候会弹出 root 授权提示。在管理员身份下，输入 exit 可回到普通用户身份。 2 美化 Termux-ohmyzsh 作用：美化之外，主要使用了 zsh 来替代 bash 作为默认 shell。使用一键安装脚本来安装，一步到位，顺便启动了外置存储，可以直接访问 SD 卡下的目录，创建软文件夹。 2.1 使用 sh -c \"$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\" 2.2 设置色彩样式 运行 chcolor 更换色彩样式，或者： ~/.termux/colors.sh 2.3 设置字体 运行 chfont 更换字体，或者： ~/.termux/fonts.sh 2.4 需要软件包 curl 3 访问外置存储 执行过上面的 zsh 一键配置脚本后，并且授予文件访问权限的话，会在家目录生成 storage 目录，并且生成若干目录，软连接都指向外置存储卡的相应目录 可以让从外置储存复制文件进 system 分区 3.1 创建 QQ 文件夹软连接 ln -s /data/data/com.termux/files/home/storage/shared/tencent/QQfile_recv QQ 3.2 创建 blog2 文件夹软连接备份文件 ln -s /data/data/com.termux/files/home/storage/shared/blog2 blog2 4 安装 hexo 4.1 安装准备 pkg install nodejs pkg install git npm install hexo-cli -g npm install hexo-deployer-git --save pkg install openssh 4.2 初始化 hexo hexo init blog cd blog hexo g hexo s 浏览器输入127.0.0.1:4000查看效果 4.3 链接 github,coding,gitee 等远程仓库 ssh-keygen -t rsa -C \"your_email@example.com\" #这将按照你提供的邮箱地址，创建一对密钥（个人喜欢一路回车） 找到~/.ssh/id_rsa.pub这个文件复制里面的内容，到对应的平台生成 SSH 公钥 4.4 设置用户信息 git config --global user.name \"lruihao\" git config --global user.email \"1074627678@qq.com\" 4.5 测试链接 ssh -T git@github.com #github ssh -T git@coding.net #coding ssh -T git@gitee.com #gitee 注意#注释部分不要的 4.6 站点配置文件 打开站点配置文件填写代码库 例如我的 deploy: - type: git repository: github: git@github.com:Lruihao/Lruihao.github.io.git,master coding: git@git.coding.net:liruihao/liruihao.git,master #message: \"日常更新\" 4.7 部署 hexo clean hexo g -d 没出错就可以正常通过相应域名访问了。 https://lruihao.github.io https://liruihao.coding.me https://lruihao.gitee.io //手机 hexo 效果展示 5 ssh 连接电脑或者服务器 ssh root@118.24.217.167 会提示输入密码，linux 下输入密码是看不到的，大家都知道，小心点别输入错误。 之后就可以手机操作服务器了。 6 解决 npm 安装报错（未验证） vim $PREFIX/lib/node_modules/npm/node_modules/worker-farm/lib/farm.js 把里面的 length 改成 4，我默认的是 1。 7 nyancat 彩虹猫 彩虹貓（英语：Nyan Cat）是在 2011 年 4 月上传在 Youtube 的视频，并且迅速爆红于网络，並在 2011 年 YouTube 浏览量最高的视频中排名第五。 pkg install nyancat nyancat 还有更多姿势这里就不写了，只写一下日常用到的，就这样 OK 睡觉！ 8 termux 更多常用有趣命令（适用于 linux） vim $PREFIX/etc/motd chcolor chfont ~/.termux/colors.sh ~/.termux/fonts.sh echo \"https://www.lruihao.cn\" |curl -F-=\\\u003c- qrenco.de pkg install nyancat nyancat pkg install sl sl pkg install figlet figlet hello pkg install toilet toilet hello toilet -f mono12 -F gay \"hello\" pkg cowsay cowsay \"hello\" pkg install cmatrix cmatrix pkg install w3m w3m www.lruihao.cn cmatrix 常用命令如下： cmatrix-a : 异步滚动（默认） cmatrix-b : 随机粗体 cmatrix-B : 全部粗体 cmatrix-o : 使用旧风格滚动 cmatrix-x :X window 模式 cmatrix-V : 显示版本信息 cmatrix-u : 刷新频率，0-9，也就是滚动的快慢 cmatrix-C : 显示的颜色，支持 green（默认）,red,blue,white,yellow,cyan, magenta and black 例如：使用红色 cmatrix -b -C red 使用蓝色 cmatrix -b -C blue 等等 ........ 主义：在运行状态下，使用 0-9 数字，可以改变运行速度快慢。 开启你的装逼之路把，骚年！ ","date":"2018-10-23","objectID":"/posts/termux1/:0:0","tags":["Node.js","linux","termux"],"title":"termux 基本使用教程","uri":"/posts/termux1/"},{"categories":["Node.js"],"content":"HTML 网页引用中文字体，文件过大，加载缓慢的解决办法。 1 安装 Node.js font-spider 是 Node.js 的一个模块，所以需要安装 Node.js。 2 安装字蛛 输入命令 npm install font-spider -g 3 编写 HTML 新建一个 HTML 文件，引用字体文件，并使用自定义字体。如下： \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u003e \u003ctitle\u003e\u003c/title\u003e \u003cstyle type=\"text/css\"\u003e @font-face { font-family: MMT; src: url('MMT_579767_SOAJ0.ttf'); } body { font-family: MMT; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e 这里写要压缩的文字，吧啦吧啦…… \u003c/body\u003e \u003c/html\u003e 4 压缩字体 在当前目录下执行以下命令生成新的字体库： font-spider index.html 更新这篇文章时在 Mac 下执行的结果 写这篇文章时最开始在 Windows 下执行的结果 执行完后，它会把原来的字体文件移动到 .font-spider 文件夹，而 CSS 中引用的字体文件会被替换为新的压缩后的字体文件，这就是我们需要部署的字体文件。 下次执行只需要往 HTML 文件中添加新的文字，然后再执行 font-spider index.html 命令即可。 5 参考 font-spider ","date":"2018-10-17","objectID":"/posts/web-font/:0:0","tags":["Node.js","字体压缩"],"title":"ttf 字体压缩","uri":"/posts/web-font/"},{"categories":["OS"],"content":" 在 Linux 上编译 c 语言文件。 0.1 打开 vim 编辑器 （没有就用 vi, 或者先安装 vimsudo apt-get install vim) vim 0.2 编辑文件 打开文件编辑器之后编辑文件 首先按Esc再:进入末行命令 再保存为 hello.c 文件后退出 : w hello.c : q 打开目录看看生成的文件 ls 0.3 编译生成可执行文件并执行 gcc hello.c -o hello ./hello 若权限不够则加可执行权限chmod +x hello ","date":"2018-10-15","objectID":"/posts/linux-hello-c/:0:0","tags":["linux","C"],"title":"linux 编程初体验","uri":"/posts/linux-hello-c/"},{"categories":null,"content":" 提示 在线预览 预览 {{ message || '「沐目之，湘也」\\n 从下笔到停笔，从开始到结束，沐目体见证了我们稚嫩到成熟。\\n故事的开头往往极具温柔，但结局常常不尽人意。\\n那些忘不掉的人和事，岁月都已替我轻描淡写。' }} From playlist, Powered by mmt-netease. 点击展开更多 《富士山下》 《爱情转移》 前尘硬化像石头 阳光在身上流转 随缘地抛下便逃走 等所有业障被原谅 我绝不罕有 爱情不停站 往街里绕过一周 想开往地老天荒 我便化乌有 需要多勇敢 你还嫌不够 你不要失望 我把这陈年风褛 荡气回肠是为了 送赠你解咒 最美的平凡 下载 警告 沐目体 仅用于个人非商用！ ","date":"2018-10-12","objectID":"/projects/font-mmt/:0:0","tags":["沐目体"],"title":"沐目体","uri":"/projects/font-mmt/"},{"categories":["Grocery"],"content":"29 概念 流水线是指在程序执行时多条指令重叠进行操作的一种准并行处理实现技术。各种部件同时处理是针对不同指令而言的，它们可同时为多条指令的不同部分进行工作，以提高各部件的利用率和指令的平均执行速度。 未使用流水线 使用流水线 流水线周期为执行时间最长的一段。 30 流水线计算公式 首先使用理论公式，没有答案用实践公式。 31 流水线吞吐率计算 流水线吞吐率是指单位时间内处理的任务的数量。 基本公式 最大吞吐率 32 流水线加速比 完成一批任务，不使用流水线所用的时间与使用流水线所用的时间之比称为流水线的加速比。 公式：S=不使用流水线执行时间/使用流水线执行时间 流水线加速比越高越好，说明使用流水线的效果。 33 流水线的效率 34 例题 35 其他 35.1 主机 35.2 CISC 和 RISC 类型 指令 寻址方式 实现方式 其他 CISC（复杂指令集） 数量多，使用频率差别大，可变长格式 支持多种 微程序控制技术（微码） 研制周期长 RISC（精简指令集） 数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有 Load/Store 操作内存 支持方式少 增加了通用寄存器；硬布线逻辑控制为主；适合采用流水线 优化编码，有效支持高级语言 ","date":"2018-10-09","objectID":"/posts/liushuixian/:0:0","tags":["流水线","计算机组成与体系结构"],"title":"流水线","uri":"/posts/liushuixian/"},{"categories":["Grocery"],"content":"0.1 数据的表示 数据的表示可分为：原码，反码和补码。（二进制） 原码：符号位 0 为正，1 为负。 反码：符号位 0 为正，1 为负。 正数：反码同原码。 负数：符号位除外其他位按位取反。 补码： 正数：同原码。 负数：符号位除外其他位按位取反再 +1。 移码：补码符号位取反。 0.2 数据表示范围 原码： -(z^n-1 - 1) ~ 2^n-1 - 1 反码： -(z^n-1 - 1) ~ 2^n-1 - 1 补码： -z^n-1 ~ 2^n-1 - 1 （补码正 0 和负 0 相同，少占一数位，就多一个范围） 例： 8 位二进制，除去符号位还有 7 位，7 个 1 为最大数，相当于 8 个 1 减 1，也就是 2^7-1, 所以范围就算出来了。 0.3 浮点数运算 对阶（小阶对大阶）+ 尾数计算（科学计数法）+ 结果规格化（科学技术法） ","date":"2018-10-08","objectID":"/posts/data/:0:0","tags":["计算机数据","计算机组成与体系结构"],"title":"计算机数据","uri":"/posts/data/"},{"categories":["JavaScript"],"content":" 这几天看到别人的博客有开关灯效果，就想给自己的博客也加一个，其实以前就在想了。经过谷歌百度后这样实现了。css+js 如何给 Web 页面增加夜间模式功能？其实所谓的夜间模式就是在页面上增加一个透明的遮罩层，但是遮罩层会挡住页面元素，解决方法是 添加 DIV，给 DIV 的 outline 属性一个很大的 outline-width 值，用 outline 的边框作为遮罩，这样既能正常点击页面元素，又能达到夜间模式的效果。 0.17 css 部分 \u003cstyle\u003e .cover{ position:fixed; top: 0px; left: 0px; outline:5000px solid rgba(0, 0, 0, 0);//初始亮度 z-index: 99999; } \u003c/style\u003e 0.18 js 部分 \u003cscript\u003e var brightness; //显示遮罩 function cover(brightness) { if (typeof(div) == 'undefined') { div = document.createElement('div'); div.setAttribute('style', 'position:fixed;top:0;left:0;outline:5000px solid;z-index:99999;'); document.body.appendChild(div); } else { div.style.display = ''; } div.style.outlineColor = 'rgba(0,0,0,' + brightness + ')'; } //事件监听 window.addEventListener('keydown', function(e) { if (e.altKey \u0026\u0026 e.keyCode == 90) { cover(brightness = 0.3); } if (e.altKey \u0026\u0026 e.keyCode == 88) { cover(brightness = 0); } if (e.altKey \u0026\u0026 e.keyCode == 38) { if (brightness - 0.05 \u003e 0.05) cover(brightness -= 0.05); } if (e.altKey \u0026\u0026 e.keyCode == 40) { if (brightness + 0.05 \u003c 0.95) cover(brightness += 0.05); } }, false); \u003c/script\u003e 0.19 html 部分 \u003cdiv class=\"cover\"\u003e\u003c/div\u003e 0.20 使用 Alt+Z: 打开夜间模式 Alt+X: 关闭 Alt+↑: 增加亮度 Alt+↓: 降低亮度 ","date":"2018-09-27","objectID":"/posts/night/:0:0","tags":["JavaScript"],"title":"网页夜间效果","uri":"/posts/night/"},{"categories":["JavaScript"],"content":" 从暑假到现在有好几个小伙伴问我博客的标题怎么变来变去的，不想再和每个人都说一遍了，耽误时间，索性写一下。 1 创建一个 js 文件 我们先创建一个 js 文件，我们用记事本就好了，然后改个文件名，不妨就叫crash-cheat.js吧，你们可以随意！ 然后把文件放到 source 文件夹的 js 文件夹的 src 里面。（我用的 next 主题，放这里统一存放，其他主题随意） 崩溃欺骗 (Jquery 版） var OriginTitle = document.title; var titleTime; document.addEventListener('visibilitychange', function () { if (document.hidden) { $('[rel=\"icon\"]').attr('href', 'https://i.loli.net/2018/08/24/5b7fcb00ed9bf.png'); document.title = '怎么回事╭(°A°`)╮'; clearTimeout(titleTime); } else { $(\"[rel='icon']\").attr('href', 'https://i.loli.net/2018/09/25/5baa4f21661e7.png'); document.title = '小老弟 (ฅ\u003eω\u003c*ฅ)'; titleTime = setTimeout(function () { document.title = OriginTitle; $(\"[rel='icon']\").attr('href', '/images/favicon-32x32-next.png'); }, 2000); } }); 崩溃欺骗 (JS 版） var oldTitle = document.title; var titleTime; //標題恢復計時器 document.addEventListener('visibilitychange', function () { if (document.hidden) { document.querySelector(\"[rel='icon']\").setAttribute('href', '/images/icons/favicon-32.png'); document.title = '網站崩潰了！'; clearTimeout(titleTime); } else { document.title = '其實並沒有！'; document.querySelector(\"[rel='icon']\").setAttribute('href', '/images/icons/crash.png'); titleTime = setTimeout(function () { document.title = oldTitle; }, 1000); } }); 2 使用 在hexo\\themes\\hexo-theme-next\\layout文件路径找到layout.swig文件，其他有些主题用的是.ejs后缀，一样的。 然后打开文件，在\u003cbody\u003e\u003c/body\u003e之间加入调用刚刚的 js。 \u003cscript type=\"text/javascript\" src=\"/js/src/crash-cheat.js\"\u003e\u003c/script\u003e 重新部署博客就可以了。 ","date":"2018-09-26","objectID":"/posts/crash-cheat/:0:0","tags":["Hexo","JavaScript"],"title":"网页离开时改变标题“崩溃欺骗”","uri":"/posts/crash-cheat/"},{"categories":["Grocery"],"content":"0.21 下载 git wget https://github.com/git/git/archive/v2.14.1.zip 0.22 安装依赖 sudo yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder perl-ExtUtils-MakeMaker 0.23 解压 git unzip v2.14.1.zip 注： unzip 命令用不了，具体步骤如下： #yum list | grep zip/unzip #yum install zip #yum install unzip 基本完成，如果在编译的时候出现错误：gcc : error trying to exec 'cc1plus': execvp : No sunch file or directory 可以用gcc -v/g++ -v 来查看 gcc 版本，会发现没有安装。安装如下： #yum list | grep gcc #yum install gcc-c++ #yum install unzip 0.24 将 git 安装到/usr/local 上 先进入 git 文件夹 编译 安装 cd git-2.14.1 make prefix=/usr/local all make prefix=/usr/local install 0.25 验证是否安装完成 git --version … ","date":"2018-09-22","objectID":"/posts/linux-git/:0:0","tags":["Git","linux"],"title":"linux/centos 下的安装 git","uri":"/posts/linux-git/"},{"categories":["thoughts"],"content":" 手机便签里保存的一段话，也记不得在哪看到的了。 每一个优秀的人，都有一段沉默的时光，是那一段时光，不抱怨不诉苦，最后渡过了这段感动自己的日子。 什么都还没有，所以没有卖弄的资格。如果有了什么，就没有卖弄的必要。 人生的每一笔经历，都在书写你的简历。多做你本以为微不足道的事情，回头看的时候，都有着无法细数的刻度。 自己拼出来的东西，和别人送到嘴边的东西，意义和珍惜的程度都大为不同。 我从不担心我努力了不优秀，只担心优秀的人都比我更努力。 决定你高度的是你对自己的要求。 以前的我，常常担心、常常犹豫，可现在我发现，人生的每一个阶段，都需要我们有一种能力同一时间完成很多重要的事情。 学习的时候，我们要谈谈恋爱。工作的时候，我们要担心家庭。所以，这是一种平衡的能力。 相信我，你做得到。因为，那么那么多学长学姐都走过来了，所以不用怕不用怕，你从来都不是一个人。 不要抱怨，抱怨永远只能显示你没本事。因为如果你有本事，就可以改变现状，而不只是忍受。 既然改变不了，又不够走开，那么就沉默地接受现实。 隐忍，是我们抵抗世界的力量，当你拥有，你才有资格自由。 我们做的每一个决定，都是由自己来买单。 而当你可以把自己不喜欢的东西都做好的时候，相信你一定可以把自己喜欢的东西做的更好！ 努力和效果之间，永远有这样一段距离。成功和失败的唯一区别是，你能不能坚持挺过这段无法估计的距离。 你可以试试？ 坚持做一件事情，坚持下去。不管它是什么。 选择本身，就是放弃另一种跋涉的可能。尝试倾听自己内心的声音，而不是外在的掌声。 尝试选择适合自己的，而不是别人眼里最好的。尝试决定我们的决定，不是因为选项表面的光鲜亮丽。 所以，每当我们每做一个选择的时候，总记得兑现心中的对自己的承诺。 不要想得到一切，对生活对自己都慷慨一些。 ","date":"2018-09-21","objectID":"/posts/mood/:0:0","tags":["随笔"],"title":"每一个优秀的人，都有一段沉默的时光","uri":"/posts/mood/"},{"categories":["Memo"],"content":"Vim 速查表 - 帮你提高 N 倍效率 61 进入 vim 命令 描述 vim filename 打开或新建文件，并将光标置于第一行首 vim +n filename 打开文件，并将光标置于第 n 行首 vim + filename 打开文件，并将光标置于最后一行首 vim +/pattern filename 打开文件，并将光标置于第一个与 pattern 匹配的串处 vim -r filename 在上次正用 vim 编辑时发生系统崩溃，恢复 filename vim filename….filename 打开多个文件，依次编辑 62 vim 配置 命令 描述 all 列出所有选项设置情况 term 设置终端类型 ignorance 在搜索中忽略大小写 list 显示制表位 (Ctrl+I) 和行尾标志（$) number 显示行号 report 显示由面向行的命令修改过的数目 terse 显示简短的警告信息 warn 在转到别的文件时若没保存当前文件则显示 NO write 信息 nomagic 允许在搜索模式中，使用前面不带“\\”的特殊字符 nowrapscan 禁止 vi 在搜索到达文件两端时，又从另一端开始 mesg 允许 vi 显示其他用户用 write 写到自己终端上的信息 :set number / set nonumber 显示/不显示行号 :set ruler /set noruler 显示/不显示标尺 :set hlsearch 高亮显示查找到的单词 :set nohlsearch 关闭高亮显示 :syntax on 语法高亮 :set nu 显示行号 :set tabstop=8 设置 tab 大小，8 为最常用最普遍的设置 :set softtabstop=8 4:4 个空格，8: 正常的制表符，12: 一个制表符 4 个空格，16: 两个制表符 :set autoindent 自动缩进 :set cindent C 语言格式里面的自动缩进 63 移动光标 命令 描述 k nk 上 向上移动 n 行 j nj 下 向下移动 n 行 h nh 左 向左移动 n 行 l nl 右 向右移动 n 行 Space 光标右移一个字符 Backspace 光标左移一个字符 Enter 光标下移一行 w/W 光标右移一个字至字首 b/B 光标左移一个字至字首 e 或 E 光标右移一个字至字尾 ) 光标移至句尾 ( 光标移至句首 } 光标移至段落开头 { 光标移至段落结尾 n$ 光标移至第 n 行尾 H 光标移至屏幕顶行 M 光标移至屏幕中间行 L 光标移至屏幕最后行 0 （注意是数字零）光标移至当前行首 ^ 移动光标到行首第一个非空字符上去 $ 光标移至当前行尾 gg 移到第一行 G 移到最后一行 f 移动光标到当前行的字符 a 上 F 相反 % 移动到与制匹配的括号上去（），{}，[]，\u003c\u003e等 nG 移动到第 n 行上 G 到最后一行 64 屏幕滚动 命令 描述 Ctrl+u 向文件首翻半屏 Ctrl+d 向文件尾翻半屏 Ctrl+f 向文件尾翻一屏 Ctrl ＋ b 向文件首翻一屏 nz 将第 n 行滚至屏幕顶部，不指定 n 时将当前行滚至屏幕顶部 65 插入文本类 命令 描述 i 在光标前 I 在当前行首 a 光标后 A 在当前行尾 o 在当前行之下新开一行 O 在当前行之上新开一行 r 替换当前字符 R 替换当前字符及其后的字符，直至按 ESC 键 s 从当前光标位置处开始，以输入的文本替代指定数目的字符 S 删除指定数目的行，并以所输入文本代替之 ncw/nCW 修改指定数目的字 nCC 修改指定数目的行 66 删除命令 命令 描述 x/X 删除一个字符，x 删除光标后的，而 X 删除光标前的 dw 删除一个单词（删除光标位置到下一个单词开始的位置） dnw 删除 n 个单词 dne 也可，只是删除到单词尾 do 删至行首 d$ 删至行尾 dd 删除一行 ndd 删除当前行及其后 n-1 行 dnl 向右删除 n 个字母 dnh 向左删除 n 个字母 dnj 向下删除 n 行，当前行 + 其上 n 行 dnk 向上删除 n 行，当期行 + 其下 n 行 cnw[word] 将 n 个 word 改变为 word C$ 改变到行尾 cc 改变整行 shift+j 删除行尾的换行符，下一行接上来了 67 复制粘贴 命令 描述 p 粘贴用 x 或 d 删除的文本 ynw 复制 n 个单词 yy 复制一行 ynl 复制 n 个字符 y$ 复制当前光标至行尾处 nyy 拷贝 n 行 68 撤销 命令 描述 u 撤销前一次的操作 shif+u(U) 撤销对该行的所有操作 69 搜索及替换 命令 描述 /pattern 从光标开始处向文件尾搜索 pattern ?pattern 从光标开始处向文件首搜索 pattern n 在同一方向重复上一次搜索命令 N 在反方向上重复上一次搜索命令 cw newword 替换为 newword n 继续查找 . 执行替换 :s/p1/p2/g 将当前行中所有 p1 均用 p2 替代，g 表示执行 用 c 表示需要确认 :n1,n2 s/p1/p2/g 将第 n1 至 n2 行中所有 p1 均用 p2 替代 :g/p1/s//p2/g 将文件中所有 p1 均用 p2 替换 :1,$ s/string1/string2/g 在全文中将 string1 替换为 string2 70 书签 命令 描述 m[a-z] 在文中做标记，标记号可为 a-z 的 26 个字母 `a 移动到标记 a 处 71 visual 模式 命令 描述 v 进入 visual 模式 V 进入行的 visual 模式 ctrl+v 进如块操作模式用 o 和 O 改变选择的边的大小 在所有行插入相同的内容如 include\u003c 将光标移到开始插入的位置，按 CTRL+V 进入 VISUAL 模式，选择好模块后按 I（shift+i)，后插入要插入的文本，按 [ESC] 完成 72 行方式命令 命令 描述 :n1,n2 co n3 将 n1 行到 n2 行之间的内容拷贝到第 n3 行下 :n1,n2 m n3 将 n1 行到 n2 行之间的内容移至到第 n3 行下 :n1,n2 d 将 n1 行到 n2 行之间的内容删除 :n1,n2 w!command 将文件中 n1 行至 n2 行的内容作为 command 的输入并执行之 若不指定 n1，n2，则表示将整个文件内容作为 command 的输入 73 宏 命令 描述 q[a-z] 开始记录但前开始的操作为宏，名称可为【a-z】，然后用 q 终止录制宏 reg 显示当前定义的所有的宏，用@[a-z] 来在当前光标处执行宏 [a-z] 74 窗口操作 命令 描述 :split 分割一个窗口 :split file.c 为另一个文件 file.c 分隔窗口 :nsplit file.c 为另一个文件 file.c 分隔窗口，并指定其行数 ctrl ＋ w 在窗口中切换 :close 关闭当前窗口 75 文件及其他 命令 描述 :q 退出 vi :q! 不保存文件并退出 vi :e filename 打开文件 filename 进行编辑 :e! 放弃修改文件内容，重新载入该文件编辑 :w 保存当前文件 :wq 存盘退出 :ZZ 保存当前文档并退出 VIM :!command 执行 shell 命令 command :r!command 将命令 command 的输出结果放到当前行 :n1,n2 write temp.c :read file.c 将文件 file.c 的内容插入到当前光标所在的下面 ","date":"2018-08-31","objectID":"/posts/vim/:0:0","tags":["vim","他山之石"],"title":"Vim 速查表","uri":"/posts/vim/"},{"categories":["Memo"],"content":" 警告 2018/11/1 说明 next 主题好像更新了，现在自带的可以用了，如果可以用了，以下教程可以忽略！！！ 最近有几个小伙伴问我博客的字数统计怎么实现的，怎么网上的教程不管用啊？一开始我搭建博客的时候也遇到了类似的问题，按照 github 上 wordcount 的 readme 操作后，并没有什么用，我打开 post 相关配置文件并没有发现发现 wordcount 这个关键词，next 本身似乎也并没有在主题配置文件提供选项（或许是个人原因），所以只好自己动手加一个了。为了不重复回答问题，先做个原创记录。转载请注明出处。在此抛转引玉，如果有更好的方法请在留言区提出，我会及时更改。同时也希望小伙伴多发扬折腾精神，多专研，少提问，毕竟还是 RTFSC 大法好！(Read the fucking source code) 13 安装 wordcount github 如果没有安装 hexo-wordcount 插件，先安装该插件： npm i --save hexo-wordcount # Node 版本 7.6.0 之前，请安装 2.x 版本 (Node.js v7.6.0 and previous) npm install hexo-wordcount@2 --save 14 post 添加 打开hexo\\themes\\hexo-theme-next\\layout\\_macro路径下的 post.swig 文件，既然没有字数统计那么我们就加一个，简单暴力地直接在阅读数后面加上一条就好了，在文件类搜索关键词busuanzi, 我用的是不蒜子，如果用的了 leancloud 的搜 leancloud 就好了，其他类似。找到这段代码后 {% if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %} \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e \u003cspan class=\"post-meta-item-icon\" {% if not theme.post_meta.item_text %} title=\"{{ __('post.views') }}\" {% endif %}\u003e \u003ci class=\"fa fa-{{ theme.busuanzi_count.post_views_icon }}\"\u003e\u003c/i\u003e {% if theme.post_meta.item_text %} {{__('post.views') + __('symbol.colon') }} {% endif %} \u003cspan class=\"busuanzi-value\" id=\"busuanzi_value_page_pv\" \u003e\u003c/span\u003e \u003c/span\u003e {% endif %} 在endif上面，即本文代码块那个空行处添加以下代码 \u003cspan class=\"post-meta-divider\"\u003e|\u003c/span\u003e \u003cspan title=\"{{ __('post.wordcount') }}\"\u003e\u003cspan class=\"post-meta-item-icon\"\u003e\u003ci class=\"fa fa-file-word-o\"\u003e\u003c/i\u003e\u003c/span\u003e字数： {{ wordcount(post.content) }}\u003c/span\u003e 15 全站添加 打开hexo\\themes\\hexo-theme-next\\layout\\_partials路径下 footer.swig 文件，在你喜欢的位置添加以下代码 \u003cdiv class=\"theme-info\"\u003e \u003cdiv class=\"powered-by\"\u003e\u003c/div\u003e \u003cspan class=\"post-count\"\u003e全站共 {{ totalcount(site) }} 字\u003c/span\u003e \u003c/div\u003e ","date":"2018-08-30","objectID":"/posts/hexo-wordcount/:0:0","tags":["Hexo","字数统计"],"title":"hexo next 主题添加字数统计（2018）","uri":"/posts/hexo-wordcount/"},{"categories":["Memo"],"content":"搭建这个博客以来，隔一段时间就出现一次部署失败的错误，每次都差不多，莫名其妙地出现的。前几次不知道怎么瞎搞就好了。 现在做一下记录，防止以后出错用。 错误如下 Connection reset by 13.229.188.59 port 22 fatal: sha1 file '\u003cstdout\u003e' write error: Broken pipe fatal: The remote end hung up unexpectedly FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error: Connection reset by 13.229.188.59 port 22 fatal: sha1 file '\u003cstdout\u003e' write error: Broken pipe fatal: The remote end hung up unexpectedly at ChildProcess.\u003canonymous\u003e (H:\\Hexo\\node_modules\\hexo-util\\lib\\spawn.js:37:17) at emitTwo (events.js:106:13) at ChildProcess.emit (events.js:191:7) at ChildProcess.cp.emit (H:\\Hexo\\node_modules\\cross-spawn\\lib\\enoent.js:40:29) at maybeClose (internal/child_process.js:850:16) at Socket.\u003canonymous\u003e (internal/child_process.js:323:11) at emitOne (events.js:96:13) at Socket.emit (events.js:188:7) at Pipe._handle.close [as _onclose] (net.js:492:12) ... 确保 ssh 正常，hexo-deploy-git 插件正常的情况下删除。deploy_git 文件夹就好了。 最后吐槽一下，这个鬼错误，搞我一晚上醉了。我又打算重装了的。/吐血 ","date":"2018-08-21","objectID":"/posts/hexo-d-error/:0:0","tags":["Hexo"],"title":"hexo d 出错","uri":"/posts/hexo-d-error/"},{"categories":["Memo"],"content":" 本文适合我这种纯小白。 目前为止，全网也就只有一个博主写到过这样动态显示 subtitle 的文章。传送门（关键词：js, 后加载） 但是嘞，该博写的不怎么详细，17 年底写的。当然更大的可能是 next 更新了一些文件结构，所以不适合现在使用了。以前我按原博的流程配置了一下没成功就搁在那里了，今天突然心血来潮。翻了翻原博主博客的源码，再与自己的对比了一下，发现了一些端倪。稍作调整后如下： 21 修改站点配置文件，主要修改 subtitle subtitle: 不怕万人阻挡，只怕自己投降。W 你如何回忆，决定你是一个怎样的人！W 这是一个句子。W 这是另一个句子。W 这些句子你们不要搞一样的不然怎么叫个性签名-_-！。 句子与句子之间以 W 分割，后续需要根据该标志位去拆分句子组。 小伙伴们博主这里只是提供一个思路，不要和我用一模一样的啊，不然撞了多尴尬呀 22 修改 header\\index.swig 修改 themes\\next\\layout_partials\\header 下面的 index.swig 文件 在最开头添加如下代码： （这里用的原博的 js) \u003cscript\u003e function GetRandomNum(Min,Max) { var Range = Max - Min; var Rand = Math.random(); return(Min + Math.round(Rand * Range)); } function setSidebarMarginTop (headerOffset) { return $('#sidebar').css({ 'margin-top': headerOffset }); } function getHeaderOffset () { return $('.header-inner').height() + CONFIG.sidebar.offset; } window.onload=function(){ var subtitle = \"{{config.subtitle}}\"; var mytitle = subtitle.split(\"W\"); var max = mytitle.length-1; var index = GetRandomNum(0,max); var text = mytitle[index]; $(\"#helloTitle\").html(text); var headOffset = getHeaderOffset(); setSidebarMarginTop(headOffset); //动态 subtitle 设置 } \u003c/script\u003e 23 修改 brand.swig 找到 {% if subtitle %} {% if theme.seo %} ... {% else %} ... {% endif %} {% endif %} 把这一段，把原来的修改成以下代码即可 ps: title和subtitle的字体还有颜色也可以在这个文件修改，即使用style标签，按个人爱好修改也可不要。 {% if subtitle %} {% if theme.seo %} \u003cp class=\"site-subtitle\" id=\"helloTitle\" itemprop=\"description\"\u003e\u003c/p\u003e {% else %} \u003cp id=\"helloTitle\" class=\"site-subtitle\"\u003e\u003c/p\u003e {% endif %} {% endif %} 之后部署后每次刷新就可以看到不同的 subtitle 了，开心 😀 24 今日诗词 今日诗词 \u003cspan id=\"jinrishici-sentence\"\u003e正在加载今日诗词 ....\u003c/span\u003e \u003cscript src=\"https://sdk.jinrishici.com/v2/browser/jinrishici.js\" charset=\"utf-8\"\u003e\u003c/script\u003e 正在加载今日诗词 .... 25 api 调用 直接 js 调用 api 简单快速 2021/9/30 更新 一言 api-参数详见 已经挂了 \u003cdiv\u003e \u003cscript type=\"text/javascript\" src=\"https://api.imjad.cn/hitokoto/?cat=\u0026charset=utf-8\u0026length=\u0026encode=js\u0026fun=sync\u0026source=\"\u003e\u003c/script\u003e \u003cdiv id=\"hitokoto\"\u003e \u003cscript\u003e hitokoto(); \u003c/script\u003e \u003c/div\u003e \u003c/div\u003e ","date":"2018-08-20","objectID":"/posts/dongtaisub/:0:0","tags":["Hexo","JavaScript"],"title":"hexo 个性化 - next 主题动态显示 subtitle","uri":"/posts/dongtaisub/"},{"categories":["瞎折腾"],"content":"七夕又快到了，分享一个曾经玩过的代码，用 C 语言画一个跳动的心，很有逼格有木有。 大一在机房拍的图 #include \u003cstdio.h\u003e #include \u003cmath.h\u003e #include \u003cwindows.h\u003e #include \u003ctchar.h\u003e float f(float x, float y, float z) { float a = x * x + 9.0f / 4.0f * y * y + z * z - 1; return a * a * a - x * x * z * z * z - 9.0f / 80.0f * y * y * z * z * z; } float h(float x, float z) { for (float y = 1.0f; y \u003e= 0.0f; y -= 0.001f) if (f(x, y, z) \u003c= 0.0f) return y; return 0.0f; } int main() { HANDLE o = GetStdHandle(STD_OUTPUT_HANDLE); _TCHAR buffer[25][80] = { _T(' ') }; _TCHAR ramp[] = _T(\".:-=+*#%@\"); for (float t = 0.0f;; t += 0.1f) { int sy = 0; float s = sinf(t); float a = s * s * s * s * 0.2f; for (float z = 1.3f; z \u003e -1.2f; z -= 0.1f) { _TCHAR* p = \u0026buffer[sy++][0]; float tz = z * (1.2f - a); for (float x = -1.5f; x \u003c 1.5f; x += 0.05f) { float tx = x * (1.2f + a); float v = f(tx, 0.0f, tz); if (v \u003c= 0.0f) { float y0 = h(tx, tz); float ny = 0.01f; float nx = h(tx + ny, tz) - y0; float nz = h(tx, tz + ny) - y0; float nd = 1.0f / sqrtf(nx * nx + ny * ny + nz * nz); float d = (nx + ny - nz) * nd * 0.5f + 0.5f; *p++ = ramp[(int)(d * 5.0f)]; } else *p++ = ' '; } } for (sy = 0; sy \u003c 25; sy++) { COORD coord = { 0, sy }; SetConsoleCursorPosition(o, coord); WriteConsole(o, buffer[sy], 79, NULL, 0); } Sleep(33); } } exe 文件下载 ","date":"2018-08-15","objectID":"/posts/heart/:0:0","tags":["C"],"title":"“高逼格”C 语言画心","uri":"/posts/heart/"},{"categories":["Git"],"content":"在 git 没有运行完成之前强制关闭，下次提交的时候会产以下生错误，或者类似的。 fatal: Unable to create '/xxx/xx/.git/index.lock': File exists. If no other git process is currently running, this probably means a git process crashed in this repository earlier. Make sure no other git process is running and remove the file manually to continue. 原因是在你进行某些比较费时的 git 操作时自动生成，操作结束后自动删除，相当于一个锁定文件，目的在于防止对一个目录同时进行多个操作。 有时强制关闭进行中的 git 操作，这个文件没有被自动删除，之后你就无法进行其他操作，必须手动删除，进入。git 文件中删除，打开显示隐藏文件。如果没有看见。git 文件夹，可以直接用命令 rm -f ./.git/index.lock 。之后就可以正常使用。 ","date":"2018-08-14","objectID":"/posts/git-index-lock/:0:0","tags":["Git"],"title":"git index.lock","uri":"/posts/git-index-lock/"},{"categories":["Memo"],"content":" 暑假刚开始的时候放假回家没带电脑，只能玩手机，想折腾一下博客都没有条件，在一个发现一个 app, 卧槽 😱，termux 真的强大！（初始化需要科学上网）安卓手机上的 linux 简直了，在手机就可以搭了一个 hexo 博客，只要在 github 上实现分支管理就可以多终端同步更新了。恕我学疏才浅，还只想到这些！一开始想回校后，折腾一下 hexo-admin 实现类似动态博客一样的多终端管理（手动滑稽），现在发现 termux 这样子的操作也不错嘛，挺装哔 hhhhhh**部署后的效果** 1 准备 Termux 文件管理器（RE,MT 文件管理器等高级一点的） 2 开始 打开 Termux，输入$pkg install nodejs安装 Nodejs，在输入pkg install git安装 Git。 过程会出现一个提示，输入 y 回车确认即可。 按照 Hexo 官网提示安装 Hexo。 npm install hexo-cli -g hexo init blog cd blog 注意 ssh 配置先安装：pkg install openssh 然后按照基本操作配置 Hexo，GitHub 或者 gitee,coding 等连上，部署测试一次。 安装部署插件npm install hexo-deployer-git --save，部署hexo d -g 没有问题的话进行下一步。 3 编辑 写文章的话创建 md 文件命令和电脑上一样，文件管理器打开/data/data/com.termux/files/home/i/source/_posts/ 编辑文章 md 文件。这种方式需要 Root。 没有 Root 的话可以使用 Vim，网上很多教程。但是这种方式相对来说更麻烦。 4 参考 termux 高级终端安装使用配置教程 使用 Termux 在手机上运行 linux 黑科技 hexo 搭建过程 超详细教程 5 效果图（未连接 github，coding 等） 效果图 1 效果图 2 效果图 3 效果图 4 ","date":"2018-08-11","objectID":"/posts/termux/:0:0","tags":["Hexo","Node.js","termux"],"title":"在 Android 上搭建 hexo 博客","uri":"/posts/termux/"},{"categories":["ACM"],"content":"链接：https://www.nowcoder.com/acm/contest/157/A 来源：牛客网 1 题目描述 xb 有 m 种石子，每种无限个，Ta 想从这些石子中取出 n 个，并按顺序排列起来，为了好看，相邻的石子不能相同。xb 想知道有多少种排列的方法。 2 输入描述 第一行有两个正整数 n，m。 3 输出描述 第一行一个整数，表示在 m 种石子中取出 n 个的排列方案数模 1000000007 后的值。 4 示例 1 输入 1 1 输出 1 5 示例 2 输入 2 3 输出 6 6 示例 3 输入 3 3 输出 12 7 备注 对于 100% 的测试数据： 1 ≤ n, m ≤ 1000 数据量较大，注意使用更快的输入输出方式。 水题。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long n,m,ans; scanf(\"%lld%lld\",\u0026n,\u0026m); ans=m; for(int i=1;i\u003cn;i++) ans=(ans*(m-1))%1000000007; printf(\"%lld\\n\",ans); return 0; } ","date":"2018-08-10","objectID":"/posts/nowcoder157a/:0:0","tags":["数学","组合数学","ACM","Nowcoder","C++"],"title":"石子阵列（组合数学）","uri":"/posts/nowcoder157a/"},{"categories":["ACM"],"content":"题目链接 Dreamoon wants to climb up a stair of n steps. He can climb 1 or 2 steps at each move. Dreamoon wants the number of moves to be a multiple of an integer m. What is the minimal number of moves making him climb to the top of the stairs that satisfies his condition? 1 Input The single line contains two space separated integers n, m (0 \u003c n ≤ 10000, 1 \u003c m ≤ 10). 2 Output Print a single integer — the minimal number of moves being a multiple of m. If there is no way he can climb satisfying condition print - 1 instead. 3 Examples 3.1 input1 10 2 3.2 output1 6 3.3 input2 3 5 3.4 output2 -1 3.5 Note For the first sample, Dreamoon could climb in 6 moves with following sequence of steps: {2, 2, 2, 2, 1, 1}. For the second sample, there are only three valid sequence of steps {2, 1}, {1, 2}, {1, 1, 1} with 2, 2, and 3 steps respectively. All these numbers are not multiples of 5. 有一个 n 级台阶，每次可以走一级或两级，问最少的步数是多少，且步数必须是 m 的倍数。 找一下数学公式就好了。 具体看代码。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int x,n,m; cin\u003e\u003en\u003e\u003em; if(n\u003cm){ cout\u003c\u003c-1\u003c\u003cendl; return 0; } if(n==m){ cout\u003c\u003cn\u003c\u003cendl; return 0; } if(n%2==0){ x=n/2%m; if(x==0) cout\u003c\u003cn/2\u003c\u003cendl; else cout\u003c\u003cn/2+m-x\u003c\u003cendl; }else if(n%2!=0){ x=(n/2+1)%m; if(x==0) cout\u003c\u003cn/2+1\u003c\u003cendl; else cout\u003c\u003c(n/2+1)+m-x\u003c\u003cendl; } return 0; } ","date":"2018-08-10","objectID":"/posts/codeforces476a/:0:0","tags":["Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and Stairs","uri":"/posts/codeforces476a/"},{"categories":["ACM"],"content":"题目链接 1 题目大意 就是给定两个字符串，第一个字符串由\"+\",\"-“组成，第二个字符串由”+\",\"-\",\"?“组成，“+”代表加 1，”-“代表减一，“?“代表可取正也可取负，问第二个字符串的位置和第一个字符串相等的概率是多少。 我一开始的想法是把（+1，-1）^n 看成和二项式定理一样的展开始式，只不过把乘法改为加法，然后得到公式 c(n,0)(n+(-1)0)+c(n,1)(n-1+(-1)1)+c(n,i)(n-i+(-1)i)+...+c(n,n)(n-n+(-1)n) 化简一下可知通项为c(n,i)(n-2*i) 然后我对第一个串求出位置 sum, 第二个串先求出已知位置 sum1，然后记录下？的个数，然后遍历找出展开式中某一项 n-2i+sum1==sum，这样 x 的系数就是可能出现位置相等的所有情况，用 (n-2i)/系数和就是概率了啊，可是为什么不对呢，本地调试，数据没问题，可是交到 cf 上第二组都过不了，烦亏我还觉得想到一个独辟的方法呢，过不了。 //cf 错误报告，思前恐后不晓得 why,wtf??? 先码着吧 Test: #2, time: 0 ms., memory: 0 KB, exit code: 0, checker exit code: 1, verdict: WRONG_ANSWER Input +-+- +-?? Output -0.000000000000 Answer 0.500000000000 Checker Log wrong answer 1st numbers differ - expected: '0.5000000', found: '-0.0000000', error = '0.5000000' 2 错误代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int i,j,cnt=0; long long c[11][11],sum=0,sum1=0; for(i = 0; i \u003c 11; i++){//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(j = 1; j \u003c i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; } string a,b; cin\u003e\u003ea\u003e\u003eb; //cout\u003c\u003ca\u003c\u003cendl\u003c\u003cb\u003c\u003cendl; int len=a.length(); for(i=0;i\u003clen;i++) if(a[i]=='+') sum+=1; else sum-=1; for(i=0;i\u003cb.length();i++){ if(b[i]=='+') sum1+=1; else if(b[i]=='-')sum1-=1; if(b[i]=='?') cnt++; } if(sum==sum1\u0026\u0026cnt==0){ printf(\"1.000000000000\\n\"); return 0; } int flag=0; int x=0; for(j=0;j\u003c=cnt;j++) x+=c[cnt][j]; //cout\u003c\u003cx\u003c\u003cendl; for(i=0;i\u003c=cnt;i++) if(cnt-2*i+sum1==sum){ flag=1; long double y=c[cnt][i]*1.0/x; printf(\"%.12llf\\n\",y); } if(!flag)printf(\"0.000000000000\\n\"); return 0; } 想不通，没办法只好换思路。 我先分别记下 a,b 串的’+’,’-’,’?‘个数，然后后我们很容易知道，如要 a,b 位置相等，则加号和减号的数目，两串要相等，且 a 中的加号要比 b 中已知的加号要多，减号也要比 b 中已知的要多，否则打死都不会相等的，仔细比划一下就知道了。然后有 z 个‘?’，相当于有 z 个坑，让我们去填使得 a,b 相等。只能填 + 或-，设加号差等于 x-p, 所以概率就等于 c(z,x-p)/2^z。 3 AC 代码 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ string a,b; int x,y,z,p,q,c[11][11],i,j; for(i = 0; i \u003c 11; i++){ c[i][0] = 1; c[i][i] = 1; for(j = 1; j \u003c i; j++) c[i][j] = c[i-1][j] + c[i-1][j-1]; } cin\u003e\u003ea; cin\u003e\u003eb; x=y=z=p=q=0; for(i=0;i\u003ca.length();i++) if(a[i]=='+') x++; else y++; for(i=0;i\u003cb.length();i++){ if(b[i]=='+') p++; else if(b[i]=='-') q++; else z++; } if(x==p\u0026\u0026z==0){ printf(\"1.000000000000\\n\"); return 0; } if(x-p\u003c0||y-q\u003c0) { printf(\"0.000000000000\\n\"); return 0; } x=x-p; printf(\"%0.12f\",c[z][x]*1.0/(2\u003c\u003c(z-1))); return 0; } 几分钟写完后面的代码，心中一万头草泥马在奔腾。 ","date":"2018-08-10","objectID":"/posts/codeforces476b/:0:0","tags":["组合数学","Codeforces","ACM","数学","C++","C"],"title":"Dreamoon and WiFi（组合数学）","uri":"/posts/codeforces476b/"},{"categories":["ACM"],"content":"1 题意 给出 a,b,c,x1,x2,y1,y2，求满足 ax+by+c=0，且 x∈[x1,x2],y∈[y1,y2] 的整数解个数。 2 分析 对于解二元一次不定方程，容易想到利用扩展欧几里得求出一组可行解后找到通解，下面来介绍一下欧几里得以及扩展欧几里得。 2.1 欧几里得 又名辗转相除法，是用来计算两个数的最大公约数，其中就是利用 gcd(a,b)=gcd(b,a mod b) 来求解。下证 gcd(a,b)=gcd(b,a mod b) 的正确性： 设 a,b 的一个公约数为 d 设 a mod b=r，则 a=kb+r(k 为整数），r=a-kb 因为 d|a,d|b 所以 d|a-kb, 即 d|r，而 r=a mod b 所以 d 为 b,a mod b 的公约数 又因为 d 也为 a,b 的公约数，所以（a,b) 和 (b,a mod b) 的公约数一样，所以最大公约数必然一样，得证。 代码描述： int gcd(int a,int b) { if (b==0) return a; return gcd(b,a%b); } 2.2 扩展欧几里得 顾名思义，为上述欧几里得算法的扩展。欧几里得是用来求 a,b 的最大公约数，那么扩展欧几里得不仅能求出 a,b 的最大公约数，还能求出满足 ax+by=gcd(a,b) 的一组可行解。 求解过程中，扩展欧几里得比欧几里得多了一个赋值过程，具体证明如下： 设 ax1+by1=gcd(a,b),bx2+(a mod b)y2=gcd(b,a mod b) 因为由欧几里得算法可知，gcd(a,b)=gcd(b,a mod b) 所以 ax1+by1=bx2+(a mod b)y2 因为a mod b=a-(a div b)*b（div 为整除 所以有ax1+by1=bx2+(a-(a div b)*b)y2 将右边移项，展开得： ax1+by1=ay2+bx2-(a div b)*b*y2 =ay2+b[x2-(a div b)]y2 所以可得： x1=y2 y1=x2-(a div b)*y2 将得到的的 x1,y1 递归操作求解 x2,y2，如此循环往复，将会像欧几里得一样得到 b=0 的情况，此时递归结束，返回 x=1,y=0，回溯得解。 代码描述： 此函数返回的是 a,b 的最大公约数，同时也求解出满足 ax+by=gcd(a,b) 的一组可行的 (x,y) int exgcd(int a,int b,int \u0026x,int \u0026y) { if (b==0) {x=1;y=0;return a;} int t=exgcd(b,a%b,x,y); int x0=x,y0=y; x=y0;y=x0-(a/b)*y0; return t; } 2.3 关于求解二元一次不定方程 ax+by=c 首先，如果 c 不是 gcd(a,b) 的倍数，方程显然无解。 扩展欧几里得求解的是 ax+by=gcd(a,b)=1 的可行解，但是题目中并没有说 c 与 a,b 互质之类的条件，所以需要在开始时两边同时除以 gcd(a,b)。 设 d=gcd(a,b) 设 a’=a/d,b’=b/d,c’=c/d, 则下面需要求解 a’x+b’y=c’的整数解，而 gcd(a’,b’)=1， 则我们只需求 a’x+b’y=1 的可行解 直接使用扩展欧几里得，得到 (x’,y’), 则最终解为x'*c',y'*c'设为 (x0,y0)。 现在得到了一组可行解，但是如何得到通解呢？ 将 (x0,y0) 代入 ax+by=c，则有 a*(x0)+b*(y0)=c 通过拆添项，可有： a*(x0+1*b)+b*(y0-1*a)=c a*(x0+2*b)+b*(y0-2*a)=c a*(x0+3*b)+b*(y0-3*a)=c …… a*(x0+k*b)+b*(y0-k*a)=c (k∈Z) 至此，我们得到了通解的方程 x=x0+k*b y=y0-k*a (k∈Z) 这样，所有满足 ax+by=c 的可行解都可求出。 3 具体实现 有了主体算法，下面要谈到具体实现了。 3.1 先处理一下无解的情况 当 a=0 并且 b=0，而 c≠0 时，显然无解； 当 a=0,b=0，而 c=0 时，[x1,x2],[y1,y2] 都为可行解，根据乘法原理，可行解的个数为(x2-x1+1)*(y2-y1+1); 当 a=0 b≠0 时： 此时即为求解 by=c，则 y=c/b， 如果 c/b 不是整数或 c/b 不在 [y1,y2] 的范围内，无解 否则 [x1,x2] 内全部整数都为可行解。 当 b=0,a≠0 时，同上。 若 c 不是 gcd(a,b) 的个数，方程显然无解。 3.2 处理完了一些繁琐的细节后，下面是具体的求解过程 扩展欧几里得求解的是 ax+by=c，而本题是 ax+by+c=0，需将 c 移项。 对于本道题，首先要注意的是，对于负数的模运算在此算法中无法得到正确解，所以要处理一下 a,b,c 的正负情况。 如果 a 为负数，只需将 a 取相反数后，再处理一下 x∈[x1,x2] 的范围。当 a 取了相反数，相当于把 x 也取反，则需要把 x 的范围由 [x1,x2] 转变成 [-x2,-x1], 类似于把数轴反了过来。b 同理。 利用扩展欧几里得解二元一次不定方程，得到一组可行解 (x0,y0)。 因为题目中对 x,y 有条件约束，而有 x=x0+kb,y=y0-kb，我们可以求出满足 x∈[x1,x2],y∈[y1,y2] 的 k 的取值范围， 即为求解 x1\u003c=x0+kb\u003c=x2,y1\u003c=y0-kb\u003c=y2 的整数 k 的个数 但是在求解这两个一次函数的过程中，会有除不尽的现象，该如何取整呢？ 举个例子 当出现 2.5\u003c=k\u003c=5.5 时，我们需要的可行的 k 为 3,4,5，所以需要将 2.5 向上取整得到 3，5.5 向下取整得到 5，即为 3\u003c=k\u003c=5； 当出现 -5.5\u003c=\u003c=-2.5 时，我们需要的可行的 k 为 -5,-4,-3, 所以需要将 -5.5 向上取整得到 -5,-2.5 向下取整得到 -3，即为 -5\u003c=k\u003c=-3； 正负数的情况都已经考虑完全了，可以得到取整的结论：上界下取整，下界上取整。 最后，将得到的两个范围取交集，得到 [l,r]，则最终答案为 r-l+1。 这样，本题就可以完美解决了。 // BY Rinyo #include\u003ccstdio\u003e #include\u003ccmath\u003e long long a,b,c,x1,x2,yy1,y2,x0,yy0; inline long long cmin(const long long \u0026x,const long long \u0026y) {return x\u003cy?x:y;} inline long long cmax(const long long \u0026x,const long long \u0026y) {return x\u003ey?x:y;} long long gcd(long long a,long long b) { if (b==0) return a; return gcd(b,a % b); } void exgcd(long long a,long long b) { if (b==0){x0=1;yy0=0;return;} exgcd(b,a%b); long long t=x0;x0=yy0;yy0=t-a/b*yy0; return; } int main() { scanf(\"%I64d%I64d%I64d%I64d%I64d%I64d%I64d\",\u0026a,\u0026b,\u0026c,\u0026x1,\u0026x2,\u0026yy1,\u0026y2); c=-c; if (c\u003c0) {a=-a;b=-b;c=-c;} if (a\u003c0) {a=-a;long long t=x1;x1=-x2;x2=-t;} if (b\u003c0) {b=-b;long long t=yy1;yy1=-y2;y2=-t;} if (a==0 \u0026\u0026 b==0) { if (c==0) { printf(\"%I64d\",(x2-x1+1)*(y2-yy1+1)); return 0; } printf(\"0\");return 0; } else if (a==0) { if (c %b ==0) if (c/b\u003c=y2 \u0026\u0026 c/b\u003e=yy1) {printf(\"%I64d\",x2-x1+1);return 0;} printf(\"0\");return 0; } else if (b==0) { if (c%a==0) if (c/a\u003c=x2 \u0026\u0026 c/a\u003e=x1) {printf(\"%I64d\",y2-yy1+1);return 0;} printf(\"0\");return 0; } long long d=gcd(a,b); if (c%d!=0){printf(\"0\");return 0;} a=a/d;b=b/d;c=c/d; exgcd(a,b); x0=x0*c;yy0=yy0*c; double tx2=x2,tx1=x1,tx0=x0,ta=a,tb=b,tc=c,ty1=yy1,ty2=y2,ty0=yy0; long long down1=floor(((tx2-tx0)/tb)),down2=floor(((ty0-ty1)/ta)); long long r=cmin(down1,down2); long long up1=ceil(((tx1-tx0)/tb)),up2=ceil(((ty0-t","date":"2018-08-10","objectID":"/posts/euclid/:0:0","tags":["数学","数论","ACM","欧几里得","他山之石","C++","C"],"title":"The equation-SGU106（扩展欧几里得）","uri":"/posts/euclid/"},{"categories":["ACM"],"content":"1 题目链接 2 题目大意 给定两个数 n,k 求 n^k 的前三位和最后三位。 3 分析 求后三位的话：直接快速幂，对 1000 取模就好了。 求前三位，对于给定的一个数 n, 它可以写成 n=10a, 其中这个 a 为浮点数，则t=n^k=(10^a)^k=10^a*k=(10^x)*(10^y);其中 x,y 分别是a*k的整数部分和小数部分，对于 t=nk 这个数，它的位数由 (10x) 决定，它的位数上的值则有 (10y) 决定，因此我们要求 t 的前三位，只需要将 10y 求出，在乘以 100，就得到了它的前三位。 分析完，我们再整体看，设 nk=10^z; 那么z=k*log10(n) fmod(z,1)可以求出 x 的小数部分。 //再一次吐槽 lightoj 的头文件，让我不能用万能头\u003cbits/stdc++.h\u003e #include\u003cstdio.h\u003e #include\u003cmath.h\u003e typedef long long LL; int quickpow (int m, int n, int k) { int b = 1; while (n \u003e 0) { if (n \u0026 1) b = (b * m) % k; n \u003e\u003e= 1; m = (m * m) % k; } return b%k; } int main () { int t, flag = 1; scanf (\"%d\", \u0026t); while (t--) { LL n, k; scanf (\"%lld %lld\", \u0026n, \u0026k); int first = pow (10.0, 2.0 + fmod (k*log10(n*1.0), 1)); int last = quickpow (n%1000, k, 1000); printf (\"Case %d: %d %03d\\n\", flag++, first, last); } return 0; } 4 注 C 库函数 - fmod() C 库函数 double fmod(double x, double y) 返回 x 除以 y 的余数。 x — 代表分子的浮点值。 y — 代表分母的浮点值。 该函数返回 x/y 的余数。 下面的实例演示了 fmod() 函数的用法。 #include \u003cstdio.h\u003e #include \u003cmath.h\u003e int main () { float a, b; int c; a = 9.2; b = 3.7; c = 2; printf(\"%f / %d 的余数是 %lf\\n\", a, c, fmod(a,c)); printf(\"%f / %f 的余数是 %lf\\n\", a, b, fmod(a,b)); return(0); } 结果： 9.200000 / 2 的余数是 1.200000 9.200000 / 3.700000 的余数是 1.800000 ","date":"2018-08-09","objectID":"/posts/lightoj1282/:0:0","tags":["数论","数学","快速幂","ACM","C"],"title":"Leading and Trailing-lightoj1282（快速幂 + 对数运算）","uri":"/posts/lightoj1282/"},{"categories":["ACM"],"content":"0.9 A. The Rank 题目大意： 给出 n 个学生的成绩，Thomas Smith 的成绩是第一行，然后要按总成绩进行排序，总分相同的按编号从小到大排； 开始看还以为要写 sort 的 cmp 函数进行多条件排序，敲完才发现其实只要按总分就可以了，因为托马斯的 id 是一，必然会排在前面。 #include\u003cbits/stdc++.h\u003e using namespace std; int a[4],sum[1005]; int main(){ int n,s,f1; cin\u003e\u003en; for(int j=1;j\u003c=n;j++){ s=0; for(int i=0;i\u003c4;i++){ cin\u003e\u003ea[i]; s+=a[i]; } sum[j]=s; if(j==1) f1=s; } sort(sum+1,sum+n+1,greater\u003cint\u003e()); for(int i=1;i\u003c=n;i++) if(sum[i]==f1){ cout\u003c\u003ci\u003c\u003cendl; break; } return 0; } 0.10 B. The Bits 题目大意： 先给出二进制数的长度，然后输入两个二进制数 a,b，问交换 a 中的某些位数的数，使得 a|b（按位或）的结果不同，求有多少种不同的或值。 a,b 上下对应的情况：a/b 个数 1/0 m 0/0 n 1/1 x 0/1 y 用组合数学的思想来想： 只要看 b 为 0 的位就行了，如果 0/0,a 只能换 1 的位置，为了避免重复，所以这里总数为n*x, 再考虑 1/0 的情况，只能和 0 的位置换，这是后可以把 0/0 没算的都算上，所以总数m*(n+y) 所以最后总数为sum=n*x+m*(n+y) #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long n,m,x,y,t; n=m=x=y=0; char a[100005],b[100005]; cin\u003e\u003et; cin\u003e\u003ea\u003e\u003eb; for(int i=0;i\u003ct;i++){ int p=a[i]-'0'; int q=b[i]-'0'; if(p==0\u0026\u0026q==0) n++; if(p==1\u0026\u0026q==0) m++; if(p==1\u0026\u0026q==1) x++; if(p==0\u0026\u0026q==1) y++; } long long sum=n*x+m*(y+n); cout\u003c\u003csum\u003c\u003cendl; return 0; } ","date":"2018-08-09","objectID":"/posts/cfcontest1017/:0:0","tags":["ACM","Codeforces","组合数学","C++"],"title":"Codeforces Round 502(Div.1 + Div.2)","uri":"/posts/cfcontest1017/"},{"categories":["ACM"],"content":"1 欧拉函数是求小于 x 并且和 x互质 的数的个数 通式：φ(x)=x(1-1/p1)(1-1/p2)(1-1/p3)(1-1/p4)…..(1-1/pn) 其中 p1, p2……pn 为 x 的所有质因数，x 是不为 0 的整数 φ(1)=1（唯一和 1 互质的数就是 1 本身）【注意：每种质因数只一个。比如 12=223】 2 定理 若 n 是素数 p 的 k 次幂，φ(n)=pk-p(k-1)=(p-1)p^(k-1)，因为除了 p 的倍数外，其他数都跟 n 互质 欧拉函数是积性函数——若 m,n 互质，φ(mn)=φ(m)φ(n) 3 特殊性质 当 n 为奇数时，φ(2n)=φ(n) p 是素数，φ(p) = p - 1，φ(p) 称为 p 的欧拉值 若 a 为素数，b mod a=0,φ(a*b)=φ(b)*a 4 模板 //直接法 int Euler(int n){ int res = n,i; //由于任何一个合数都至少有一个不大于根号 n 的素因子，所以只要遍历到根号 n 即可 for(i=2;i * i \u003c= n;i++) if(n%i == 0){ //第一次找到的必为素因子 n /=i ; res = res - res/i; //x(1-1/p1) while(n % i ==0) n/=i; //将该素因子的倍数也全部筛掉 } if (n \u003e 1) res = res - res/n; return res; } 以上转载注明 //素数筛选法，先素数筛选，再求欧拉 /* 特性 : 1. 若 a 为质数，phi[a]=a-1; 2. 若 a 为质数，b mod a=0,phi[a*b]=phi[b]*a 3. 若 a,b 互质，phi[a*b]=phi[a]*phi[b](当 a 为质数时，if b mod a!=0 ,phi[a*b]=phi[a]*phi[b]) */ int m[n],phi[n],p[n],nump; //m[i] 标记 i 是否为素数，0 为素数，1 不为素数；p 是存放素数的数组；nump 是当前素数个数；phi[i] 为欧拉函数 int make() { phi[1]=1; for (int i=2;i\u003c=n;i++) { if (!m[i])//i 为素数，m[] 初始化为 0 { p[++nump]=i;//将 i 加入素数数组 p 中 phi[i]=i-1;//因为 i 是素数，由特性得知 } for (int j=1;j\u003c=nump\u0026\u0026p[j]*i\u003cn;j++) //用当前已的到的素数数组 p 筛，筛去 p[j]*i { m[p[j]*i]=1;//可以确定 i*p[j] 不是素数 if (i%p[j]==0) //看 p[j] 是否是 i 的约数，因为素数 p[j], 等于判断 i 和 p[j] 是否互质 { phi[p[j]*i]=phi[i]*p[j]; //特性 2 break; } else phi[p[j]*i]=phi[i]*(p[j]-1); //互质，特性 3,p[j]-1 就是 phi[p[j]] } } } 附素数打表 int p[N]={1,1,0}; void prime(){ for(int i=2;i\u003cN;i++) if(!p[i]){ for(int j=2*i;j\u003c=N;j+=i)//筛掉 i 的倍数 p[j]=1; } } 5 例题 Bi-shoe and Phi-shoe LightOJ - 1370 题意： 给一些数 Ai（第 i 个数），Ai 这些数代表的是某个数欧拉函数的值，我们要求出数 Ni 的欧拉函数值不小于 Ai。而我们要求的就是这些 Ni 这些数字的和 sum，而且我们想要 sum 最小，求出 sum 最小多少。 解题思路： 要求和最小，我们可以让每个数都尽量小，那么我们最后得到的肯定就是一个最小值。 给定一个数的欧拉函数值 ψ(N)，我们怎么样才能求得最小的 N? 我们知道，一个素数 P 的欧拉函数值 ψ(P)=P-1。所以如果我们知道 ψ(N)，那么最小的 N 就是最接近 ψ(N)，并且大于 ψ(N) 的素数。我们把所有素数打表之后再判断就可以了。 这个 lightoj 有毒，什么头文件都不支持，卡了我好久。 #include\u003cstdio.h\u003e #define N 1000005 #define ll long long int m[N]={1,1,0}; int p[100000],cnt=0; int max(int x,int y){ return x\u003ey?x:y; } void prime(){ for(int i=2;i\u003cN;i++) if(!m[i]){ for(int j=2*i;j\u003c=N;j+=i) m[j]=1; p[cnt++]=i; } } int binary_search(int x){//二分查找 int l=0,r=cnt; while(l\u003c=r){ int mid=(l+r)/2; if(p[mid]\u003ex) r=mid-1; else l=mid+1; } for(int i=max(r,0);;i++) if(p[i]\u003ex) return p[i]; } int main(){ prime(); int T,n,cas=1,temp; scanf(\"%d\",\u0026T); while(T--){ scanf(\"%d\",\u0026n); ll sum=0; for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026temp); sum+=binary_search(temp); } printf(\"Case %d: %lld Xukha\\n\",cas++,sum); } return 0; } ","date":"2018-08-08","objectID":"/posts/euler/:0:0","tags":["数学","数论","euler","C"],"title":"欧拉函数","uri":"/posts/euler/"},{"categories":["ACM"],"content":"题目链接 大意： 要从城市 1 到城市 N 运送货物，有 M 条道路，每条道路都有它的最大载重量，问从城市 1 到城市 N 运送最多的重量是多少。 其实题意很简单，就是找一条 1–\u003eN 的路径，在不超过每条路径的最大载重量的情况下，使得运送的货物最多。一条路径上的最大载重量为这个路径上权值最小的边； //dijkstra #include\u003ciostream\u003e #include\u003ccstdio\u003e #define min(a,b) (a\u003cb?a:b) using namespace std; int n,m,v[1010],maps[1010][1010],d[1010];//此时 d 表示 1 到每一个点的能通过的最大的重量 int dijkstra(){ int i,j,k; for(i=1;i\u003c=n;i++){ v[i]=0; d[i]=maps[1][i];//这个时候 d 不代表最短路径，而是从 1 到 n 的最大承载量 } for(i=1;i\u003c=n;i++){//n 个点 int f=-1; for(j=1;j\u003c=n;j++) if(!v[j]\u0026\u0026d[j]\u003ef){ f=d[j]; k=j; } v[k]=1; for(j=1;j\u003c=n;j++) if(!v[j]\u0026\u0026d[j]\u003cmin(d[k],maps[k][j]))//更新说明见图解 d[j]=min(d[k],maps[k][j]); } return d[n]; } int main(){ int ans=1; int a,b,w; int T; scanf(\"%d\",\u0026T); while(T--){ for(int i=0;i\u003c=n;i++) for(int j=0;j\u003c=n;j++) maps[i][j]=0; scanf(\"%d%d\",\u0026n,\u0026m); for(int i=1;i\u003c=m;i++) { scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026w); maps[a][b]=maps[b][a]=w; } printf(\"Scenario #%d:\\n%d\\n\\n\",ans++,dijkstra()); } return 0; } ","date":"2018-08-06","objectID":"/posts/poj1797/:0:0","tags":["ACM","POJ","最短路","C++"],"title":"Heavy Transportation-poj1797(dijkstra 或最大生成树）","uri":"/posts/poj1797/"},{"categories":["JavaScript"],"content":"看到知乎，百度的页面 F12 检查后都会有一些有趣的招聘信息。于是乎我也想给我的博客加一个。 我主要用到的工具： console.log() Notepad++ 在线图片转文字工具 1 用法 用 js 在\u003cbody\u003e\u003c/body\u003e使用 console.log() 就行了，hexo 的主题文件在_layout.swig里，所以我们打开该文件，在该位置，添加 js 就行了； 2 图案 我用的我自己的一张照片（电脑上照片就那么几张。)，然后用 在线图片转文字工具 转字符， 选择文件，设置大小，然后生成， 生成后，复制 TXT 文件（下面那个框，上面的是 HTML 代码） 粘贴到 Notepad++ 里面，然后按图操作； Ctrl+H 替换 最后就变成一个字符串了。 3 效果图 线上 demo, 按 F12 找到 console 4 我的 txt \\n` @@#``@@@@@@@@@@@@@@@@@@##,` \\n` @@#`;@@@@@@@@@@@@@@@@@@@':' \\n` @@#`@@@@@@@@@@@@@@@@@@@#+#;` \\n` @@#`@@@@@@@@@@@@@@@@@@###@'. \\n` @@+.@@@@@@@@@@@@@@@@@@@@@##, \\n` @@#,@@@@@@@@@@@@@@@@@@@@@@#, \\n` #@#:@@@@@@@@@@@@@@@@@@@@@@@, \\n` #@#'@@@@@@@@@@@@@@@@@@@@@@@. \\n` +@#;@@@@@@@@@@@@@@@@@@@@@@# \\n` `;: ;@#'@@@@@@@@@@@@@@@@@@+'+@' \\n` `,,;';'+';'@@+:@@@@@@@@@@@@##@#',.:#; \\n,, `` ``..,:;@@#'@@@@@@@@#####@@@@#:`:. \\n` `````:++@@@@@@@@@@@@@###@@@@#+,.. \\n ``````.#@@@@@@@@@@@@@@#@@@#++#'`` \\n` ```.,,:,.`:@@@@@@@@@@@@@###@@@##'.` \\n``..`````..,::;+@@@@@@@@@@@@#+`::+##'`. \\n` ````.```,@@@@@@@@@@@##;``.,';` ` \\n``.;@@@@@@@@@@@@@@@@@@@@@@###;``..`````` \\n#@@@@@@@@@@@@@@@@@@@@@@@@##@#;``,``,.`` \\n@@@@@@@@@@@@@@@@@@@.`````..``.. +` `:` \\n@+''++#####@@#`.@@@``````` ` `,``` `` \\n';;;;'+##+'+.`;+@@@,..```` `` :,. \\n;::,,:;+#++``,,#@@@'..``````` ,`.`` \\n;,,,,...'#.,,..#@@@#,,.`````` .```` \\n:,,,,....`,::;''+#@#;,..`````````.`` \\n:,,,.....'##++''';:+':,.`..,,...` \\n:,,,...#####+'+#@@@'.';+:. ` `` \\n;,,.`'####'#,`.`+@@@+'``` `.` \\n;,.`#@@@#+:'+++##+@##@,,,,` \\n',.#@@###'''';:,.```,+#. \\n+,#@@@####;,,..``````````````` `.:,::\\n+@@@@###+;,,..`````````````````` `.,\\n#@@@##+',,,........`````````````` \\n@@@@#+:,,,,`........`````````` \\n@@@#+:,,,,.`````.....`````````` `` \\n@@##':,......`````....``` ````` ```\\n@@@#':,....,..``````..```` ``` ```\\n@@@#',....,,,..``````````` ``` ..\\n@@@#,.....,,,,.`` ```````` `````` \\n@@@+....,,,,,..````````````` `````````` \\n@@@:....,,,,.LiRuihao```````` ```````````` \\n#@@,....,,,,.Always Be Yourself !````````````\\n,##,,...,::,.````````````..`````` `......``\\n,'#,,..,,:::.`````````........`````` `.,,..\\n\\n 你好！\\n 欢迎进入什么都不会的李瑞豪的个人网站！\\nhttps://lruihao.cn\\nhttps://www.lruihao.cn\\nhttps://lruihao.github.io\\nhttps://liruihao.coding.me\\n\\n\\n\\n 其他个人网站，个人博客也是可以的。 ","date":"2018-08-04","objectID":"/posts/console-log/:0:0","tags":["Hexo","JavaScript"],"title":"hexo 博客自定义 console log","uri":"/posts/console-log/"},{"categories":["ACM"],"content":"题目链接 题目大意： 说的是，一只奶牛位于 N 号节点，输入 N 个节点和 T 对双向的边，求出由 N 到 1 的最短的距离，其实就是问的单源最短路问题。 两个点可能有多条路，选择最短的。 #include\u003cstdio.h\u003e #include\u003cstring.h\u003e #include\u003calgorithm\u003e using namespace std; const int INF=99999999; //设为无穷大 int maps[1005][1005],v[1005],d[1005]; //v 表示是否已经过遍历 d 表示从源到点当前最短路 int n; void Dijkstra(int s,int t) { int i,j,k,mini; for(i=1;i\u003c=n;i++) d[i]=INF; //除源点设为 0 距离外 其他先设为无穷大 d[s]=0; for(i=1;i\u003c=n;i++) //n 点循环 n 次 , 找出 n 个 k, 找 n 个点 { mini=INF; k=-1; for(j=1;j\u003c=n;j++) //在所有未标记点中 选 d 值最小的点 if(!v[j] \u0026\u0026 d[j]\u003cmini) mini=d[k=j]; v[k]=1; //标记节点 if(k==t) { printf(\"%d\\n\",d[t]); return; } for(j=1;j\u003c=n;j++) if(!v[j] \u0026\u0026 (d[k]+maps[k][j])\u003cd[j]) //表示从 k 出发的点，对于所有边，更新相连点 d[j]=d[k]+maps[k][j]; } } int main() { int T,i,j,x,y,D; while(scanf(\"%d %d\",\u0026T,\u0026n)!=EOF) { memset(v,0,sizeof(v)); //清除标记 for(i=1;i\u003c=n;i++) for(j=1;j\u003c=n;j++) maps[i][j]=INF; for(i=1;i\u003c=T;i++){ scanf(\"%d%d%d\",\u0026x,\u0026y,\u0026D); if(maps[x][y]\u003eD) //可能有多条路，只记录最短的 maps[x][y]=D,maps[y][x]=D; } Dijkstra(1,n); } return 0; } ","date":"2018-08-03","objectID":"/posts/poj2387/:0:0","tags":["ACM","最短路","C++","C"],"title":"Til the Cows Come Home-poj2387(dijkstra 判断重边）","uri":"/posts/poj2387/"},{"categories":["ACM"],"content":" 1 Dijkstra 算法 1.1 1. 定义概览 Dijkstra（迪杰斯特拉）算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra 算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。 问题描述：在无向图 G=(V,E) 中，假设每条边 E[i] 的长度为 w[i]，找到由顶点 V0 到其余各点的最短路径。（单源最短路径） 1.2 2. 算法描述 1.2.1 算法思想 设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组，第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了），第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。此外，每个顶点对应一个距离，S 中的顶点的距离就是从 v 到此顶点的最短路径长度，U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。 1.2.2 算法步骤 a. 初始时，S 只包含源点，即 S ＝{v}，v 的距离为 0。U 包含除 v 外的其他顶点，即：U={其余顶点}，若 v 与 U 中顶点 u 有边，则\u003cu,v\u003e正常有权值，若 u 不是 v 的出边邻接点，则\u003cu,v\u003e权值为 ∞。 b. 从 U 中选取一个距离 v 最小的顶点 k，把 k，加入 S 中（该选定的距离就是 v 到 k 的最短路径长度）。 c. 以 k 为新考虑的中间点，修改 U 中各顶点的距离；若从源点 v 到顶点 u 的距离（经过顶点 k）比原来距离（不经过顶点 k）短，则修改顶点 u 的距离值，修改后的距离值的顶点 k 的距离加上边上的权。 d. 重复步骤 b 和 c 直到所有顶点都包含在 S 中。 执行动画过程如下图 2 spfa 算法 spfa 是一种求单源最短路的算法 算法中需要用到的主要变量 int n; //表示 n 个点，从 1 到 n 标号 int s,t; //s 为源点，t 为终点 int d[N]; //d[i] 表示源点 s 到点 i 的最短路 int p[N]; //记录路径（或者说记录前驱） queue q; //一个队列，用 STL 实现，当然可有手打队列，无所谓 bool vis[N]; //vis[i]=1 表示点 i 在队列中 vis[i]=0 表示不在队列中 3 几乎所有的最短路算法其步骤都可以分为两步 初始化 松弛操作 3.1 初始化 d 数组全部赋值为 INF（无穷大）；p 数组全部赋值为 s（即源点），或者赋值为 -1，表示还没有知道前驱，然后 d[s]=0; 表示源点不用求最短路径，或者说最短路就是 0。将源点入队； （另外记住在整个算法中有顶点入队了要记得标记 vis 数组，有顶点出队了记得消除那个标记） 3.2 队列 + 松弛操作 读取队头顶点 u，并将队头顶点 u 出队（记得消除标记）；将与点 u 相连的所有点 v 进行松弛操作，如果能更新估计值（即令 d[v] 变小），那么就更新，另外，如果点 v 没有在队列中，那么要将点 v 入队（记得标记），如果已经在队列中了，那么就不用入队 以此循环，直到队空为止就完成了单源最短路的求解 4 SPFA 可以处理负权边 定理：只要最短路径存在，上述 SPFA 算法必定能求出最小值。 证明： 每次将点放入队尾，都是经过松弛操作达到的。换言之，每次的优化将会有某个点 v 的最短路径估计值 d[v] 变小。所以算法的执行会使 d 越来越小。由于我们假定图中不存在负权回路，所以每个结点都有最短路径值。因此，算法不会无限执行下去，随着 d 值的逐渐变小，直到到达最短路径值时，算法结束，这时的最短路径估计值就是对应结点的最短路径值。（证毕） 期望的时间复杂度 O(ke)，其中 k 为所有顶点进队的平均次数，可以证明 k 一般小于等于 2。 判断有无负环： 如果某个点进入队列的次数超过 N 次则存在负环（SPFA 无法处理带负环的图） 代码 ","date":"2018-08-03","objectID":"/posts/zuiduanlu/:0:0","tags":["最短路","ACM"],"title":"最短路入门","uri":"/posts/zuiduanlu/"},{"categories":["ACM"],"content":"题目链接 密码：l9sn 终于不爆零了，但是还是 wa 了无数次，有时候代码感觉都差不多 1 G-max /* //wa #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,c;//好像不会爆 int 吧，头晕 cin\u003e\u003ec\u003e\u003en; int t=n/c; if(t\u003c1) cout\u003c\u003c\"-1\\n\";// else if(t==1) cout\u003c\u003cc*c\u003c\u003cendl; else cout\u003c\u003c(t*c)*((t-1)*c)\u003c\u003cendl; return 0; }*/ //AC #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ long long n,c; cin\u003e\u003ec\u003e\u003en; long long t=n/c; if(t\u003c1) cout\u003c\u003c-1\u003c\u003cendl; else if(t==1) cout\u003c\u003cc*c\u003c\u003cendl; else cout\u003c\u003c(t*c)*((t-1)*c)\u003c\u003cendl; return 0; } 2 J-plan /*枚举所有情况 全买双人 n%2 0 or 1//剩 1 个人的时候，可以多开一间房或者退一间 2 人房开一间 3 人房 全买 3 人 n%3 0 or 1 or 2 再比较大小 */ #include\u003cbits/stdc++.h\u003e #define INF 1\u003c\u003c20 using namespace std; typedef long long ll; ll min(ll a,ll b){ return a\u003cb?a:b; } int main(){ ll n,p2,p3,sum,sum1; while(cin\u003e\u003en\u003e\u003ep2\u003e\u003ep3){ if(n%2==0) sum=p2*(n/2); else sum=p2*(n/2)+min(min(p2,p3),p3-p2);//退二买三； if(n%3==0) sum1=p3*(n/3); else if(n%3==1) sum1=p3*(n/3)+min(min(p2,p3),2*p2-p3);//退 3 买 2*2 else if(n%3==2) sum1=p3*(n/3)+min(p3,p2);//退 3 买 3*2 cout\u003c\u003cmin(sum1,sum)\u003c\u003cendl; } return 0; } ","date":"2018-08-02","objectID":"/posts/nowcodersummer-5th/:0:0","tags":["Nowcoder","ACM","C++"],"title":"牛客暑假多校第五场","uri":"/posts/nowcodersummer-5th/"},{"categories":["ACM"],"content":"题目链接 思路参考 1,思路参考 2（没看懂） 先占坑，有时间再理理思路。 同一棵树中 d=1, 即 x 和 y 是同类，则需满足 r[x]==r[y] d=2,x 应该吃了 y, 也就是 (r[x]+1)%3 == r[y] 不同树合并且更新关系 (x 树做主根) ’ 如果 x 和 y 为关系 r1, y 和 z 为关系 r2，那么 x 和 z 的关系就是（r1+r2）%3 如果 d1 则 x 和 y 是同类，那么 y 对 x 的关系是 0, 如果 d2 , 则 x 吃了 y, 那么 y 对 x 的关系是 1, x 对 y 的关系是 2。综上所述 , 无论 d 为 1 或者是为 2, y 对 x 的关系都是 d-1。 fy 对 y 的关系为 3-r[y] （有点互补的感觉，注意这里是不同类喔） y 对 x 的关系为 d-1, x 对 fx 的关系为 r[x] 所以 fy 对 fx 的关系是（3-r[y] + d-1 + r[x]）%3。可以借助向量图理解 fy-\u003ey-\u003ex-\u003efx #include\u003ccstdio\u003e const int maxn = 50000+10; int p[maxn]; //存父节点 int r[maxn];//存与父节点的关系 0 同一类，1 被父节点吃，2 吃父节点 void set(int n) //初始化 { for(int x = 1; x \u003c= n; x++) { p[x] = x; //开始自己是自己的父亲节点 r[x] = 0;//开始自己就是自己的父亲，每一个点均独立 } } int find(int x) //找父亲节点 { if(x == p[x]) return x; int t = p[x]; p[x] = find(p[x]); r[x] = (r[x]+r[t])%3; //回溯由子节点与父节点的关系和父节点与根节点的关系找子节点与根节点的关系 return p[x]; } void Union(int x, int y, int d) { int fx = find(x); int fy = find(y); p[fy] = fx; //合并树 注意：被 x 吃，所以以 x 的根为父 r[fy] = (r[x]-r[y]+3+(d-1))%3; //对应更新与父节点的关系 } int main() { int n, m; scanf(\"%d%d\", \u0026n, \u0026m); set(n); int ans = 0; int d, x, y; while(m--) { scanf(\"%d%d%d\", \u0026d, \u0026x, \u0026y); if(x \u003e n || y \u003e n || (d == 2 \u0026\u0026 x == y)) ans++; //如果节点编号大于最大编号，或者自己吃自己，说谎 else if(find(x) == find(y)) //如果原来有关系，也就是在同一棵树中，那么直接判断是否说谎 { if(d == 1 \u0026\u0026 r[x] != r[y]) ans++; //如果 x 和 y 不属于同一类 if(d == 2 \u0026\u0026 (r[x]+1)%3 != r[y]) ans++; // 如果 x 没有吃 y（注意要对应 Uinon(x, y) 的情况，否则一路 WA 到死啊！！！) } else Union(x, y, d); //如果开始没有关系，则建立关系 } printf(\"%d\\n\", ans); return 0; } ","date":"2018-08-02","objectID":"/posts/poj1182/:0:0","tags":["ACM","并查集","POJ","C++","C"],"title":"食物链-poj1182（带权并查集经典模板）","uri":"/posts/poj1182/"},{"categories":["ACM"],"content":"1 题目链接：小希的迷宫 2 并查集 无回路 单连通 并查集做，首先想到的是判断两个点是否连通，不连通就合并，已连通的话说明会形成回路，则可以判定 No，交了一发错了。 想了一下没有考虑到多个连通域的情况，该题必须只有一个连通域 3 树的性质 既然单连通无回路，则这肯定是一棵树；那么 edge=v-1; 最后注意空树的情况，至于自环我这里 No 也过了，没有去验证自环 Yes 的情况了 //并查集 #include\u003cbits/stdc++.h\u003e using namespace std; int pre[100001]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int a,int b){ int x=find(a),y=find(b); if(x!=y) pre[y]=x; } int main(){ int a,b,flag,i,sum; while(1) { flag = 0; while(~scanf(\"%d%d\",\u0026a,\u0026b) \u0026\u0026 a!=0 \u0026\u0026 b!=0){ if(a==-1 \u0026\u0026 b==-1) return 0; if(pre[a]==0)pre[a]=a; if(pre[b]==0)pre[b]=b; if(find(a)==find(b))flag = 1; else if(flag!=1) join(a,b); } for(sum = 0,i=1;i\u003c100001;i++){ if(pre[i]==i)sum++; pre[i] = 0; } if(sum\u003e1 || flag == 1) printf(\"No\\n\"); else printf(\"Yes\\n\"); } } //1 2 3 4 0 0 No 没有连通 //0 0 Yes //1 1 0 0 No（该代码） //树性质 #include \u003cstdio.h\u003e bool s[100001]; int main() { int a,b,i,len,num,v; for(i=0;i\u003c100001;++i) s[i]=false; len=0,num=0,v=0; while(1) { scanf(\"%d%d\",\u0026a,\u0026b); if(a==-1\u0026\u0026b==-1) break; if(a==0\u0026\u0026b==0) { if(v==0) { printf(\"Yes\\n\"); continue; } if(num==len-1) //划重点！！ printf(\"Yes\\n\"); else printf(\"No\\n\"); num=len=v=0; for(i=0;i\u003c100001;++i) s[i]=false; continue; } v=1; if(s[a]==false) len++;//点数 if(s[b]==false) len++; s[a]=s[b]=true; num++;//边数 } return 0; ","date":"2018-08-01","objectID":"/posts/hdu1272/:0:0","tags":["ACM","并查集","HDU","C++","C"],"title":"小希的迷宫-HDU-1272（并查集 or 树性质）","uri":"/posts/hdu1272/"},{"categories":["ACM"],"content":"题目链接：How Many Answers Are Wrong 思路参考：本题直接参考,图文解释 #include\u003cbits/stdc++.h\u003e using namespace std; typedef long long LL; int pre[200010],ranks[200010]; int find(int root){ if(pre[root] != root) { int f = pre[root]; pre[root] = find(pre[root]);//递归路径压缩 ranks[root] += ranks[f]; /*精髓假如一开始没关系，那么用 rank 数组来表示 a，b 各自到各自祖先的距离。 那么在把 a 的祖先给 b 的祖先当父亲之后，那么 b 到祖先的距离也就是 rank[b] 就要再加上 b 原本的祖先到 a 的祖先的距离，更新一下， 其中 find 函数（找根节点的函数）里 rank[x]+=rank[pre[x]]（这里 pre 数组存的是对应数的父节点）*/ } return pre[root]; } int main(){ int n,m; while(~scanf(\"%d%d\",\u0026n,\u0026m)){ int ans=0; for(int i=1; i\u003c=n; i++) pre[i]=i; memset(ranks,0,sizeof(ranks)); while(m--){ int a,b,c; scanf(\"%d%d%d\",\u0026a,\u0026b,\u0026c); a--;//[a,b]~~(a--,b] int fa=find(a); int fb=find(b); if(fa!=fb){ pre[fb]=fa;//注意合并顺序，反过来下面的也要改 ranks[fb]=ranks[a]-ranks[b]+c;//更新距离 } else { if(ranks[b]-ranks[a]!=c) ans++; } } printf(\"%d\\n\",ans); } return 0; } ","date":"2018-08-01","objectID":"/posts/hdu3038/:0:0","tags":["并查集","ACM","HDU","C++"],"title":"How Many Answers Are Wrong-hdu3038（带权并查集）","uri":"/posts/hdu3038/"},{"categories":["ACM"],"content":"题目链接：Bear and Finding Criminals 大致题意就是小熊警察住在某个城市，他要抓各个城市的罪犯，现在用一个 BCD 可以知道那个城市里一定有罪犯。 一定能确定该城市有小偷的几种情况： 警察所住城市有罪犯，则一定能检测到 警察所住城市的左边和右边位置若都不为 0，则说明两座城市都有罪犯（只有一边为 1 是不能确定到底哪个城市有罪犯的） 警察所在城市的一边检测到有罪犯，但在另一边已经没有城市了，则说明该城市一定有罪犯 #include\u003cbits/stdc++.h\u003e using namespace std; int t[107]; int main() { int n, a; while(cin\u003e\u003en\u003e\u003ea){ int sum = 0; for(int i =1; i \u003c= n; i++) cin \u003e\u003e t[i]; if(t[a]) sum++;//小熊所在城市有罪犯 for(int i = 1; i \u003c= n; i++){ if(a-i \u003e 0\u0026\u0026a+i \u003c= n) { if(t[a-i] == 1\u0026\u0026t[a+i] == 1) sum+=2; } else if(a-i \u003c= 0\u0026\u0026a+i \u003c= n){//警察在第一个点 if(t[a+i]) sum++; } else if(a-i \u003e 0\u0026\u0026a+i \u003e n){ if(t[a-i]) sum++; } } cout \u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-31","objectID":"/posts/codeforces680b/:0:0","tags":["Codeforces","ACM","C++"],"title":"Bear and Finding Criminals-Codeforces680B","uri":"/posts/codeforces680b/"},{"categories":["ACM"],"content":"题目链接：Bear and Five Cards 大致题意就是小熊有 5 张卡片，每张卡片有对应的分数，他可以选择丢弃 2 张相同的或者 3 张相同的卡片，没有相同的就无法丢弃，问小熊剩下的分数最少是多少。 没有想得那么复杂，由于分数最大才 100，所以直接暴力就好了。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int a[5],b[107],i,j,sum=0,sum1=0; for(i=0;i\u003c5;i++){ cin\u003e\u003ea[i]; sum+=a[i]; } sort(a,a+5); memset(b,0,sizeof(b)); for(i=0;i\u003c5;i++) b[a[i]]++; for(i=0;i\u003c107;i++){ if(b[i]==2) sum1=max(2*i,sum1); if(b[i]\u003e=3) {sum1=max(3*i,sum1);/*cout\u003c\u003c3*i\u003c\u003c\" \"\u003c\u003csum1\u003c\u003cendl;*/} } cout\u003c\u003csum-sum1\u003c\u003cendl; return 0; } ","date":"2018-07-31","objectID":"/posts/codeforces680a/:0:0","tags":["Codeforces","ACM","C++"],"title":"Bear and Five Cards-Codeforces680A","uri":"/posts/codeforces680a/"},{"categories":["ACM"],"content":"并查集求连通域数目，初始化 sum=n； 题目链接： how many tables #include\u003cbits/stdc++.h\u003e using namespace std; int pre[1005]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } int main(){ int n,m,t,sum,root1,root2; cin\u003e\u003et; while(t--){ cin\u003e\u003en\u003e\u003em; sum=n; for(int i=1;i\u003c=n;i++) pre[i]=i; for(int i=0;i\u003cm;i++){ cin\u003e\u003eroot1\u003e\u003eroot2; int xx=find(root1); int yy=find(root2); if(xx!=yy){ pre[xx]=yy; sum--; } } cout\u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-31","objectID":"/posts/how-tables/:0:0","tags":["并查集","HDU","C++","ACM"],"title":"how many tables-HDU-1213（并查集求连通域数目）","uri":"/posts/how-tables/"},{"categories":["ACM"],"content":"1 题目链接：The-suspects 2 翻译 警察抓贩毒集团。有不同类型的犯罪集团，人员可能重复，集团内的人会相互接触。现在警察在其中一人（0 号）身上搜出毒品，认为与这个人直接接触或通过其他人有间接接触的人都是嫌疑犯。问包括 0 号犯人共有多少嫌疑犯？ 2.1 Input 多样例输入。 每个测试用例以两个整数 n 和 m 开头，其中 n 为人数，m 为犯罪集团数。你可以假定 0 \u003c n \u003c= 30000 和 0 \u003c= m \u003c= 500。在所有的情况下，每个人都有自己独特的整数编号 0 到 n−1, 且 0 号是公认的嫌疑犯。 接下来 m 行输入，每个犯罪集团一行。每一行从一个整数 k 开始，它本身表示集团内成员的数量。按照成员的数量，在这个组中有 k 个整数表示人员。一行中的所有整数都被至少一个空格隔开。 n = 0 且 m = 0 时输入结束。 2.2 Output 对于每个样例，输出嫌疑犯人数。 2.3 Sample Input 100 4 2 1 2 5 10 13 11 12 14 2 0 1 2 99 2 200 2 1 5 5 1 2 3 4 5 1 0 0 0 2.4 Sample Output 4 1 这题也很好理解，AC 代码如下： #include\u003ccstdio\u003e int pre[30010],x[30010]; int find(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int x,int y){ int fx=find(x),fy=find(y); if(fx!=fy) pre[fy]=fx; } int main(){ int n,m,i,k,sum; while(scanf(\"%d%d\",\u0026n,\u0026m),n||m){ sum=0; for(i=0;i\u003cn;i++) pre[i]=i; while(m--){ scanf(\"%d\",\u0026k); for(i=0;i\u003ck;i++) scanf(\"%d\",\u0026x[i]); for(i=1;i\u003ck;i++) join(x[i-1],x[i]); } for(i=0;i\u003cn;i++) if(find(0)==find(i)) sum++;//再次查找并压缩路径，注不用 pre[i] printf(\"%d\\n\",sum); } return 0; } ","date":"2018-07-31","objectID":"/posts/poj-1611/:0:0","tags":["并查集","POJ","ACM","C","C++"],"title":"The-suspects-POJ-1611（并查集）","uri":"/posts/poj-1611/"},{"categories":["ACM"],"content":"1 题目链接：wireless network 2 翻译 南亚发生了一次地震。ACM (Asia Cooperated Medical 亚洲联合医疗队）已经为膝上型电脑搭建了一个无线网络，但受到了一次不可预知的余震攻击，因此网络中的所有电脑都被破坏了。电脑被逐台修复，网络逐步恢复了工作。由于受到硬件的约束，每台电脑只能与距离它不超过 d 米的其它电脑直接通信。但每台电脑可被看作其它两台电脑的通信中转点，也就是说，如果电脑 A 和电脑 B 可以直接通信，或存在一台电脑 C 既可与 A 也可与 B 通信，那么电脑 A 和电脑 B 之间就能够通信。 在处理网络修复的过程中，工作人员们在任何一个时刻，可以执行两种操作：维修一台电脑，或测试两台电脑是否能够通信。请您找出全部的测试操作。 2.1 输入 第一行包含了两个整数 N 和 d (1 \u003c= N \u003c= 1001, 0 \u003c= d \u003c= 20000)。此处 N 是电脑的数目，编号从 1 到 N；同时，D 是两台电脑之间能够直接通信的最大距离。接下来的 N 行，每行包含两个整数 xi, yi (0 \u003c= xi, yi \u003c= 10000)，表示 N 台电脑的坐标。从第 (N+1) 行到输入结束，是逐一执行的操作，每行包含一个操作，格式是以下两者之一： “O p” (1 \u003c= p \u003c= N)，表示维护电脑 p。。 “S p q” (1 \u003c= p, q \u003c= N)，表示测试电脑 p 和 q 是否能够通信。 输入不超过 300000 行。 2.2 输出 对于每个测试操作，如果两台电脑能够通信，则打印 “SUCCESS”；否则，打印 “FAIL”。 2.3 示例输入 4 1 0 1 0 2 0 3 0 4 O 1 O 2 O 4 S 1 4 O 3 S 1 4 2.4 示例输出 FAIL SUCCESS 2.5 AC 代码 #include \"iostream\" #include \"cstring\" using namespace std; int pre[1005]; int x[1005],y[1005],use[1005]; int findd(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } void join(int x,int y){ int fx=findd(x),fy=findd(y); if(fx!=fy) pre[fx]=fy; } int dis(int i,int num,int d){ d=d*d; int xx=x[i]-x[num]; int yy=y[i]-y[num]; if((xx*xx+yy*yy)\u003c=d) return 1; return 0; } int main(){ int n,d; char s; memset(use,0,sizeof(use)); cin\u003e\u003en\u003e\u003ed; for(int i=0;i\u003c=n;i++) pre[i]=i; for(int i=1;i\u003c=n;i++) cin\u003e\u003ex[i]\u003e\u003ey[i]; while(cin\u003e\u003es){ if(s=='O'){ int num; cin\u003e\u003enum; use[num]=1; findd(num);//路径压缩 for(int i=1;i\u003c=n;i++) if(i!=num\u0026\u0026use[i]==1\u0026\u0026dis(i,num,d))//修好了，且可以被合并（自己除外） join(i,num); } else if(s=='S'){ int q,p; cin\u003e\u003eq\u003e\u003ep; if(findd(q)==findd(p)) cout\u003c\u003c\"SUCCESS\"\u003c\u003cendl; else cout\u003c\u003c\"FAIL\"\u003c\u003cendl; } } return 0; } ","date":"2018-07-31","objectID":"/posts/poj-2236/:0:0","tags":["并查集","ACM","POJ","C++","C"],"title":"wireless network-POJ-2236（并查集）","uri":"/posts/poj-2236/"},{"categories":["ACM"],"content":"Codeforces Round #500 (Div. 2) 题目链接：Piles With Stones 大致题意就是有 n 堆石头，第一天每堆有一定数目的石头，第二天石头可能被小朋友移动或者带走，求满足题意的两天的石碓； 所以第二天的石头总数不会大于第一天的，所以是 sum1-sum2\u003e=0 即可。 //又只打了一道题，扣了 80 多分。 #include\u003cbits/stdc++.h\u003e using namespace std; int x[55],y[55],n,s1=0,s2=0; int main(){ scanf(\"%d\",\u0026n); for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026x[i]); s1+=x[i]; } for(int i=0;i\u003cn;i++){ scanf(\"%d\",\u0026y[i]); s2+=y[i]; } if((s1-s2)\u003e=0) printf(\"Yes\\n\"); else printf(\"No\\n\"); return 0; } ","date":"2018-07-31","objectID":"/posts/piles-with-stones/:0:0","tags":["ACM","Codeforces","C++"],"title":"Piles-with-stones","uri":"/posts/piles-with-stones/"},{"categories":["ACM"],"content":"1 并查集入门推荐：超有爱的并查集~ 2 题目链接：畅通工程 3 题意分析 首先在地图上给你若干个城镇，这些城镇都可以看作点，然后告诉你哪些对城镇之间是有道路直接相连的。最后要解决的是整幅图的连通性问题。比如随意给你两个点，让你判断它们是否连通，或者问你整幅图一共有几个连通分支，也就是被分成了几个互相独立的块。像畅通工程这题，问还需要修几条路，实质就是求有几个连通分支。 #include\u003ciostream\u003e #include\u003ccstdio\u003e using namespace std; int pre[1010]; int findd(int root){ int son,t; son=root; while(root!=pre[root]) root=pre[root]; while(son!=root){ t=pre[son]; pre[son]=root; son=t; } return root; } int main(){ int n,m,i,sum,r1,r2,star,end1; while(scanf(\"%d\",\u0026n)\u0026\u0026n){ sum=n-1; for(i=1;i\u003c=n;i++) pre[i]=i; scanf(\"%d\",\u0026m); while(m--){ scanf(\"%d%d\",\u0026star,\u0026end1); r1=findd(star); r2=findd(end1); if(r1!=r2){ pre[r1]=r2; sum--; } } printf(\"%d\\n\",sum); } return 0; } 4 基础回顾 4.1 find() 函数找根结点的两种写法如下 第一种递归： int find(int x) { return x == pre[x] ? x : find(pre[x]); } 第二种： int find(int x) { int root, temp; root = x; while(root != pre[root]) root = pre[root]; while(x != root) { temp = pre[x]; pre[temp] = root; x = temp; } return root; } 4.1.1 合并函数 void join(int x,int y){ int fx=find(x); int fy=find(y); if(fx!=fy) pre[fx]=fy; } ","date":"2018-07-31","objectID":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/:0:0","tags":["ACM","并查集","HDU","C++","C"],"title":"畅通工程-HDU-1232（并查集经典模板）","uri":"/posts/%E7%95%85%E9%80%9A%E5%B7%A5%E7%A8%8B/"},{"categories":["ACM"],"content":"两题水过，暴力，找规律。 1 托米的赌球 2 托米的划分 3 a #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int c[13],d[13]={100,50,20,10,5,2,1,50,20,10,5,2,1}; int i,t; cin\u003e\u003et; int a,b; while(t--){ memset(c,0,sizeof(c)); cin\u003e\u003ea\u003e\u003eb; for(i=0;i\u003c7;i++){ int x=0; if(a\u003ec[i]){ x=a/d[i]; c[i]+=x; a-=x*d[i]; } for(i=7;i\u003c13;i++){ int x=0; if(b\u003ec[i]){ x=b/d[i]; c[i]+=x; b-=x*d[i]; } cout\u003c\u003cc[0]; for(i=1;i\u003c13;i++) cout\u003c\u003c\" \"\u003c\u003cc[i]; cout\u003c\u003cendl; } return 0; } 4 b f(n)=f(n-1)+n-1; #include\u003cbits/stdc++.h\u003e using namespace std; long long sum; int main(){ int n; int t; cin\u003e\u003et; while(t--){ sum=1; cin\u003e\u003en; if(n==1) sum=0; for(int i=3;i\u003c=n;i++) sum+=i-1; cout\u003c\u003csum\u003c\u003cendl; } return 0; } ","date":"2018-07-27","objectID":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/:0:0","tags":["Nowcoder","ACM","C++","C"],"title":"牛客练习赛 23","uri":"/posts/%E7%89%9B%E5%AE%A2%E7%BB%83%E4%B9%A0%E8%B5%9B23/"},{"categories":["Grocery"],"content":"1 在线算法 在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。 在计算机科学中，一个在线算法是指它可以以序列化的方式一个个的处理输入，也就是说在开始时并不需要已经知道所有的输入。相对的，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。例如，选择排序在排序前就需要知道所有待排序元素，然而插入排序就不必。 因为在线算法并不知道整个的输入，所以它被迫做出的选择最后可能会被证明不是最优的，对在线算法的研究主要集中在当前环境下怎么做出选择。对相同问题的在线算法和离线算法的对比分析形成了以上观点。如果想从其他角度了解在线算法可以看一下流算法（关注精确呈现过去的输入所使用的内存的量），动态算法（关注维护一个在线输入的结果所需要的时间复杂度）和在线机器学习。 一个很好的展示在线算法概念的例子是 加拿大旅行者问题，这个问题的目标是在一个有权图中以最小的代价到达一个目标节点，但这个有权图中有些边是不可靠的可能已经被剔除。然而一个旅行者只有到某个边的一个端点时才能确定该边是否已经被移除了。最坏情况下，该问题会变得简单了，即所有的不确定的边都被移除该问题将会变成通常的最短路径问题。 2 离线算法 离线算法 ( off line algorithms)，是指基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果。 设计策略 在执行算法前输入已知的基本假设 前提 具有问题完全信息 算法设计策略都是基于在执行算法前输入数据已知的基本假设，也就是说，对于一个离线算法，在开始时就需要知道问题的所有输入数据，而且在解决一个问题后就要立即输出结果，通常将这类具有问题完全信息前提下设计出的算法称为离线算法 ( off line algorithms) ","date":"2018-07-26","objectID":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/:0:0","tags":["在线离线算法"],"title":"在线离线算法","uri":"/posts/%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E7%AE%97%E6%B3%95/"},{"categories":["ACM"],"content":"非常可乐 大家一定觉的运动以后喝可乐是一件很惬意的事情，但是 seeyou 却不这么认为。因为每次当 seeyou 买了可乐以后，阿牛就要求和 seeyou 一起分享这一瓶可乐，而且一定要喝的和 seeyou 一样多。但 seeyou 的手中只有两个杯子，它们的容量分别是 N 毫升和 M 毫升 可乐的体积为 S（S\u003c101）毫升（正好装满一瓶） ，它们三个之间可以相互倒可乐（都是没有刻度的，且 S==N+M，101 ＞ S ＞ 0，N ＞ 0，M ＞ 0) 。聪明的 ACMER 你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出\"NO\"。 1 Input 三个整数 : S 可乐的体积 , N 和 M 是两个杯子的容量，以\"0 0 0\"结束。 2 Output 如果能平分的话请输出最少要倒的次数，否则输出\"NO\"。 3 Sample Input 7 4 3 4 1 3 0 0 0 4 Sample Output NO 3 模拟一下倒水的过程，一共有三种倒法，a 向 bc，b 向 ac，c 向 ab。（相当于一共六个方向）搜索并记录搜索过的过程就好了。 #include\u003cbits/stdc++.h\u003e using namespace std; int a,b,c; int used[111][111][111]; struct node { int x,y,z; int step; }m,n; int bfs() { queue\u003cnode\u003eq; m.x = a; m.y = 0; m.z = 0; m.step = 0; used[a][0][0] = 1; q.push(m); while (!q.empty()) { int trans; //倒水量 m = q.front(); q.pop(); //成功分好的三种情况 if ((m.x == 0 \u0026\u0026 m.y == m.z) || (m.y == 0 \u0026\u0026 m.x == m.z) || (m.z == 0 \u0026\u0026 m.x == m.y)) return m.step; //下面开始 6 个搜索（由一个杯子向另外两个倒水） if (m.x) { //第一 trans = min(m.x , b - m.y);//自己模拟一下倒水过程就知道了 n.x = m.x - trans; n.y = m.y + trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } //第二 trans = min(m.x , c - m.z); n.x = m.x - trans; n.y = m.y; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } } if (m.y) { //第三 trans = min(m.y , a - m.x); n.x = m.x + trans; n.y = m.y - trans; n.z = m.z; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } //第四 trans = min(m.y , c - m.z); n.x = m.x; n.y = m.y - trans; n.z = m.z + trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } } if (m.z) { //第五 trans = min(m.z , a - m.x); n.x = m.x + trans; n.y = m.y; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { used[n.x][n.y][n.z] = 1; q.push(n); } //第六 trans = min(m.z , b - m.y); n.x = m.x; n.y = m.y + trans; n.z = m.z - trans; n.step = m.step + 1; if (!used[n.x][n.y][n.z]) { q.push(n); used[n.x][n.y][n.z] = 1; } } } return 0; } int main() { while (~scanf (\"%d %d %d\",\u0026a,\u0026b,\u0026c) \u0026\u0026 (a || b || c)) { if (a\u00261) //先简单的剪枝一下，奇数肯定不能平分 printf (\"NO\\n\"); else { memset (used,0,sizeof (used)); int ans = bfs(); if (ans) printf (\"%d\\n\",ans); else printf (\"NO\\n\"); } } return 0; } 然后杭电上讨论板子上提供一种数论题解，但是数据存在一点问题，只不过有些数据好像不对；比如：10 6 5 的结果应该是 1 而不是 9，也提示我们多维思考同一个问题！ 数论推导 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int s,n,m; while(cin\u003e\u003es\u003e\u003en\u003e\u003em,s+n+m){ s/=__gcd(n,m); if(s\u00261)//奇数 cout\u003c\u003c\"NO\\n\"; else cout\u003c\u003cs-1\u003c\u003cendl; } return 0; } ","date":"2018-07-24","objectID":"/posts/hdu-1495/:0:0","tags":["ACM","HDU","搜索","C++"],"title":"HDU-1495-非常可乐（bfs 模拟倒水 or 数论）","uri":"/posts/hdu-1495/"},{"categories":["ACM"],"content":"Find a way 圣诞节要到了，坤神和瑞瑞这对基佬想一起去召唤师大峡谷开开车。百度地图一下，发现周围的召唤师大峡谷还不少，这对基佬纠结着，该去哪一个。坤神：我要去左边的这个（因为离自己比较近 哈哈~）。瑞瑞：我要去右边的这个（因为离自己比较近 嘿嘿~） …….. 这对基佬闹矛盾了，开车有危险了！为了不让他们去召唤师大峡谷坑人，riot 决定让他们去 X 召唤师大峡谷，保证他俩所走的路程和最短。每走一个点需要花费 11 分钟，输出他们一共花费多少时间（最短时间噢） 1 Input 多组测试数据 每组数据，开始一行 n，m (2\u003c=n,m\u003c=200) 接下来是个 n x m 的矩阵 ‘Y’ 表示坤神所在的初始位置 ‘M’ 表示瑞瑞所在的初始位置 ‘#’ 该点禁止通行 ‘.’ 该点可通行 ‘@’ 召唤师大峡谷 2 Output 每组测试数据，输出坤神和瑞瑞到达同一个召唤师大峡谷所花费的最短时间。 3 Sample Input 4 4 Y.#@ .... .#.. @..M 4 4 Y.#@ .... .#.. @#.M 5 5 Y..@. .#... @..M. `#...#` 4 Sample Output 66 88 66 5 Hint 对于第一组样例，坤神和瑞瑞去矩阵（4,1）这个召唤师大峡谷，耗费的时间为 3 ✖️ 11 + 3 ✖️ 11 = 66，去矩阵（1,4）这个召唤师大峡谷，耗费的时间为 5 ✖️ 11 + 3 ✖️ 11 = 88。所以，最终答案：66。思路参考 写代码总是好粗心！！ #include \u003cbits/stdc++.h\u003e #define inf 0x3f3f3f3f //acm 中“无穷大”的一般定义 using namespace std; const int M=202; char mp[M][M]; //地图 int a[M][M],b[M][M]; bool vis[M][M]; //标记数组 int n,m; int ans; struct node { int x,y,step; }; void init() //初始化函数 { ans=inf; for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) { a[i][j]=inf; b[i][j]=inf; } } void bfs(int x,int y,bool flag){ int dir[4][2]={-1,0,1,0,0,1,0,-1}; node u,v; queue\u003cnode\u003e q; //初始化队列第一个元素 u.x=x; u.y=y; u.step=0; vis[x][y]=true; q.push(u); while(!q.empty()){ u=q.front(); q.pop(); if(mp[u.x][u.y]=='@'){ if(!flag) a[u.x][u.y]=u.step; else b[u.x][u.y]=u.step; } for(int i=0;i\u003c4;i++){ int tx=u.x+dir[i][0]; int ty=u.y+dir[i][1]; if(tx\u003e=0\u0026\u0026ty\u003e=0\u0026\u0026tx\u003cn\u0026\u0026ty\u003cm\u0026\u0026!vis[tx][ty]\u0026\u0026mp[tx][ty]!='#'){//注意@和 M，Y 也是可以走的。 v.x=tx; //每次写搜索都忘记 vis!!!! v.y=ty; vis[tx][ty]=true; //我总是忘记。 v.step=u.step+1; q.push(v); } } } } int main() { while(~scanf(\"%d%d\",\u0026n,\u0026m)) { init(); for(int i=0; i\u003cn; i++) scanf(\"%s\",mp[i]); for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) { if(mp[i][j]=='Y') { memset(vis,false,sizeof(vis)); bfs(i,j,false); } if(mp[i][j]=='M') { memset(vis,false,sizeof(vis)); //记得再次初始化标记数组 bfs(i,j,true); } } for(int i=0; i\u003cn; i++) for(int j=0; j\u003cm; j++) if(mp[i][j]=='@') ans=min(ans,a[i][j]+b[i][j]); printf(\"%d\\n\",ans*11); } return 0; } ","date":"2018-07-23","objectID":"/posts/hdu-2612/:0:0","tags":["ACM","HDU","搜索","C++"],"title":"hdu-2612-Find a way（双 bfs）","uri":"/posts/hdu-2612/"},{"categories":["ACM"],"content":"Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point N (0 ≤ N ≤ 100,000) on a number line and the cow is at a point K (0 ≤ K ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting. Walking: FJ can move from any point X to the points X\",“1 or X + 1 in a single minute Teleporting: FJ can move from any point X to the point 2 × X in a single minute. If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it? 1 Input Line 1: Two space-separated integers: N and K 2 Output Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow. 3 Sample Input 5 17 4 Sample Output 4 5 Hint The fastest way for Farmer John to reach the fugitive cow is to move along the following path: 5-10-9-18-17, which takes 4 minutes. 6 题意 农场主的牛不见了，主人和牛在一条直线上，且牛没有新的目标，它不会走动，主人的位置是你 n，牛的位置是 k，主人可以有三种走路的方法，右左（距离+-1），闪现（距离+x,x 为当前位置），每走一步，一分钟，问几分钟主人能找到牛。bfs 搜索方向即为三个“方向”。搜索所有走法； #include\"iostream\" #include\u003cqueue\u003e #include\"string.h\" using namespace std; int n,k; bool sign[200007]; struct node{ int x,step; }; bool check(int a) { if(!sign[a]\u0026\u0026a\u003e=0\u0026\u0026a\u003c110000) return true; return false; } void bfs() { node u,v; queue\u003cnode\u003e q; v.x=n;//初始化起点 v.step=0; q.push(v); sign[v.x]=true; while(!q.empty()){ u=q.front(); q.pop(); if(u.x==k){ cout\u003c\u003cu.step\u003c\u003cendl; return ; } //三种前进方向，左右和闪现 v=u; v.x++; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } v=u; v.x--; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } v=u; v.x=2*v.x; v.step++; if(check(v.x)){ sign[v.x]=true; q.push(v); } } } int main() { cin\u003e\u003en\u003e\u003ek; memset(sign,0,sizeof(sign)); bfs(); return 0; } ","date":"2018-07-22","objectID":"/posts/poj-3278/:0:0","tags":["BFS","ACM","搜索","POJ","C++"],"title":"POJ-3278-Catch That Cow(bfs)","uri":"/posts/poj-3278/"},{"categories":["ACM"],"content":"英文原题链接 1 Description - 题目描述 你被困在一个三维的空间中，现在要寻找最短路径逃生！ 空间由立方体单位构成 你每次向上下前后左右移动一个单位需要一分钟 你不能对角线移动并且四周封闭 是否存在逃出生天的可能性？如果存在，则需要多少时间？ 2 Input - 输入 输入第一行是一个数表示空间的数量。 每个空间的描述的第一行为 L，R 和 C（皆不超过 30）。 L 表示空间的高度。R 和 C 分别表示每层空间的行与列的大小。 随后 L 层地牢，每层 R 行，每行 C 个字符。 每个字符表示空间的一个单元。’#‘表示不可通过单元，’.‘表示空白单元。你的起始位置在’S’，出口为’E’。 每层空间后都有一个空行。L，R 和 C 均为 0 时输入结束。 3 Output - 输出 每个空间对应一行输出。 如果可以逃生，则输出如下 Escaped in x minute(s). x 为最短脱离时间。 如果无法逃生，则输出如下 Trapped! 4 Sample Input - 输入样例 3 4 5 S.... .###. .##.. ###.# ##### ##.## ##... ##### #.### ####E 1 3 3 S## #E# ### 0 0 0 5 Sample Output - 输出样例 Escaped in 11 minute(s). Trapped! 类似二维四个方向的 bfs 最短路，改成上下东西南北就行了，三维 bfs 最短路 #include \u003ciostream\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cqueue\u003e #include \u003calgorithm\u003e using namespace std; char map[35][35][35]; int vis[35][35][35]; int k,n,m,sx,sy,sz,ex,ey,ez; int to[6][3] = {{0,0,1},{0,0,-1},{0,1,0},{0,-1,0},{1,0,0},{-1,0,0}};//上下东西南北 struct node { int x,y,z,step; }; int check(int x,int y,int z)//检查是否可走 { if(x\u003c0 || y\u003c0 || z\u003c0 || x\u003e=k || y\u003e=n || z\u003e=m)//越界判断 return 1; else if(map[x][y][z] == '#') return 1; else if(vis[x][y][z]) return 1; return 0; } int bfs() { int i; node a,next; queue\u003cnode\u003e Q; a.x = sx,a.y = sy,a.z = sz; a.step = 0; vis[sx][sy][sz] = 1; Q.push(a); while(!Q.empty()) { a = Q.front(); Q.pop(); if(a.x == ex \u0026\u0026 a.y == ey \u0026\u0026 a.z == ez) return a.step; for(i = 0; i\u003c6; i++) { next = a; next.x = a.x+to[i][0]; next.y = a.y+to[i][1]; next.z = a.z+to[i][2]; if(check(next.x,next.y,next.z)) continue; vis[next.x][next.y][next.z] = 1; next.step = a.step+1; Q.push(next); } } return 0; } int main() { int i,j,r; while(scanf(\"%d%d%d\",\u0026k,\u0026n,\u0026m),n+m+k) { for(i = 0; i\u003ck; i++) { for(j = 0; j\u003cn; j++) { scanf(\"%s\",map[i][j]); for(r = 0; r\u003cm; r++) { if(map[i][j][r] == 'S') { sx = i,sy = j,sz = r; } else if(map[i][j][r] == 'E') { ex = i,ey = j,ez = r; } } } } memset(vis,0,sizeof(vis)); int ans; ans = bfs(); if(ans) printf(\"Escaped in %d minute(s).\\n\",ans); else printf(\"Trapped!\\n\"); } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-2251/:0:0","tags":["BFS","ACM","搜索","POJ","C++","C"],"title":"poj-2251-Dungeon Master（三维 bfs 最短路）","uri":"/posts/poj-2251/"},{"categories":["ACM"],"content":"Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 63659 Accepted: 30423 1 Description 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放 k 个棋子的所有可行的摆放方案 C。 2 Input 输入含有多组测试数据。 每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个 n * n 的矩阵内描述棋盘，以及摆放棋子的数目。n \u003c= 8 , k \u003c= n 当为 -1 -1 时表示输入结束。 随后的 n 行描述了棋盘的形状：每行有 n 个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 3 Output 对于每一组数据，给出一行输出，输出摆放的方案数目 C（数据保证 C\u003c2^31）。 4 Sample Input 2 1 #. .# 4 4 ...# ..#. .#.. #... -1 -1 5 Sample Output 2 1 6 Source 蔡错@pku 7 思路 下子方案数就相当于遍历图的不同遍历数，用 dfs 变形。 理解以下数据还有样例应该差不多了 3 2 #.. .#. ..# 3 3 2 #.. .## ..# 4 8 AC 代码 #include\u003ciostream\u003e #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003calgorithm\u003e using namespace std; char mp[8][8]; int v[8]; int n,k,w,r;//状态计数器 r void dfs(int x)//逐行深搜，x 为当前搜索行 { if(w==k)//下子数 w { r++;return; } if(x==n)return; for(int i=0;i\u003cn;i++) { if(v[i]!=1\u0026\u0026mp[x][i]=='#') { v[i]=1; w++; dfs(x+1); w--; v[i]=0; } } dfs(x+1);//搜索下一行 } int main() { while(cin\u003e\u003en\u003e\u003ek) { if(n==-1\u0026\u0026k==-1) return 0; memset(mp,0,sizeof(mp)); memset(v,0,sizeof(v)); for(int i=0;i\u003cn;i++) cin\u003e\u003emp[i]; w=0;r=0; dfs(0); cout\u003c\u003cr\u003c\u003cendl; } } 传送门 ","date":"2018-07-22","objectID":"/posts/poj-1321/:0:0","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1321 棋盘问题（dfs）","uri":"/posts/poj-1321/"},{"categories":["ACM"],"content":"1 Find The Multiple Time Limit: 1000MS Memory Limit: 10000K Total Submissions: 40713 Accepted: 17088 Special Judge 1.1 Description Given a positive integer n, write a program to find out a nonzero multiple m of n whose decimal representation contains only the digits 0 and 1. You may assume that n is not greater than 200 and there is a corresponding m containing no more than 100 decimal digits. 1.2 Input The input file may contain multiple test cases. Each line contains a value of n (1 \u003c= n \u003c= 200). A line containing a zero terminates the input. 1.3 Output For each value of n in the input print a line containing the corresponding value of m. The decimal representation of m must not contain more than 100 digits. If there are multiple solutions for a given value of n, any one of them is acceptable. 1.4 Sample Input 2 6 19 0 1.5 Sample Output 10 100100100100100100 111111111111111111 给定一个正整数 n，请编写一个程序来寻找 n 的一个非零的倍数 m，这个 m 应当在十进制表示时每一位上只包含 0 或者 1。你可以假定 n 不大于 200 且 m 不多于 100 位。 提示：本题采用 Special Judge，你无需输出所有符合条件的 m，你只需要输出任一符合条件的 m 即可。 #include\"iostream\" using namespace std; typedef unsigned long long ll; int n; bool sign; void dfs(ll x,int count) { if(sign) return ; if(x%n==0){ sign=true; cout\u003c\u003cx\u003c\u003cendl; return ; } if(count==19)//m 最多 200 位 return ; dfs(x*10,count+1); dfs(x*10+1,count+1); //每两位数后两位有两种情况，10 或 11，深搜所有情况，找到一种就返回，找不到找另外一颗子树 } int main() { while(cin\u003e\u003en\u0026\u0026n) { sign=false; dfs(1,0); } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-1426/:0:0","tags":["DFS","ACM","搜索","POJ","C++"],"title":"poj-1426-Find The Multiple(dfs)","uri":"/posts/poj-1426/"},{"categories":["ACM"],"content":"Codeforces Round 498 (Div. 3) A. Adjacent Replacements（水）","date":"2018-07-22","objectID":"/posts/adjacent-replacements/","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"A. Adjacent Replacements 第一次打 cf 就做出一道这样的找规律的题，打到自闭。 #include\u003cbits/stdc++.h\u003e using namespace std; int main(){ int n,a[1001]; cin\u003e\u003en; int i; int flag=0; for(i=0;i\u003cn;i++){ cin\u003e\u003ea[i]; if(!(a[i]\u00261)) a[i]--; if(!flag) {cout\u003c\u003ca[i];flag=1;} else cout\u003c\u003c\" \"\u003c\u003ca[i]; } return 0; } ","date":"2018-07-22","objectID":"/posts/adjacent-replacements/:0:0","tags":["Codeforces","ACM","C++"],"title":"Adjacent Replacements","uri":"/posts/adjacent-replacements/"},{"categories":["ACM"],"content":"迷宫问题 Time Limit: 1000MS Memory Limit: 65536K Total Submissions: 32323 Accepted: 18471 1 Description 定义一个二维数组： int maze[5][5] = { 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, }; 它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 2 Input 一个 5 × 5 的二维数组，表示一个迷宫。数据保证有唯一解。 3 Output 左上角到右下角的最短路径，格式如样例所示。 4 Sample Input 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0 5 Sample Output (0, 0) (1, 0) (2, 0) (2, 1) (2, 2) (2, 3) (2, 4) (3, 4) (4, 4) 对于新手来说，主要是 bfs 路径的问题有点难度，搞得晕晕的。 6 题解 #include\u003ciostream\u003e #include\u003ccstring\u003e using namespace std; int map[5][5]; int visited[5][5]; int dx[4]={0, 1, 0, -1}; int dy[4]={ 1, 0,-1, 0}; int head,tail; struct node{ int xx,yy; int fa;//父节点 }pre[25],way[25]; void BFS(int x,int y) { int x1,y1; visited[x][y]=1; pre[0].xx=x,pre[0].yy=y; while(tail\u003ehead)//栈空 { x=pre[head].xx; y=pre[head].yy; if(x==4\u0026\u0026y==4)//结束标志 return ; for(int i=0;i\u003c4;i++) { x1=x+dx[i];y1=y+dy[i]; if(x1\u003e=0\u0026\u0026x1\u003c=4\u0026\u0026y1\u003e=0\u0026\u0026y1\u003c=4) if(map[x1][y1]==0\u0026\u0026!visited[x1][y1]) { pre[tail].xx=x1; pre[tail].yy=y1; pre[tail].fa=head; visited[x1][y1]=1; tail+=1;//入栈 } } head++;//相当于出栈 } } int main() { int i,j; ios::sync_with_stdio(false); memset(map,0,sizeof(map)); memset(visited,0,sizeof(visited)); for(i=0;i\u003c5;i++) for(j=0;j\u003c5;j++) cin\u003e\u003emap[i][j]; BFS(0,0); i=0; while(head)//逆序进行赋值输出就是通路 { way[i].xx=pre[head].xx; way[i].yy=pre[head].yy; head=pre[head].fa; i++; } //画一下队列 way[i].xx=0;way[i].yy=0; while(i!=-1) { cout\u003c\u003c\"(\"\u003c\u003cway[i].xx\u003c\u003c\", \"\u003c\u003cway[i].yy\u003c\u003c\")\"\u003c\u003cendl; i--; } return 0; } ","date":"2018-07-22","objectID":"/posts/poj-3984/:0:0","tags":["BFS","ACM","POJ","C++","C"],"title":"poj-3984-迷宫问题 (bfs 路径）","uri":"/posts/poj-3984/"},{"categories":["ACM"],"content":"链接：https://www.nowcoder.com/acm/contest/133/A 来源：牛客网 1 题目描述 现在有一棵被 Samsara-Karma 染了 k 种颜色的树，每种颜色有着不同的价值，Applese 觉得 Samsara-Karma 染的太难看了，于是打算把整棵树重新染成同一种颜色，但是，由于一些奥妙重重的原因，每一次染色 Applese 可以选择两个有边相连的点，将其中一个染成另一个的颜色。而进行一次这样的操作需要付出两种颜色价值和的代价， 现在，Applese 的钱要用来买书 (game)，所以他想要最小化代价 2 输入描述 输入包括若干行第一行包括一个数 n，表示这棵树有 n 个节点第二行包括 n 个数，第 i 个数表示第 i 个节点的颜色 coli 注意：一个颜色的标号即价值接下来的 n - 1 行，每行包括两个数 u, v，表示 u 节点与 v 节点之间有一条无向边 n ≤ 100000, 1 ≤ coli ≤ 1e9，数据保证是一棵树 3 输出描述 输出包括一行第一行包括一个数，表示最小代价 4 示例 1 4.1 输入 4 2 3 4 3 1 2 2 3 3 4 4.2 输出 12 蒟蒻暴力枚举-_-! #include \u003cbits/stdc++.h\u003e using namespace std; const int MAXN=1e5+10; int a[MAXN]; map\u003cint, int \u003ema; set\u003cint\u003ese; int x[MAXN],y[MAXN]; int main() { int n; scanf(\"%d\",\u0026n); for (int i = 1; i \u003c=n ; ++i) { scanf(\"%d\",\u0026a[i]); se.insert(a[i]); } for (int i = 1; i \u003cn ; ++i) { scanf(\"%d%d\",\u0026x[i],\u0026y[i]); } long long ans=1e14,sum=0; set\u003cint\u003e::iterator it; for (it=se.begin(); it !=se.end() ; ++it) { sum=0; for (int j = 1; j \u003c=n ; ++j) { if((*it)!=a[j]) sum+=((*it)+a[j]); } ans=min(sum,ans); } printf(\"%lld\\n\",ans); return 0; } 最后想说这都过了什么鬼，不会数据这么弱吧？？！? 我只枚举了最小的价值颜色的情况，唉，不管了不管了。 #include\u003cbits/stdc++.h\u003e using namespace std; int a[1000000],n,m,k=1,t,ans=0; int main() { scanf(\"%d\",\u0026n); for(int i=1;i\u003c=n;++i) scanf(\"%d\",\u0026a[i]); sort(a+1,a+n+1); for(int i=2;i\u003c=n;++i) if(a[i]!=a[1]) ans+=a[i]+a[1]; printf(\"%d\",ans); return 0; } ","date":"2018-07-22","objectID":"/posts/wannafly-20/:0:0","tags":["ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 20-染色","uri":"/posts/wannafly-20/"},{"categories":["ACM"],"content":"百度知道 1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1、每行数字左右对称，由 1 开始逐渐变大，然后变小，回到 1。 2、第 n 行的数字个数为 n 个。 3、第 n 行数字和为 2^(n－1)。 4、每个数字等于上一行的左右两个数字之和。可用此性质写出整个帕斯卡三角形。 5、将第 2n+1 行第 1 个数，跟第 2n+2 行第 3 个数、第 2n+3 行第 5 个数……连成一线，这些数的和是第 2n 个斐波那契数。将第 2n 行第 2 个数，跟第 2n+1 行第 4 个数、第 2n+2 行第 6 个数……这些数之和是第 2n-1 个斐波那契数。 6、第 n 行的第 1 个数为 1，第二个数为 1×(n-1)，第三个数为 1×(n-1)×（n-2）/2，第四个数为 1×(n-1)×（n-2）/2×（n-3）/3…依此类推。 此数列中各行中的数字正好是二项式 a+b 乘方后，展开始终各项的系数。如： (a+b)^1=a^1+b^1 (a+b)^2=a^2+2ab+b^2 (a+b)^3=a^3+3a^2b+3ab^2+b^3 …… (a+b)^6=a^6+6a^5b+15a^4b^2+20a^3b^3+15a^2b^4+6ab^5+b^6（注意发现规律） …… 二项式展开式： ","date":"2018-07-22","objectID":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/:0:0","tags":["数学","杨辉三角"],"title":"杨辉三角","uri":"/posts/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/"},{"categories":["ACM"],"content":"1 Oil Deposits 翻译 Time Limit: 2000/1000 MS (Java/Others) Memory Limit: 65536/32768 K (Java/Others) Total Submission(s): 41406 Accepted Submission(s): 23977 1.1 Problem Description The GeoSurvComp geologic survey company is responsible for detecting underground oil deposits. GeoSurvComp works with one large rectangular region of land at a time, and creates a grid that divides the land into numerous square plots. It then analyzes each plot separately, using sensing equipment to determine whether or not the plot contains oil. A plot containing oil is called a pocket. If two pockets are adjacent, then they are part of the same oil deposit. Oil deposits can be quite large and may contain numerous pockets. Your job is to determine how many different oil deposits are contained in a grid. 1.2 Input The input file contains one or more grids. Each grid begins with a line containing m and n, the number of rows and columns in the grid, separated by a single space. If m = 0 it signals the end of the input; otherwise 1 \u003c= m \u003c= 100 and 1 \u003c= n \u003c= 100. Following this are m lines of n characters each (not counting the end-of-line characters). Each character corresponds to one plot, and is either ’ * ‘, representing the absence of oil, or ‘@’, representing an oil pocket. 1.3 Output For each grid, output the number of distinct oil deposits. Two different pockets are part of the same oil deposit if they are adjacent horizontally, vertically, or diagonally. An oil deposit will not contain more than 100 pockets. 1.4 Sample Input 1 1 * 3 5 *@*@* **@** *@*@* 1 8 @@****@* 5 5 ****@ *@@*@ *@**@ @@@*@ @@**@ 0 0 1.5 Sample Output 0 1 2 1.6 Source Mid-Central USA 1997 1.7 Recommend Eddy | We have carefully selected several similar problems for you: 1016 1010 1312 1242 1240 2 思路 dfs 模板题吧，八个方向搜索；（像 i，j 这样的计数器还是写在局部比较好，我尽然被定义域的问题搞了一晚上醉了醉了。） #include\u003cbits/stdc++.h\u003e using namespace std; int n,m,s; char maze[107][107]; int vx[8]={-1,1,0,0,-1,-1,1,1}; int vy[8]={0,0,-1,1,-1,1,1,-1}; void dfs(int x,int y){ maze[x][y]='*'; for(int i=0;i\u003c8;i++){ int tx=x+vx[i]; int ty=y+vy[i]; if(tx\u003e=0\u0026\u0026tx\u003cm\u0026\u0026ty\u003e=0\u0026\u0026ty\u003cn\u0026\u0026maze[tx][ty]=='@') dfs(tx,ty); } } int main(){ int i,j; while(cin\u003e\u003em\u003e\u003en\u0026\u0026m){ s=0; for(i=0;i\u003cm;i++) cin\u003e\u003emaze[i]; for(i=0;i\u003cm;i++){//相当于不连通的情况 for(j=0;j\u003cn;j++){ if(maze[i][j]=='@'){ dfs(i,j); s++; } } } cout\u003c\u003cs\u003c\u003cendl; } return 0; } ","date":"2018-07-22","objectID":"/posts/hdu-1241/:0:0","tags":["DFS","搜索","HDU","ACM","C++"],"title":"hdu-1241-Oil Deposits (dfs)","uri":"/posts/hdu-1241/"},{"categories":["ACM"],"content":"假设有一个 n 行 m 列的迷宫，每个单位要么是空地（用 1 表示）要么是障碍物（用 0 表示）. 如和找到从起点到终点的最短路径？利用 BFS 搜索，逐步计算出每个节点到起点的最短距离， 以及最短路径每个节点的前一个节点。最终将生成一颗以起点为根的 BFS 树。此时 BFS 可以求出任意一点到起点的距离。 1 图 1 3 0 21 23 2 0 17 20 22 4 0 14 0 0 5 0 12 15 18 6 8 10 0 19 7 9 11 13 16 2 输入 6 5 1 1 0 1 1 1 0 1 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 3 输出 1 2 4 5 6 8 10 12 14 17 20 21 23 12//最短距离 4 代码 #include\u003ciostream\u003e #include\u003cqueue\u003e #include\u003ccstdio\u003e #include\u003ccstring\u003e #include\u003cvector\u003e using namespace std; const int maxn=100+5; int G[maxn][maxn]; //存图的 d=id int path[maxn]; //存每个节点的父节点，即路径 int n,m; //n 行 m 列 int k=1;//记录编号 int end_num; int vx[5] = {-1,1,0,0}; //vx vy 用来计算一个节点周围上下左右 4 个节点 int vy[5] = {0,0,-1,1}; bool vis[maxn][maxn]; //判断某节点是否已经被访问过 struct node { int x; int y; int id; int parent=0; node(int a,int b,int c) { x=a; y=b; id=c; } }; int main() { //freopen(\"in.txt\",\"r\",stdin); memset(G,0,sizeof(G)); memset(vis,0,sizeof(vis)); memset(path,0,sizeof(path)); cin\u003e\u003en\u003e\u003em; for(int i=1; i\u003c=n; i++) for(int j=1; j\u003c=m; j++) { cin\u003e\u003eG[i][j]; } queue\u003cnode\u003e q; node v=node(1,1,1); q.push(v); vis[1][1]=1; while(!q.empty()) { node u=q.front(); q.pop(); path[u.id]=u.parent;//记录每个点的父节点 for(int i=0; i\u003c4; i++) { int tx=u.x+vx[i]; int ty=u.y+vy[i]; if(G[tx][ty]\u0026\u0026!vis[tx][ty])//有路可走且未访问 { vis[tx][ty]=1; //cout\u003c\u003ctx\u003c\u003cty\u003c\u003cendl; node v=node(tx,ty,++k); end_num=k; v.parent=u.id; q.push(v); } } } vector\u003cint\u003e ans; //cout\u003c\u003cend_num\u003c\u003cendl; while(end_num)//从后面开始找父亲节点 { ans.push_back(end_num); end_num=path[end_num]; } int s=0; while(!ans.empty()) { s++; cout\u003c\u003c*(ans.end()-1)\u003c\u003c' ';//ans 最后一个元素是 0 ans.pop_back(); } cout\u003c\u003cendl\u003c\u003cs-1; return 0; } ","date":"2018-07-22","objectID":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/:0:0","tags":["BFS","搜索","C++"],"title":"BFS 求最短路","uri":"/posts/bfs%E6%B1%82%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"categories":["ACM"],"content":"那天晚上报名了没打，第二天早上打的，也只出了两题。 1 A. Game Shopping #include\u003ciostream\u003e using namespace std; int main(){ int n,m,s=0; cin\u003e\u003en\u003e\u003em; int i,j; int c[1000],a[1000]; for(i=0;i\u003cn;i++) cin\u003e\u003ec[i]; for(i=0;i\u003cm;i++) cin\u003e\u003ea[i]; for(i=0,j=0;i\u003cn;){ if(j==m) break; if(c[i]\u003c=a[j]){ s++; j++; i++; } else i++; } if(i==n\u0026\u0026s==0) cout\u003c\u003c\"0\\n\"; else cout\u003c\u003cs\u003c\u003cendl; return 0; } 2 B. Minimum Ternary String #include \u003cbits/stdc++.h\u003e using namespace std; string s, ans; int main(){ cin \u003e\u003e s; int one = 0; for (int i = 0; i \u003c s.size(); i++){ if (s[i] == '0') ans += \"0\"; if (s[i] == '1') one++; if (s[i] == '2') ans += \"2\"; } bool flag = false; for (int i = 0; i \u003c ans.size(); i++){ if (ans[i] == '2' \u0026\u0026 !flag) flag = true, cout \u003c\u003c string(one, '1'); cout \u003c\u003c ans[i]; } if (!flag) cout \u003c\u003c string(one, '1'); return 0; } /* 100210 11222121 20 2001 020201 2012101 111 000 */ ","date":"2018-07-22","objectID":"/posts/cf-1009/:0:0","tags":["Codeforces","ACM","C++","C"],"title":"Educational Codeforces Round 47 (Rated for Div. 2)","uri":"/posts/cf-1009/"},{"categories":["ACM"],"content":"0.1 广度优先搜索（BFS） 广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。访问了就入队。 0.2 深度优先搜索（DFS） 深度优先搜索在搜索过程中访问某个顶点后，需要递归地访问此顶点的所有未访问过的相邻顶点。 #include \u003cbits/stdc++.h\u003e #define N 5 using namespace std; int maze[N][N] = {//无权有向图邻接矩阵 { 0, 1, 0, 1, 0 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 1 }, { 0, 0, 1, 0, 0 }, { 0, 0, 0, 0, 0 } }; int visited[N]; void DFS(int start) { cout \u003c\u003c start\u003c\u003c \" \"; visited[start] = 1; for (int i = 0; i \u003c N; i++) { if (!visited[i] \u0026\u0026 maze[start][i] == 1)//没访问过且为邻居节点 DFS(i); } } void BFS(int start){ queue\u003cint\u003e Q;//队列 Q.push(start); visited[start] = 1; while (!Q.empty()) { int front = Q.front();//头 cout \u003c\u003c front \u003c\u003c \" \"; Q.pop(); for (int i = 0; i \u003cN; i++) { if (!visited[i] \u0026\u0026 maze[front][i] == 1) { visited[i] = 1; Q.push(i); } } } } int main() { memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; DFS(i); } cout\u003c\u003cendl; memset(visited,0,sizeof(visited)); for (int i = 0; i \u003c N; i++)//不连通的情况 { if (visited[i] == 1)//访问过 continue; BFS(i); } return 0; } 传送门 ","date":"2018-07-22","objectID":"/posts/dfs_bfs/:0:0","tags":["ACM","BFS","DFS","搜索","C","C++"],"title":"深搜广搜","uri":"/posts/dfs_bfs/"},{"categories":["ACM"],"content":" 2018 年全国多校算法寒假训练营练习比赛（第二场）B(0 1 背包变化 特殊处理一个物品） 链接：https://www.nowcoder.com/acm/contest/74/B 来源：牛客网 1 题目描述 Taotao 的电脑带不动绝地求生，所以 taotao 只能去玩 pc 版的荒野行动了，和绝地求生一样，游戏人物本身可以携带一定重量 m 的物品，装备背包之后可以多携带 h（h 为 0 代表没有装备背包）重量的东西。玩了几天 taotao 发现了一个 BUG，当装备背包之后，如果可携带重量没有满，就可以拿一个任意重的东西（解释看样例）有一天 taotao 空降到了一个奇怪的岛上，岛上有 n 件装备，每个装备都有重量 Wi 和威力值 Vi, 但 taotao 不认识这些装备，所以他来求助你，挑选威力最大的装备，帮助他吃鸡。 2 输入描述 本题有多组输入（小于 10），当 n=0 时结束输入。第一行输入 n,m,h。n，m，h 为整数，并且 0\u003c=n,m,h\u003c=100，接下来 n 行，每行输入第 i 个物品的物品的重量 Wi 和威力值 Vi。0\u003c=Wi,Vi\u003c=100. 3 输出描述 输出最大威力值，每组输出一行。 4 示例 1 4.1 输入 3 3 3 2 3 3 2 2 3 0 4.2 输出 8 5 说明 可携带的总重量为 6，当拿了前两件装备，此时容量为 5/6，还可以再拿第三件物品。 思路：0-1 背包的变形题目，h=0 的时候为背包的模板，h！=0 的时候枚举每一个需要特殊处理的物品再背包 #include \u003cbits/stdc++.h\u003e using namespace std; int v[105]; int w[105]; int n,m,h; int dp[205]; int main() { while(scanf(\"%d\",\u0026n)==1\u0026\u0026n!=0){ int sum=0; scanf(\"%d%d\",\u0026m,\u0026h); for(int i=1;i\u003c=n;i++) scanf(\"%d%d\",\u0026w[i],\u0026v[i]); if(h==0){ memset(dp,0,sizeof(dp)); for(int i=1;i\u003c=n;i++) //前 i 个物品 for(int j=m;j\u003e=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); // sum=dp[m]; } else{ m+=h for(int k=1;k\u003c=n;k++) //枚举可以被剩下的物品 { memset(dp,0,sizeof(dp)); for(int i=1;i\u003c=n;i++){ //前 i 个物品 if(i!=k){ for(int j=m;j\u003e=w[i];j--) //枚举背包重量 dp[j]=max(dp[j],dp[j-w[i]]+v[i]); } } //留下来一个重量，即初始化威力为那个重量的威力 for(int j=m-1;j\u003e=m-w[k];j--) //枚举背包重量 + 剩下物品 dp[m]=max(dp[m],dp[j]+v[k]); // printf(\"%d\\n\",dp[m]); sum=max(sum,dp[m]); } } printf(\"%d\\n\",sum); } return 0; } ","date":"2018-07-22","objectID":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/:0:0","tags":["背包问题","Nowcoder","C++"],"title":"TaoTao 要吃鸡","uri":"/posts/taotao%E8%A6%81%E5%90%83%E9%B8%A1/"},{"categories":["ACM"],"content":"时间限制：C/C++ 1 秒，其他语言 2 秒 空间限制：C/C++ 262144K，其他语言 524288K 64bit IO Format: %lld 1 题目描述 有一个长度为 n 的序列 a，已知 a[1]=a[n]=1，且对于 2 \u003c= x \u003c= n，a[x] / a[x-1] 是以下三个数字之一 [ 1，-2，0.5 ], 问有多少种不同的序列满足题意。 两个序列不同当且仅当它们有至少一个位置上的数字不同，序列 a 可以为任何实数。 2 输入描述 一个整数 表示 n (1\u003c= n \u003c= 1e3) 3 输出描述 一个整数 表示答案模 109+7 4 示例 1 输入 5 输出 7 解题思路： 整体来看，a[x] = a[x-1] [1, -2, 0.5]，那么等于从 n-1 个 [1,-2,0.5] 中选出 n-1 个数值相乘（a[x-1]=a[x-2] [1,-2,0.5] 同理化简式子）， 最后答案要是 1，所以 -2 就必须有偶数个，同理 0.5 的个数要等于 -2. 顺序无关。 那所有的转换中，就只要保证有若干组 (-2,-2,0.5,0.5) 存在 表示偶数个 2 的个数与偶数个 0.5 的个数组合；组合数用二项式系数，杨辉三角来求。 #include \u003cbits/stdc++.h\u003e using namespace std; const int maxn = 1e3 + 5; const int mod = 1e9 + 7; long long c[maxn][maxn]; int main(){ for(int i = 0; i \u003c maxn; i++){//杨辉三角 c[i][0] = 1; c[i][i] = 1; for(int j = 1; j \u003c i; j++) c[i][j] = (c[i-1][j] + c[i-1][j-1]) % mod; } int n; while(~scanf(\"%d\", \u0026n)){ n--; long long ans = 0; for(int i = 0; i*2 \u003c= n; i += 2){ ans = (ans%mod + (c[n][i]*c[n-i][i])%mod)%mod; } printf(\"%lld\\n\", ans); } return 0; } ","date":"2018-07-18","objectID":"/posts/wannafly-18/:0:0","tags":["组合数学","ACM","Nowcoder","C++","C"],"title":"Wannafly 挑战赛 18-序列","uri":"/posts/wannafly-18/"},{"categories":["ACM"],"content":"弱鸡还是弱鸡啊最简单的背包问题——。——！ 1 问题描述 假设有一个能装入总体积为 T 的背包和 n 件体积分别为 W1，W2，···，Wn 的物品，能否从 n 件物品中挑选若干件恰好装满背包，即使 W1+W2+···+Wn=T，要求找出所有满足上述条件的解。例如：当 T=10，共 6 件物品，物品的体积为{1，2，3，4，5，8}，那么可找到下列 4 组解：（1，2，3，4）、（1，4，5）、（2，3，5）、（2、8）。 2 实现提示 可利用回溯法的设计思想来解决背包问题。首先，将物品排成一列，然后顺序选取物品装入背包，假设已选取了前 i 件物品之后背包还没有装满，则继续选取第 i+1 件物品，若该件物品“太大”不能装入，则丢弃而继续选取下一件，直至背包装满为止。但如果在剩余的物品中找不到合适的物品以填满背包，则说明“刚刚”装入背包的那件物品“不合适”，应将它取出“丢弃一边”，继续再从“它之后”的物品中选取，如此重复，直至求得满足条件的解，或者无解。由于回溯求解的规则是“后进先出”，因此要用到栈。 使用栈作为该程序的数据结构，利用栈进行语法检查，以深度优先的搜索方式解空间，实现递归过程和函数的调用，在设计时还使用 C 语言的数组及其循环语言来实现程序。 运用回溯法解题，在搜索解空间树时，只要其左儿子节点是一个可行结点，搜索就进入左子树，在右子树中有可能包含最优解是才进入右子树搜索。否则将右子树剪去。 #include \u003cstdio.h\u003e #include \u003cwindows.h\u003e #define size 50 struct stacks { int data[size]; int top; } stack; void backpack(int number,int V,int w[]){ int i,j=1,k=0; int flag=0; do { while (V \u003e 0 \u0026\u0026 k \u003c= number) { if (V \u003e= w[k]) { stack.data[stack.top] = k;//第 k 个物品的体积下标 stack.top++; V -= w[k]; } k++; } if (V == 0) { flag=1; printf(\"第%d 个符合条件的解：\", j); for (i = 0; i \u003c stack.top; i++) { printf(\"%d \", w[stack.data[i]]); } j++; printf(\"\\n\"); } //k 满时回溯 k = stack.data[--stack.top]; stack.data[stack.top] = 0; V += w[k]; k++; } while (!(stack.top == 0 \u0026\u0026 k == number)); if(!flag){ printf(\"背包无解！\\n\"); } } void judge(int number,int V,int w[]){ int i,s = 0; for (i = 0; i \u003c number; i++) s = s + w[i]; if(V \u003e s){ printf(\"背包无解！\\n\"); exit(0); } if(V==s){ printf(\"只有一个符合条件的解：%d\\n\", V); exit(0); } } int main() { int w[size]; int V; int i = 0; int j = 0; int number; printf(\"\\t **简单背包问题**\\n\\n\"); printf(\"\\n 请输入可供选择装入物品的个数：\\n\"); scanf(\"%d\", \u0026number); printf(\"\\n 请输入各件物品的体积：\\n\"); for (i = 0; i \u003c number; i++) scanf(\"%d\", \u0026w[i]); //排序 for(i=0;i\u003cnumber;i++) for(j=i+1;j\u003cnumber;j++) if(w[i]\u003ew[j]){ w[i]=w[i]^w[j]; w[j]=w[i]^w[j]; w[i]=w[i]^w[j]; } printf(\"\\n 请输入背包的总体积：\\n\"); scanf(\"%d\", \u0026V); while(V \u003c 0){ printf(\"输入背包体积错误！重新输入！\\n\"); scanf(\"%d\",\u0026V); } judge(number,V,w); //初始化栈 for (i = 0; i \u003c number; i++) stack.data[i] = 0; stack.top = 0; backpack(number,V,w); return 0; } –这么简单的问题我都费力，太辣鸡了，还是要多练习啊！– ","date":"2018-06-16","objectID":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/:0:0","tags":["背包问题","C"],"title":"简单背包","uri":"/posts/%E7%AE%80%E5%8D%95%E8%83%8C%E5%8C%85/"},{"categories":["ACM"],"content":" 来自一位大佬的演讲 尊敬的领导、教练，亲爱的参赛选手们： 大家好，我是来自广东工业大学的 tmk。今天很荣幸能够站在这里代表全体参赛选手发言，与大家分享我的经历和感受。 刚开始来到大学的时候，我一心向学，本着“好好学习，天天向上，为校争光，不搞对象”的信念，想在大学一展宏图。因为高中 OI 的挫败，我在刚上大学的时候就选择了 ACM 这条“不归路”。一开始是因为高中的遗憾，到后来就完全是因为信念和兴趣慢慢一直搞到现在。当时的我还不知道踏上 ACM 这条路的苦，而如今的我却也尝到了 ACM 带给我的乐。 在这三年里，有数不清的夜晚，我的舍友们在寝室里开黑，而我和我的队友在机房里开黑；在这三年里，有数不清的周末，我的舍友们在校园里驰骋，而我和我的队友在题库里驰骋；在这三年里，有数不清的假期，我的舍友们在召唤师峡谷里征战，而我和我的队友在中国各省市征战。三年过去了，我的舍友们成为了 offer 收割机，而我和我的队友成为了气球收割机。 为了变强是一个痛苦且漫长的过程，只有耐得住寂寞，才能守得住繁华。我的一位队友为了变强甚至牺牲了自己的头发，仅仅是因为他担心他的头发阻碍了他思维的发散。他变秃了也变强了。 三年的 ACM 让我成长很多，收获很多。我也从一个“好好学习天天向上为校争光不搞对象”的无知青年变成了一个写的了工程查得出异常的准程序员。我觉得三年献身于 ACM 的日子是值得的，和一大堆萌萌的男孩子们在屋子里面一个又一个通宵奋斗的酣畅淋漓的日子是值得的，看着谈恋爱的大家一会儿哀伤一会儿忧愁而我与代码自得其乐矢志不渝的日子是值得的。此外他还给我带来两个最好的小伙伴，是他们的一路陪伴，让我有勇气一直走下去。我和他们走过的地方，比我和女朋友去过的地方还要多。噢，对了，我好像没有女朋友。总而言之，请珍惜你们的队友，他们是你们在大学里为数不多一起奋斗的小伙伴。希望大家像我一样，也爱着 ACM，为自己心爱的努力。 最后预祝各位参赛选手们取得理想的成绩，也预祝本次大赛圆满成功。谢谢大家。 ","date":"2018-06-15","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/:0:0","tags":["ACM","2018 湘潭邀请赛"],"title":"18 湘潭邀请赛参赛队员代表发言","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E9%98%9F%E5%91%98%E4%BB%A3%E8%A1%A8%E5%8F%91%E8%A8%80/"},{"categories":["thoughts"],"content":"题目链接（hdu 复赛） 2018 年湘潭邀请赛，在湘大举行，当时一起打的过去的，因为没出市就方便点。第一次参加现场赛，首先反省一下自己，比赛前算法先不说（没有好好搞过），就连普通的题，数学性质的题都很少刷，什么都不会，然后英语不说四六级的东西，很多专业英语词汇都没有好好了解过，主要的原因还是刷题刷少了，英文题刷少了。理所当然，成功拿下一铁，湘潭赛打铁告终。 比赛开始，这次是三个人没人一份纸质题目，拿到题目，看最后一题，k.2018 发现可以做，（事实证明确实是一道水题），我就在做这题，他们看了 a 题，好像是 k 题一顿操作后提交，错了，一直到比赛结束都没做出来，后来回去看别人的题解，发现自己情况没有分析全面，其实是完全可以解出来的，真的做的太少太少了。a 题最后也是没过，还有一个 f 题，sort，我最初的想法是用 stl 里的那个 sort 排序，只要对 sort 的 compare 函数做处理应该可以完成排序，比赛之前我看过，但是不熟悉，zxm 她也看了我就交给她了，最后好像因为爆 long double 的问题也没做出来。 哎，菜还是菜，很多算法都不懂，数据结构也没学好，很有一段时间我都特别头疼算法，不想学，费劲，觉得自己不适合学计算机，更不适合 ACM。有时候又想，不适合好像总是 loser 的借口！总是在后悔和偷懒的矛盾中！ 最后，放上，“参赛奖\"羞辱自己，也是鞭策！ ","date":"2018-06-14","objectID":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/:0:0","tags":["2018 湘潭邀请赛","ACM","总结"],"title":"18 湘潭邀请赛总结","uri":"/posts/18%E6%B9%98%E6%BD%AD%E9%82%80%E8%AF%B7%E8%B5%9B%E6%80%BB%E7%BB%93/"},{"categories":["ACM"],"content":" 1 Sample Input 2 1 1 1 1 1 2 2 1 1 2 1 1 1 3 1 3 1 2 2 1 3 1 1 2 Sample Output 2 1 1 2 1 2 3 题意：给定 n 个元组 (a1,b1,c1),(a2,b2,c2),…,(an,bn,cn)，将其按 (ai+bi)/(ai+bi+ci) 的值从小到大排序，输出排序后的 n 个元组的原序号； 思路：编写 sort 里的 cmp 函数（形参为元组结构体元素，设为 Tuple x,Tuple y)，若直接算出 (x.a+x.b)(y.a+y.b+y.c) 和 (y.a+y.b)(x.a+x.b+x.c) 再比较大小，这两个结果会爆 unsigned long long； 可以把因式乘积展开成多项式的和，约去两式中相同的项，得到 x.ay.c+x.by.c 和 y.ax.c+y.bx.c，因此只需计算它俩再比较即可，结果不会爆 unsigned long long 后 AC 代码 #include \"bits/stdc++.h\" using namespace std; struct node{ long double a,b,c; int numb; }ss[1005]; bool cmp(const node \u0026a,const node \u0026b){ long double suma,sumb; //suma=a.a*b.c+a.b*b.c; //sumb=b.a*a.c+b.b*a.c; suma=(a.a+a.b)/(a.a+a.b+a.c); sumb=(b.a+b.b)/(b.a+b.b+b.c); if(suma!=sumb)return suma\u003csumb; return a.numb\u003cb.numb; } int main(){ int n; while(cin\u003e\u003en){ for(int i=0;i\u003cn;i++){ cin\u003e\u003ess[i].a\u003e\u003ess[i].b\u003e\u003ess[i].c; ss[i].numb=i+1; } stable_sort(ss,ss+n,cmp); int i; for(i=0;i\u003cn-1;i++) cout\u003c\u003css[i].numb\u003c\u003c\" \"; cout\u003c\u003css[i].numb\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/f-sorting/:0:0","tags":["2018 湘潭邀请赛","ACM"],"title":"F.sorting","uri":"/posts/f-sorting/"},{"categories":["ACM"],"content":"1 K. 2018 Given a,b,c,d, ﬁnd out the number of pairs of integers (x,y) where a ≤ x ≤ b,c ≤ y ≤ d and x·y is a multiple of 2018. 1.1 Input The input consists of several test cases and is terminated by end-of-ﬁle. Each test case contains four integers a,b,c,d. 1.2 Output For each test case, print an integer which denotes the result. 1.3 Constraint • 1≤ a ≤ b ≤109,1≤ c ≤ d ≤109 • The number of tests cases does not exceed 104. 1.4 Sample Input 1 2 1 2018 1 2018 1 2018 1 1000000000 1 1000000000 1.5 Sample Output 3 6051 1485883320325200 题意：给定区间 [a,b]、[c,d]，问有多少对有序数组 (x,y)(x∈[a,b],y∈[c,d]) 使得 xy 是 2018 的倍数 思路：2018=21009（分解质因数），则对 x 分类讨论：1) 仅为 2 的倍数；2）仅为 1009 的倍数；3）即为 2 又为 1009 的倍数；4）既不为 2 又不为 1009 的倍数 等价于如下分类讨论： 若 x 是偶数：1）若 x 是 1009 的倍数，则 y 可为 [c,d] 中任意数；2）若 x 不是 1009 的倍数，则 y 必定为 [c,d] 中 1009 的倍数 若 x 是奇数：1）若 x 是 1009 的倍数，则 y 必定为 [c,d] 中 2 的倍数；2）若 x 不是 1009 的倍数，则 y 必定为 [c,d] 中 2018 的倍数 后 AC 代码 #include\u003ccstdio\u003e #include\u003ciostream\u003e typedef unsigned long long ll; using namespace std; int main(){ ll a,b,c,d; while(cin\u003e\u003ea\u003e\u003eb\u003e\u003ec\u003e\u003ed){ ll num1_all_1009=b/1009-(a-1)/1009; ll num1_even=b/2-(a-1)/2; ll num1_1009_in_even=b/2018-(a-1)/2018; ll num1_rest_in_even=num1_even-num1_1009_in_even; ll num1_odd=(b-a+1)-num1_even; ll num1_1009_in_odd=num1_all_1009-num1_1009_in_even; ll num1_rest_in_odd=num1_odd-num1_1009_in_odd; ll ans=0; ans+=num1_1009_in_even*(d-c+1); ll num2_all_1009=d/1009-(c-1)/1009; ans+=num1_rest_in_even*num2_all_1009; ll num2_even=d/2-(c-1)/2; ans+=num1_1009_in_odd*num2_even; ll num2_all_2018=d/2018-(c-1)/2018; ans+=num1_rest_in_odd*num2_all_2018; cout\u003c\u003cans\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/k-2018/:0:0","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"K.2018","uri":"/posts/k-2018/"},{"categories":["ACM"],"content":"1 B. Higher h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has no papers and he is going to publish some subsequently. If he works on a paper for x hours, the paper will get (a·x) citations, where a is a known constant. It’s clear that x should be a positive integer. There is also a trick – one can cite his own papers published earlier. Given Bobo has n working hours, ﬁnd the maximum h-index of him. 1.1 Input The input consists of several test cases and is terminated by end-of-ﬁle. Each test case contains two integers n and a. 1.2 Output For each test case, print an integer which denotes the maximum h-index. 1.3 Constraint • 1≤ n ≤109 • 0≤ a ≤ n • The number of test cases does not exceed 104. 1.4 Sample Input 3 0 3 1 1000000000 1000000000 1.5 Sample Output 1 2 1000000000 1.6 Note For the ﬁrst sample, Bobo can work 3 papers for 1 hour each. With the trick mentioned, he will get papers with citations 2,1,0. Thus, his h-index is 1. For the second sample, Bobo can work 2 papers for 1 and 2 hours respectively. He will get papers with citations 1+1,2+0. Thus, his h-index is 2. 题意：给定 n 个小时，可以用其中 x(1\u003c=x\u003c=n) 个小时写一篇论文，那么这篇论文的\"既定\"引用数将会是x*a(a 为给定正整数）；此外，已经写好的论文将会被其后写成的论文所引用，也就是说，这篇论文的总引用数将会是\"既定\"引用数 + 其后论文篇数；问在所有的写论文方案中（例如一种方案就是用 n 个小时写 n 篇论文，每篇论文各花 1 小时（可以得到这 n 篇论文的引用数）)，h 最大为多少 (h 的含义同上题）（每一种方案都对应着一个 h，求这些 h 中的最大者） 思路：最优方案（即对应 h 值最大的方案）是平摊 n 小时写成 n 篇论文（证明未知）；此时 n 篇论文的引用数为 a,a+1,a+2,…,a+n-1，引用数为 a+i 时，引用数大于等于它的论文有 n-i 篇，令 a+i=n-i 得 i=(n-a)/2, 所以 h=a+(n-a)/2; 后 AC 代码 #include\u003ccstdio\u003e int main(){ int n,a; while(scanf(\"%d%d\",\u0026n,\u0026a)!=EOF){ printf(\"%d\\n\",a+(n-a)/2); } return 0; } ","date":"2018-06-14","objectID":"/posts/b-higher/:0:0","tags":["ACM","2018 湘潭邀请赛","C++","C"],"title":"B.Higher h-index","uri":"/posts/b-higher/"},{"categories":["ACM"],"content":"1 A. Easy h-index The h-index of an author is the largest h where he has at least h papers with citations not less than h. Bobo has published many papers. Given a0,a1,a2,…,an which means Bobo has published ai papers with itations exactly i, ﬁnd the h-index of Bobo. 1.1 Input The input consists of several test cases and is terminated by end-of-ﬁle. The ﬁrst line of each test case contains an integer n. The second line contains (n+1) integers a0,a1,…,an. 1.2 Output For each test case, print an integer which denotes the result. 1.3 Constraint • 1≤ n ≤2·105 • 0≤ ai ≤109 • The sum of n does not exceed 250,000. 1.4 Sample Input 1 1 2 2 1 2 3 3 0 0 0 0 1.5 Sample Output 1 2 0 题意：给定被引用次数为 0n 的论文分别有几张，找到最大的 h，满足被引用次数大于等于 h 的论文至少有 h 张 思路：在区间 [0,n] 内二分答案；或直接从 n0 遍历找到第一个满足条件的 h 后 AC 代码 #include \"bits/stdc++.h\" using namespace std; int main(){ int a[200005]; int n; int i; while(cin\u003e\u003en){ for(i=0;i\u003c=n;i++) cin\u003e\u003ea[i]; int sum=a[n]; for(i=n;i\u003e=0;){ if(sum\u003e=i){ cout\u003c\u003ci\u003c\u003cendl; break; } else sum+=a[--i]; } if(i\u003c0) cout\u003c\u003c\"0\"\u003c\u003cendl; } return 0; } ","date":"2018-06-14","objectID":"/posts/a-easy/:0:0","tags":["2018 湘潭邀请赛","ACM","C++"],"title":"A.Easy h-index","uri":"/posts/a-easy/"},{"categories":["ACM"],"content":"sort 使用#include\u003calgorithm\u003e头文件， sort（开始地址，结束地址，排序方式），其中第三参数可以没有，则默认为升序排序。 或者简单的用 less\u003c参数类型\u003e()表示升序 greater\u003c参数类型\u003e()表示降序 也可以用一个 bool 型函数，比如： bool cmp(int a,int b){ return a\u003eb;//表从大到小，即降序 } 假设自己定义了一个结构体 node typedef struct node { int a; int b; double c; }note; 有一个 node 类型的数组 node arr[100]，想对它进行排序：先按 a 值升序排列，如果 a 值相同，再按 b 值降序排列，如果 b 还相同，就按 c 降序排列。就可以写这样一个比较函数： 以下是代码片段： bool cmp(node x,node y) { if(x.a!=y.a) return x.a\u003cy.a; if(x.b!=y.b) return x.b\u003ey.b; return x.c\u003ey.c; } sort() 函数是完全通用的，你可以用它来操作几乎任何数据集合，包括链表，容器和数组，数组类型可以是 int,char 等。 实例：先降序再升序 #include\u003ciostream\u003e #include\u003calgorithm\u003e using namespace std; typedef struct data{ int a; double b; }date; bool cmp(date a,date b){ if(a.b!=b.b) return a.b\u003eb.b; return a.a\u003cb.a; } int main(){ date a[3]={{5,56.5},{4,56.5},{8,85}}; sort(a,a+3,cmp); for(int i=0;i\u003c3;i++) cout\u003c\u003ca[i].a\u003c\u003c\"-\"\u003c\u003ca[i].b\u003c\u003cendl; cout\u003c\u003cendl; return 0; } 传送门 ","date":"2018-06-14","objectID":"/posts/c-sort/:0:0","tags":["C++","sort","STL","ACM"],"title":"sort 排序","uri":"/posts/c-sort/"},{"categories":["Grocery"],"content":"1 1. \u0026运算 \u0026运算通常用于二进制取位操作，例如一个数 \u0026 1 的结果就是取二进制的最末位。这可以用来判断一个整数的奇偶，二进制的最末位为 0 表示该数为偶数，最末位为 1 表示该数为奇数。 2 2. |运算 |运算通常用于二进制特定位上的无条件赋值，例如一个数 or 1 的结果就是把二进制最末位强行变成 1。如果需要把二进制最末位变成 0，对这个数 | 1 之后再减一就可以了，其实际意义就是把这个数强行变成最接近的偶数。 3 3. ^运算 ^运算通常用于对二进制的特定一位进行取反操作，因为异或可以这样定义：异或 0 都不变，异或 1 则取反。 ^运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 a ^ b ^ b = a。运算可以用于简单的加密，比如你想对你 MM 说 1314520，但怕别人知道，于是双方约定拿你的生日 19880516 作为密钥。131452019880516 = 20665500，你就把 20665500 告诉 MM。MM 再次计算 20665500 ^ 19880516 的值，得到 1314520，于是她就明白了你的企图。 还可以用异或来进行快速地交换数据， a=2;b=3;//先转化成二进制 a=a^b; b=a^b; a=a^b; 操作后 a=3;b=2; 4 4. ~ 运算 运算的定义是把内存中的 0 和 1 全部取反。使用运算时要格外小心，你需要注意整数类型有没有符号。如果~的对象是无符号整数（不能表示负数），那么得到的值就是它与该类型上界的差，因为无符号类型的数是用$0000 到$FFFF 依次表示的。 5 5. «运算 a « b 就表示把 a 转为二进制后左移 b 位（在后面添 b 个 0）。例如 100 的二进制为 1100100，而 110010000 转成十进制是 400，那么 100 «2 = 400。可以看出，a « b 的值实际上就是 a 乘以 2 的 b 次方，因为在二进制数后添一个 0 就相当于该数乘以 2。 通常认为 a « 1 比 a * 2 更快，因为前者是更底层一些的操作。因此程序中乘以 2 的操作请尽量用左移一位来代替。 定义一些常量可能会用到«运算。你可以方便地用 1 «16 – 1 来表示 65535。很多算法和数据结构要求数据规模必须是 2 的幂，此时可以用«来定义 Max_N 等常量。 6 6. »运算 和«相似，a » b 表示二进制右移 b 位（去掉末 b 位），相当于 a 除以 2 的 b 次方（取整）。我们也经常用» 1 来代替 div 2，比如二分查找、堆的插入操作等等。想办法用»代替除法运算可以使程序效率大大提高。最大公约数的二进制算法用除以 2 操作来代替慢得出奇的 mod 运算，效率可以提高 60% 传送门 原文：http://www.matrix67.com/blog/archives/263 ","date":"2018-06-14","objectID":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/:0:0","tags":["位运算"],"title":"位运算","uri":"/posts/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"categories":["ACM"],"content":"1 1.swap（交换两元素值，在 algorithm 下，用法：swap(a,b);） 交换两元素的值在 C 语言课上作为指针讲解的典例。 int a=1,b=2; swap(a,b); //此时 a=2,b=1 （可以是其他类型） 2 2.sort(,,) sort 排序是不稳定的，stl 中的 stable_sort 才是稳定的 inta[10]={1,6,2,3,5,4,3,8,9,7}; stable_sort(a,a+10,greater\u003cint\u003e()); for(int i=0;i\u003c10;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; 3 3.reverse（翻转序列，在 algorithm 下） //常用在字符串上 int a[5]={1,2,3,4,5}; reverse(a,a+5); //序列现在是 5 4 3 2 1 char s[]=“ericxie”; reverse(s,s+strlen(s)); //序列现在是 “eixcire” //同样适用于 string string s=“qwer”; reverse(s.begin(),s.end()); 4 4.min，max（取大，取小） int a=1,b=2,c; c=min(a,b); //此时 c 等于 1 c=max(a,b); //此时 c 等于 2 string s=“qwer”,d=“asjk”,c; c=min(s,d); //c=“asjk” 5 5.__gcd（最大公约数） 手写 gcd 函数也行，辗转相除，辗转相减； int gcd(int a,int b){ return a%b ? b : gcd(b,a%b); } //直接用 int a=4,b=6; int c=__gcd(a,b); //注意下划线，此时 c 等于 2 6 6.lower_bound 和 upper_bound（二分查找） lower_bound 意思就是：找到第一个位置，使得：如果在这个位置插入 value 后，原有序序列依旧有序。 upper_bound 是找到最后一个符合数位置后一个位置，使得：如果在这个位置插入 value 后，原有序序列依旧有序。 //数组 int a[8]={1,2,4,4,9,12,12,15}; int pos1 = lower_bound(a,a+8,4)-a; int pos2 = upper_bound(a,a+8,4)-a-1; //在这个样例下 pos1!=pos2;pos1=2;pos2=3; 根据我的理解 lower_bound(a,a+8,value) 得到的是一个地址，拿这个地址减去数组首地址 a[0]，那么刚好就是 value 应该放入的位置。 //vector vector\u003cint\u003e a; 若 a 中目前的元素也是{1,2,4,4,9,12,12,15}; 那么这里用 lower_bound 得到的应该也是一个类似于指针的东西，为什么不叫它指针呢？因为他有了一个名字，叫做迭代器。 vector\u003cint\u003e::iterator it; it = lower_bound(a.begin(),a.end(),4); //这里的 it 就是迭代器，那么* it 就是该下标对应的 value 了。 //set 集合 set\u003cint\u003e a; set\u003cint\u003e::iterator it; it = a.lower_bound(value); 7 7.next_permutation（排列） bool next_permutation( iterator start, iterator end ); 通常用于生成序列的全排列。用之前先保证有序； int a[]={1,2,3}; do{ for(int i=0;i\u003c3;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; cout\u003c\u003cendl; }while(next_permutation(a,a+3)); 结果为： 1 2 3 1 3 2 2 1 3 2 3 1 3 1 2 3 2 1 string str=\"STL\"; sort(str.begin(), str.end()); do{ cout \u003c\u003c str \u003c\u003c endl; }while (next_permutation(str.begin(),str.end()))； 结果： LST LTS SLT STL TLS TSL 大数据 c 比 c++效率高 int length; char str[MAX]; gets(str); length = strlen(str); sort(str, str + length); do{ puts(str); }while(next_permutation(str, str+length))； 8 8.unique（去重） 如何把序列 a 中的重复元素去除呢？首先需要对原序列 a 进行排序，保证有序后，调用 unique(a.head , a.tail ) 就可以了。unique 会返回一个类似指针的东西（和 lower_bound 有点像），-a 后表示去重之后序列的长度。 下面是实例。 int a[]={1,3,5,7,9,2,2,2,1,1,1}; sort(a,a+11); int len = unique(a,a+11)-a; for(int i=0;i\u003clen;i++) cout\u003c\u003ca[i]\u003c\u003c\" \"; 输出结果为：1 2 3 5 7 9 传送门 ","date":"2018-06-14","objectID":"/posts/c-with-stl/:0:0","tags":["ACM","STL","C++"],"title":"C++ with STL","uri":"/posts/c-with-stl/"},{"categories":["Memo"],"content":" 2021/10/1 更新 使用 Chrome 等浏览器管理书签是更好更方便的方式，登陆 google 账号，或者导出 html 书签文件都挺方便。 我们在平时学习生活总会遇到很多很多有用的网站，也许我们收藏在了浏览器书签里，可过久了，不做说明，这些链接的价值就被时间淹没了，我们自己都记不起来了，所以这篇文章因此而生。对自己收藏的链接做些简单的说明（第一次编写用了我一个下午）；也相当于我的链接收藏夹，分享一些有趣的网站， 29 ACM 相关 链接 描述 各大 OJ 题目分类 各种算法分类，对应 OJ 题号超链接 ACM 题目分类 codeforces 俄国 CF 在线编程，一般比赛在晚上 9:30 和 11:00 牛客网 国内求职学习网，有很多程序设计比赛 vjudge 这个不用说了吧 hihocoder 打得少，感觉好多数据结构的题 百练 OpenJudge 的一个小组，很多题目来自 POJ；也是我 ACM 启蒙地 HDUOJ 杭州电子科技大学 OJ POJ 北京大学 OJ 洛谷 lintcode 领扣（国外） leedcode 力扣 codewar 国外 更多 OJ，在线刷题网站 … 30 编程，学习 链接 描述 visualgo 算法学习，数据结构和算法动态可视化 c,c++学习 很详细的知识讲解 Tomcat 下载 Tomcat 各版本下载，Tomcat 解压即安装；\\bin下可以启动和关闭服务器；可手动在\\webapps里创建 web 应用，也可以配合Eclisp IDE for Java EE Developers等 Java IDE 工具创建 w3school 可在线测试，Web 技术教程，HTML, 浏览器脚本，服务器脚本，xml 教程等 w3cschool 和上面不同哦，是不是和上面的很像哈哈哈！我估计是上一个网站的新版，功能更强大，内容更丰富，还有微信小程序教程等 菜鸟教程 和上面两个差不多，还有一些数据库、安卓的东西，git 学习 python 学习 Python 库安装包下载，python,Django,HTML,ACM 学习 python123 Python123 是专注于为中国高等院校教学 Python 语言的而开发的一款学习工具网站 python 学习 pypi Find, install and publish Python packages with the Python Package Index 优矿 python 在线测试，笔记 阮一峰的网络日志 开发者手册，JavaScript 等等 廖雪峰 git,python,javascript 学习 新晴网 PS 学习，摄影教程等 实验楼 在线做实验，高效学编程 慕课网 在线学习，免费，付费视频 wxpy 一个 python 关于微信的库 So1n python 学习 31 云服务及站长工具 链接 描述 腾讯云 dnspod 解析新版入口，腾讯云控制台 dnspod 解析 域名解析，其他：阿里云等 cloudflare 解析 域名解析，https 解析，介绍 cloud studio 这是腾讯云和 coding 合作后的一个东西，简单来说就是云端开发环境。试了一下完全可以把 hexo 博客源码挂上面编辑。这也就不用只局限于一台电脑发布博客了。 腾讯云大学开放实验室 可以在线进行一些云服务应用搭建等的实验。与之对应的还有阿里云开放实验室 宝塔面板 宝塔面板是一款使用方便、功能强大且终身免费的服务器管理软件，支持 Linux 与 Windows 系统。一键配置：LAMP/LNMP、网站、数据库、FTP、SSL，通过 Web 端轻松管理服务器。 leancloud 一站式后端云服务 daovoice 网站在线客服 百度网站收录 网站 seo Bing 站长 Bing 网站管理员工具 站长工具 网站信息查询，权重，seo，网站速度查询，ping 等 站长工具大全 各种 seo 优化，工具等 32 前端工具 链接 描述 全栈开发者 顾名思义，有很多 web 开发的教程，也可以在线执行代码 JSFuck JSFuck 是一种基于 JavaScript 原子部分的深奥教育编程风格。它只使用六个不同的字符来编写和执行代码。（代码极丑化） BootCDN 稳定、快速、免费的前端开源项目 CDN 加速服务，共收录了 3441 个前端开源项目。比如vue,fancybox等 bootstrap 中文网 简洁、直观、强悍的前端开发框架，让 web 开发更迅速、简单。还有一些基于 bootstrap 开发或扩充的项目的 cdn，BootCDN也是在该网站旗下 Font Awesome 图标库 hexo 指定图标库 iconfont 阿里巴巴矢量图标库 easyicon 图标库 图标下载，格式转换，可外链 semantic-ui.com 图标库 semantic-ui.com 还有很多前端样式对应代码 colorhunt 配色方案推荐，调试 grabient 渐变色 渐变色调色 gradient 渐变色调色 渐变色调色，获取代码 encycolorpedia encycolorpedia 取色器 优酷视频上传 获取视频外链，其他：腾讯视频 sm.ms 非常好用的图床 imgURL 一个开源的图床，很不错，有兴趣的可以自己尝试搭建，比如 img.lruihao.cn 现实君外链 支持多种文件外链，唯一不好的是 http PEXELS 美图 文章配图，无版权美图网，避免配图侵权 unsplash 美图 API 还可以获取 随机图 图标工厂 移动应用图标生成工具，一键生成所有尺寸的应用图标 emoji 在线复制 Simple emoji copy and paste HTML 字符实体 网页特殊符号大全 特效字转换工具集 各种特效字转换工具，彩虹字生成器，RGB 转 16 进制颜色等 压缩图 在线 ps，图片去底，证件照换底等操作很方便的 web 图片处理工具 改图宝 在线改图压缩，加水印，生成二维码，印章制作等 GIF 之家 一个压缩效果很好且免费的 gif 压缩工具 二维码解码器 草料二维码 https://cli.im 联图二维码 第九工厂 死磕艺术二维码 模板码 动态二维码等 33 实用工具 链接 描述 Gearn Git Branching 通过游戏闯关的方式学习 git！ PicGo 一个很好的开源的图床管理桌面程序，图床神器支持微博图床、七牛图床、腾讯云 COS、又拍云、GitHub 图床、阿里云 OSS、Imgur 图床等等 Proxyee Down 百度云下载解决方案，满速下载，但不限于百度云的下载，感觉比迅雷还好用！ PanDownload 这是 pandownload 网页版，把需要下载的百度网盘链接baidu改成baiduwp即可加速，也有桌面版。 ubuntu pastebin 代码展示托管，生成分享网址，防止代码直接分享缩进消失 图片转字符工具 Img–\u003eString everyfont 中文字库在线压缩 字蛛 font-spider 中文字库压缩 mdtr2pdf markdown 转 pdf AD’s API 包括动态签名，网易音乐等 在线工具 w3cschool 的在线工具集合 在线工具 开源中国社区 菜鸟工具 菜鸟教程 在线工具，编译，加密，压缩代码等 msdn windows 系统上 office 等软件下载（备用） 老殁科技 Adobe 等各种绿色破解软件 百度接口 百度搜索关键词接口 在线短信 不想泄露个人的电话号码，注册一些一次性网站可以用到 配音阁 文字转换语音/语音合成广告_叫卖录音_在线配音网络软件_促销宣传片配音 - 配音阁 - 配音阁，国内专业的广告配音平台 hacknical 在线个性简历，个人 Github 总结分析 34 其他 链接 描述 俄罗斯方块 这是一个开源的游戏，小白的我看来简直牛逼爆了，好逼真，刷新都不会打断游戏进度！！ 网址迷宫 nazo_game 一个程序员的网页游戏，我只玩到 12 关。 无损音乐下载 手写体制作 北京大学计算机科学技术研究所的一个项目59.108.48.27 （我的字体至今还未完成） 大象代理 收费，口碑不错 蒲公英 应用内测发布平台 35 博客文章 文章 概括 Web 笔记 记录一下自己 web 相关学习的笔记 Git 常用指令汇总 可能用到按需自查 hexo 插件及 next 内置样式集 让文章写的好看又简洁又好用的插件！hexo 更多请看分类 hexo-theme-next @modified LRH 对 next 主题的 DIY 设计记录日志 一款自己写的字体 - 沐目体 沐目体–release ","date":"2018-06-07","objectID":"/posts/links/:0:0","tags":["ACM"],"title":"各种 Links 汇总与分享","uri":"/posts/links/"},{"categories":["thoughts"],"content":"从此故乡只有冬夏，再无春秋。","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/","tags":["随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["thoughts"],"content":" 从此故乡只有冬夏，再无春秋。 时间急促得仿佛还在昨天，还没有清楚地认识到这句话的其中含义时，我早已离开它，远去。 自此，一江绿水东去，桃花竞开，春洒满园；瑟瑟秋风里，稻谷黄时，落木萧萧；故乡的春秋成为回忆尘封在我的脑海深处。 三月，这里和故乡一样雨下得缠绵，却尽带着他乡的味道。在不是滋润自己的那方水土上，哪怕是喜雨之人，亦只有料峭的寒意。雨下到这里才懂得，为何古来才子佳人逢阴雨连绵天总是带着一股莫名的惆怅。原是这般由头！我与他们，并无二般，想起故乡来。 故乡的春是在牛耕上的。太爷说，老牛伏在岸边饮水时节就是春耕了。到那时，耕牛头角披红挂彩，鼻挂铜色大铃，以祈愿今年平安，田地丰收；当耕牛喘着鼻息，缓缓地哞哞叫着走下田，是其在田地里大展身手的机会。故而，二月春耕总是会见到红布条装扮的水牛在田间劳作，彩带飘逸，好生招摇，尤其是农夫哼起那极具故乡气息的耕牛民歌，如高山流水般，伴着清脆的铜铃声隐隐飘去……在春末，三月桃花尽开，漫山望去，粉红红一片，甚是好看。小时看到总以为身处仙山，而后来，陶渊明一篇《桃花源记》就以为自己是那秦时避乱而住在桃花源中的后人。每每与外人谈起家乡的桃花山时，必然是一副神气十足的傲气样子。我想，这也是自己不知不觉中受家人影响，又倾心桃花的缘故吧。 印象中，家里人都爱这漫山遍野的桃花。太爷爱赏花，山上桃花开得极好的时候，便移栽了数株桃花留在了院子里，天好天坏，都能观赏上好一会儿。太婆还在的时候，桃花次第开，她就会拾掇许多桃花下来做成桃花糕，那桃花糕香香糯糯的味道飘散四周，总能把我馋来。后来，太婆故去，奶奶学着太婆开始做起了桃花糕，却总是没有太婆做的如意。但奶奶的桃花酒，受到父辈们的一致好评。每当酒坛从土里挖出，揭开红布，酒气便带着桃花的香甜扑鼻而来。父辈们在太爷种的桃花树下把酒话桑麻，颇有一副桃花坞里桃花庵，桃花庵里桃花仙的样子。现如今记忆远去，酒香却长留下来，记起时，那酒酣甜得喜人。 故乡的秋从九月农收渐起，那时候一家老小在浓浓的秋意里忙忙碌碌，直至十月方才得些许闲暇日子。 稻谷黄时，是秋最盛的时候。父辈们清晨便出发去地里收稻谷。晌午，我兴起与祖母前去送饭。正午的太阳烈得很，父辈们大颗大颗的汗直往下掉，稻谷机嘈杂得很。这才想起太爷教我的诗，“妇姑荷箪食，童稚携壶浆”，就是这样的情景无差。那时候不懂得父辈的辛苦，只知奔入山间，捕捉蚱蜢，蛐蛐等趣物。等傍晚将近，坐在板车谷袋上，兴尽而回，一天就算结束。渐渐长大，再也不敢胡闹，不知是童趣少了还是知了人事愈发迷惘了？ 窗外又下起雨，心里竟也惆怅起来。并非是洗过的衣服久晾未干，而是伴着那股湿意而来，藏在雨里的那点点乡愁。这边的桃花也开得好，往窗外，密密一片，不免想起了太爷书房里的书画：花是春时花，却非故乡花。人是故乡人，却是他乡客。所见时，不过是从戏子变成看客了罢。 ","date":"2018-06-03","objectID":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/:0:0","tags":["随笔"],"title":"戏子春秋","uri":"/posts/%E6%88%8F%E5%AD%90%E6%98%A5%E7%A7%8B/"},{"categories":["Memo"],"content":"更多关于 hexo 33 首先 官方文档 是我们的第一手资料，也是最好的。 安装 Hexo 相当简单。然而在安装前，你必须检查电脑中是否已安装下列应用程序： Node.js Git 34 hexo 安装 如果你的电脑中已经安装上述必备程序，那么恭喜你！接下来只需要使用 npm 即可完成 Hexo 的安装。 npm install -g hexo-cli 35 建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 hexo init \u003cfolder\u003e cd \u003cfolder\u003e npm install 为一个文件夹的名字 新建完成后，指定文件夹的目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes 36 安装 hexo 插件 全装上吧，没事。 npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked@0.2 --save npm install hexo-renderer-stylus@0.2 --save npm install hexo-generator-feed@1 --save npm install hexo-generator-sitemap@1 --save 37 本地查看效果 执行下面语句，执行完再登录 localhost:4000 查看效果（执行完不要按 Ctrl+C，不然就停止了） hexo g hexo s 其他步骤在这里不赘述，参见 超详细教程 安卓上搭建 hexo 博客 38 部署 hexo g -d 部署后我们可以浏览器搜 username.github.io 查看自己的博客效果，比如我的 lruihao.github.io 39 美化 这些美化都写的很详细，我建议你们自己好好看看吧，我也是在这里看到的，如果问我和这里说的是一样的。 hexo 个性化教程 valine 特别鸣谢赵俊 👍 asdfv1929 hexo 官方主题集合，我用的是 aloha 主题，该主题 官方文档，后改用 next 主题 next 主题 hexo 官方插件 说说我的主题遇到的一些问题，由于这个主题用的人少，所以作者优化的不是很好（next 使用最多），当然也可以反过来说，所以自己美化了一点 39.1 博文置顶 修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为： 'use strict'; var pagination = require('hexo-pagination'); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top \u0026\u0026 b.top) { // 两篇文章 top 都有定义 if(a.top == b.top) return b.date - a.date; // 若 top 值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照 top 值降序排 } else if(a.top \u0026\u0026 !b.top) { // 以下是只有一篇文章 top 有定义，那么将有 top 的排在前面（这里用异或操作居然不行 233） return -1; } else if(!a.top \u0026\u0026 b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, { perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: { __index: true } }); }; 39.2 about 页面 about 页面可以用 HTML 写，你想怎么写都行，我用的最简单的方法，直接hexo n page \"about\"后，会生成一个 md 文件，也就是后面说的文章，直接写文章就行了。 39.3 添加搜索，评论，分享 搜索功能真心好用，当文章多起来的时候，标签提供的作用已经很少了，只能简单索引，搜索却能精确查找，这里我用的依旧是最简单的本地站内搜索。 安装hexo-generator-searchdb 在站点的根目录下执行以下命令： npm install hexo-generator-searchdb --save 配置站点配置文件 新增以下内容到任意位置： search: path: search.xml field: post format: html limit: 10000 配置主题配置文件 ## Local search local_search: enable: true algolia 参考文件 让搜索引擎找到你的博客，还是看到邱承佳学长博文有写到 传送门 39.4 添加访客数，阅读量等 评论有多说（多说好像挂了），计数有不蒜，我用的不蒜子，还有其他的。 39.4.1 文章阅读量 以下适合非 next 主题的部分主题，next 主题已经自带，到主题配置文件修改就好了。 打开以下路径在你喜欢的地方添加代码，\\blog\\hexo\\themes\\主题名字、layout\\_partial，找到 article.ejs文件 \u003cdiv align=\"left\"\u003e \u003cspan id=\"busuanzi_container_page_pv\"\u003e 本文总阅读量\u003cspan id=\"busuanzi_value_page_pv\"\u003e\u003c/span\u003e次 \u003c/span\u003e \u003c/div\u003e 39.4.2 站点访问量，访客数 打开以下路径在你喜欢的地方添加代码，\\blog\\hexo\\themes\\主题名字、layout\\_partial，找到 footer.ejs文件 \u003cscript src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\" async defer\u003e\u003c/script\u003e \u003cspan id=\"busuanzi_container_page_pv\"\u003e 本站总访问量\u003cspan id=\"busuanzi_value_site_pv\"\u003e\u003c/span\u003e次 | \u003c/span\u003e \u003cspan id=\"busuanzi_container_site_uv\"\u003e 本站访客数\u003cspan id=\"busuanzi_value_site_uv\"\u003e\u003c/span\u003e人次 \u003c/span\u003e 2018.10.08 更新 不蒜子官网说七牛强制过期域名dn-lbstatics.qbox.me, 所以 js 文件位置发生改变，改为busuanzi.ibruce.info 40 写文章 hexo 文章用轻量型标签语言 Markdown 编写 markdown 入门 繁体原始文件 繁体原始文件 github ","date":"2018-06-01","objectID":"/posts/hexobuild/:0:0","tags":["Hexo","Node.js"],"title":"hexo+github 搭建个人博客及美化","uri":"/posts/hexobuild/"},{"categories":["Memo"],"content":" 如果实在搞得头晕直接去 简书 写文章，再把简书生成的 md 文章复制过来就好了（简书是个不错的 Markdown 在线编辑器），还可以去 马克飞象，专为印象笔记打造的 Markdown 编辑器，typora 也是不错的，突然发现 csdn 也支持 Markdown 编译器了 1 1. 首先 刚刚搭博客，很多都不懂，就连插入图片的路径问题都把我整的要命。（我用的 Sublime Text 3 编译器） 下面讲讲： 1.1 1.1 设置站点配置_config.yml post_asset_folder: true 1.2 1.2 安装插件 npm install https://github.com/CodeFalling/hexo-asset-image -- save 1.3 1.3 下次再运行 hexo n “xxxx\"来生成 md 博文时，下路径 /source/_posts 文件夹内除了 xxxx.md 文件还有一个同名的文件夹，在 xxxx.md 中想引入图片时，先把图片复制到 xxxx 这个文件夹中，然后只需要在 xxxx.md 中按照 markdown 的格式引入图片。 2 2. 添加图片 首先大家可以查看 hexo 官方文档 资源文件夹章节 2.1 2.1 markdown 添加 相对路径添加（我被这个相对路径搞得要死，前面各种出错，大家可以对照我的来插入图片 …） #直接写图片名就好了，图片实例见下 ![kyrie irving](294136.jpg) #如果改了 Permalink 就要加上文章名，即同名文件夹名 ![kyrie irving](hexo-添加图片，音乐，链接，视频/294136.jpg) #代码压缩后前面还要加一个/ ![kyrie irving](/hexo-添加图片，音乐，链接，视频/294136.jpg) 2.2 2.2 插件添加 传送门 这种方式被很多人诟病，但有时候也不失一种好方式，简单快捷。 还有图片名字显示，不错的。 {% asset_img 297787.jpg kyrie irving %} 3 3. 音乐 大家可以看 网易云音乐 的官网，播放音乐可以生成外链，直接拿来用就行了。iframe 插件可以在代码中设置宽高等参数，auto 为自动播放。flash 不可以自己设置参数。看喜好，随便你。 其他音乐，把插件中的链接替换成要播放的链接就可以了 #iframe 插件 \u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2\u0026id=66651\u0026auto=0\u0026height=66\"\u003e \u003c/iframe\u003e #flash 插件 \u003cembed src=\"//music.163.com/style/swf/widget.swf?sid=40249713\u0026type=2\u0026auto=0\u0026width=320\u0026height=66\" width=\"340\" height=\"86\" allowNetworking=\"all\"\u003e \u003c/embed\u003e 4 4. 添加链接 [我的微博](https://weibo.com/liahao) {% link text url title %} 5 5. 添加视频 视频链接最好是打开就是视频的链接（youku，YouTube，抖音等） 可以把视频上传到优酷，抖音等生成外链再拿来用。（优酷上传需要注册和实名认证） 插件参考资料 自拍手写视频（优酷） 实验室无聊拍的 \u003ciframe height=500 width=100% src=\"https://player.youku.com/embed/XMzY0MzgxNDMyOA==\" frameborder=0 allowfullscreen\u003e \u003c/iframe\u003e 6 工具集合 Picgo 马克飞象、CSDN、简书 SM.MS 图床 ","date":"2018-05-31","objectID":"/posts/hexowrite/:0:0","tags":["Hexo"],"title":"hexo 添加图片，音乐，链接，视频","uri":"/posts/hexowrite/"},{"categories":["thoughts"],"content":"一直觉得中国古代神话 能称得上传奇的只有两个人物： 一是猴子 一是哪吒 百世蕴灵育出只石猴 大闹天宫腾云驾雾 三年怀胎生了个哪吒 东海屠龙翻江倒海 可以说 除了这两人 没人再能当得起离经放纵四个字的 但称得上悲剧的 约摸也只有这两个 一个五行山下压五百年 揭了封印 戴上金箍无悲无喜 拜佛西天 唤孙悟空 一个削肉还母剔骨还父 塑了莲身 站上火轮无怨无恨 封神南门 号三太子 这尘世最擅长的事 大抵就是抹杀疏狂者的落拓 磨平豪纵者的傲骨 斩灭叛世者的孤妄 ","date":"2018-05-31","objectID":"/posts/%E7%8C%B4%E5%AD%90%E4%B8%8E%E5%93%AA%E5%90%92/:0:0","tags":["随笔"],"title":"猴子与哪吒","uri":"/posts/%E7%8C%B4%E5%AD%90%E4%B8%8E%E5%93%AA%E5%90%92/"},{"categories":["GitHub"],"content":"Lruihao/lruihao.github.io: 博客构建档（HTML \u0026 Markdown）","date":"2018-05-28","objectID":"/projects/lruihao/lruihao.github.io/","tags":["acm","backend","blog","frontend","hexo","hexo-theme-next","hugo","hugo-fixit","java","javascript","php","python","study-notes","summary","web-development"],"title":"博客构建档（HTML \u0026 Markdown）","uri":"/projects/lruihao/lruihao.github.io/"},{"categories":["GitHub"],"content":"菠菜眾長 Hugo FixIt 作者，喜欢瞎折腾、造轮子、写东西，分享一些前端开发中的所见、所闻、所思。 共计 292 篇文章 by Lruihao. 2025 共计 9 篇文章 08-04 Code Playground 07-22 A custom web component that embeds caniuse.com browser compatibility data for a specific feature. 06-18 CSS @layer：构建更高效、更可维护的样式层级 06-11 Vue.js History 模式下的 NGINX 配置与 API 代理 04-10 The webfont package for the MMT typeface. 04-09 API proxies powered by Vercel. 01-20 CSS Flexbox 布局指南 01-14 Generate a list of all hugo-fixit theme components. 01-08 A Hugo theme component with asciinema-embed shortcode. 2024 共计 38 篇文章 12-06 震惊！CSS 竟然能获取视口尺寸？ 12-02 🌐 A component for site automatic translation. 11-22 Amazon 如何让服务器享受着持续集群安全？ 11-05 🐟 A canvas implemented animation effect of small fish swimming. 10-06 自动获取 GitHub README 内容添加到 Hugo 文章 09-13 不使用任何框架，只使用原生 HTML、CSS 和 JavaScript 的一些小 demo。 09-04 ⚙️ Versioning, change-log and release. 08-22 Hugo theme component for ATOM feed custom Output Format. 08-22 Hugo theme component for JSON feed custom Output Format. 08-07 Mobile devtools component powered by vConsole and eruda. 07-29 现代 CSS 解决方案：CSS 四舍五入数值单位 07-21 A Hugo theme component with reward-log or sponsor-log shortcode. 07-17 Git 统计代码量 07-15 现代 CSS 解决方案之异形元素怎么设置阴影？ 07-14 🔖 Embed bookmark of FixIt Docs. 07-14 CSS 实现时间轴、背景图 loading 和渐变边框 07-07 探索 Amazon S3 的无限存储潜力 06-28 标准滚动条控制规范 06-28 A Hugo theme component with caniuse shortcode. 06-13 如何实现 VSCode 编辑器窗口边界拖拽类似功能 06-09 架构之基：从根儿上了解设计原则 06-06 怎么生成暗黑模式和明亮模式的 SVG 图片？ 05-20 坐高铁去柳州吃螺狮粉 04-17 利用 Vercel 反代 Gravatar 实现镜像加速 04-17 Gravatar Proxy powered by Vercel. 04-09 🐙 Display your GitHub projects in the FixIt theme and generate blog posts from readme. 04-04 临时决定再写一个小工具 - 网站预览图生成器 04-02 用五天时间给自己制作一个封面图生成工具 03-28 🛠 Create awesome cover images for your blog posts quickly. 03-26 写文档时英文标题什么时候要大写？ 02-29 实现类似于 Element UI 表格的溢出文本提示功能 02-21 聊聊 Chrome 新增的 sizes=“auto” 属性 02-09 2023 年度总结 01-21 强大的脑图可视化工具 01-17 记一次 Debug 第三方包的过程 01-17 为什么很多教程中都有 foo bar？ 01-11 git submodule: already exists in the index 01-10 给 el-card 添加折叠功能 2023 共计 35 篇文章 12-22 尝试在 Python 中使用 Amazon Titan 文本模型 11-28 用 Node.js 开发一个轻量脚手架 11-20 🛠️ A node-based tooling for FixIt site initialization. 11-18 探索 AWS 云上一站式解决方案免费使用 10-22 SSH 提交签名验证 10-12 如何给 npm 包打补丁？ 10-12 拖拽式仪表盘系列总结 10-12 拖拽式仪表盘 - 组件开发 10-12 拖拽式仪表盘 - 模板使用 10-12 拖拽式仪表盘 - 组件配置文档 10-12 拖拽式仪表盘 - 布局模板文档 10-12 拖拽式仪表盘 - 功能需求分析 10-11 给你的 Markdown 挑挑刺 10-08 认知复杂度（Cognitive Complexity） 09-26 写作技巧：如何搭建文章的框架结构？ 09-25 如何让 Element UI 表头、表尾、横向滚动条吸顶吸底固定？ 09-17 封装 Vue FullScreenToggler 组件 09-15 JS 实现全屏和退出全屏 09-15 中文翻译的常见问题 09-14 在 Vue 项目中更优雅地使用 icon 09-14 VSCode 添加用户代码片段，自定义用户代码片段 09-02 CSS 如何实现网格背景效果？ 08-26 将 Hugo 博客部署到亚马逊云服务器 08-08 Vue2 and element-ui related demos 07-20 用魔法打败魔法 - ElBacktop Fix 06-14 A plugin includes a set of directives to make the header, footer and horizontal scrollbar sticky or make highly adaptive of Element UI (Vue 2) tables. 06-14 使用 Node.js 自动创建 Vue 的路由 06-12 解决 SourceTree 提交时候 husky 命令失败问题 06-03 Vue2 + tailwindcss 初始化 03-14 新手向：Vue 2.0 的建议学习顺序 02-28 🎶 A Hugo theme component with a NetEase Cloud random comment shortcode. 02-12 浏览器 IMG 图片原生懒加载 loading=“lazy” 02-05 浏览器渲染原理 02-04 中文技术文档的写作规范 01-11 浏览器原理 - 事件循环 2022 共计 21 篇文章 12-17 2022 年度总结 12-15 安装 Homebrew 后导致系统中原有的 npm 和 npx 失效 12-09 基于 Bootstrap 5 + Font Awesome 6 的消息提示插件 10-10 基于 fex-team/kityminder-core 和 Vue2 封装的在线脑图编辑组件 09-30 🆕 A quick-start template base on Hugo Modules to create a Hugo FixIt site. 09-27 🆕 A quick-start template base on Git submodule to create a Hugo FixIt site. 09-04 Using frequently-used Hugo commands by shell. 08-31 Beego 安装及配置 08-13 语义版本控制（SemVer） 08-12 Commit Message Spec 08-12 electron 踩坑总结 08-08 前端页面内容加密总结 08-07 Node.js + GitHub Actions 自动刷新 CDN 08-07 不同系统的换行符的差异 07-31 自定义 ohmyzsh 主题 07-30 linux 文件权限 07-29 Mac 上的开发配置总结 07-23 📄 The open-source repo for fixit.lruihao.cn 07-05 Mac 配置 ADB 05-01 重新认识 JavaScript 04-30 关于 CSS 和 Scss 变量运算那些事 2021 共计 19 篇文章 12-22 Getting Things Done for ios App Reminders and Github issues 12-16 🔧 A clean, elegant but advanced blog theme for Hugo 一个简洁、优雅且高效的","date":"2018-05-28","objectID":"/projects/lruihao/lruihao.github.io/:0:0","tags":["acm","backend","blog","frontend","hexo","hexo-theme-next","hugo","hugo-fixit","java","javascript","php","python","study-notes","summary","web-development"],"title":"博客构建档（HTML \u0026 Markdown）","uri":"/projects/lruihao/lruihao.github.io/"},{"categories":["thoughts"],"content":" “每天早晨叫醒你的不是鬧鐘，而是你的夢想。” 我有過靠著這種信念撐下來的日子，我見過自己努力的樣子，至於現在的自己配不配得上當初努力的自己， 其實也不重要了，還望披荊斬棘，不改初心。 不怕萬人阻擋，只怕自己投降。你如何回憶，決定你是一個怎樣的人！ 從大一伊始，打 ACM 比賽，訓練刷題，再到毅然決然離開實驗室，選擇陌生的 Web 開發，從工作前的一無所知到，到前端開發，後端開發，到教實習生，到面試新人，到開始乏味。這一路走來，好奇心，探索欲，瞎擇騰，或許還有愛意，都是支撐我的動力。 時間並不會因為你的迷茫和遲疑而停留，就像你在看到這篇博客的時候，不知道有多少人正風雨兼程趕赴夢想。沒有誰生來就是神牛，千裏之行，始於足下！比自己優秀的人有很多，永遠不要感動自己，保持謙遜，沉澱自己，感謝每一個曾經努力的自己。不必執著於過去，也不必過度擔憂未來，望披荊斬棘，不忘初心。 最開始寫博客，是在打 ACM 的時候，深受一個學長的博客影響，他的博客是 hexo 搭建的，ID 是 [戎碼一生]，所以我也照葫蘆畫瓢用 hexo 搭建了一個，一用就是 3 年，博客名字原“博採眾長”改为“菠菜眾長”，因為不能用成語作為網站名字，就這個原因。 直到 21 年下半年，升級 Windows 11, 系統出了 BUG, 整理磁盤不小心把代碼刪掉了，就乾脆換成 hugo 了。 逝者如斯乎，不舍昼夜 ","date":"2018-05-28","objectID":"/posts/hello-world/:0:0","tags":["随笔"],"title":"Hello World","uri":"/posts/hello-world/"}]