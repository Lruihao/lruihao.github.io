<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>认知复杂度（Cognitive Complexity） | 菠菜眾長</title><meta name=author content="Lruihao"><meta name=description content="1 摘要 循环复杂度（Cyclomatic Complexity）最初被制定为衡量模块控制流的“可测试性和可维护性”的一种度量标准。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。
1.1 术语说明 虽然认知复杂度（Cognitive Complexity）是一种语言中立的度量标准，同样适用于文件和类，以及方法、过程、函数等等，但为了方便起见，本文中使用面向对象的术语“类”和“方法”。
"><meta name=keywords content='李瑞豪,李瑞豪的博客,菠菜眾長,博採眾長,Lruihao,Cell,Hugo FixIt'><meta itemprop=name content="认知复杂度（Cognitive Complexity）"><meta itemprop=description content="1 摘要 循环复杂度（Cyclomatic Complexity）最初被制定为衡量模块控制流的“可测试性和可维护性”的一种度量标准。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。
1.1 术语说明 虽然认知复杂度（Cognitive Complexity）是一种语言中立的度量标准，同样适用于文件和类，以及方法、过程、函数等等，但为了方便起见，本文中使用面向对象的术语“类”和“方法”。"><meta itemprop=datePublished content="2023-10-08T09:52:44+08:00"><meta itemprop=dateModified content="2023-11-17T20:39:48+08:00"><meta itemprop=wordCount content="5604"><meta itemprop=image content="https://lruihao.cn/posts/cognitive-complexity/images/featured-image.png"><meta itemprop=keywords content="程序猿的自我修养,翻译"><meta property="og:url" content="https://lruihao.cn/posts/cognitive-complexity/"><meta property="og:site_name" content="菠菜眾長"><meta property="og:title" content="认知复杂度（Cognitive Complexity）"><meta property="og:description" content="1 摘要 循环复杂度（Cyclomatic Complexity）最初被制定为衡量模块控制流的“可测试性和可维护性”的一种度量标准。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。
1.1 术语说明 虽然认知复杂度（Cognitive Complexity）是一种语言中立的度量标准，同样适用于文件和类，以及方法、过程、函数等等，但为了方便起见，本文中使用面向对象的术语“类”和“方法”。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-10-08T09:52:44+08:00"><meta property="article:modified_time" content="2023-11-17T20:39:48+08:00"><meta property="og:image" content="https://lruihao.cn/posts/cognitive-complexity/images/featured-image.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lruihao.cn/posts/cognitive-complexity/images/featured-image.png"><meta name=twitter:title content="认知复杂度（Cognitive Complexity）"><meta name=twitter:description content="1 摘要 循环复杂度（Cyclomatic Complexity）最初被制定为衡量模块控制流的“可测试性和可维护性”的一种度量标准。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。
1.1 术语说明 虽然认知复杂度（Cognitive Complexity）是一种语言中立的度量标准，同样适用于文件和类，以及方法、过程、函数等等，但为了方便起见，本文中使用面向对象的术语“类”和“方法”。"><meta name=application-name content="菠菜眾長"><meta name=apple-mobile-web-app-title content="菠菜眾長"><meta name=theme-color data-light=#ffffff data-dark=#252627 content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical type=text/html href=https://lruihao.cn/posts/cognitive-complexity/ title="认知复杂度（Cognitive Complexity） | 菠菜眾長"><link rel=prev type=text/html href=https://lruihao.cn/posts/article-structure/ title=写作技巧：如何搭建文章的框架结构？><link rel=next type=text/html href=https://lruihao.cn/posts/markdownlint/ title="给你的 Markdown 挑挑刺"><link rel=alternate type=text/markdown href=https://lruihao.cn/posts/cognitive-complexity/index.md title="认知复杂度（Cognitive Complexity） | 菠菜眾長"><link rel=stylesheet href=/css/config.min.css><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://unpkg.com/@fortawesome/fontawesome-free@6.7.1/css/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/@fortawesome/fontawesome-free@6.7.1/css/all.min.css></noscript><link rel=preload href=https://unpkg.com/animate.css@4.1.1/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://unpkg.com/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"认知复杂度（Cognitive Complexity）","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/lruihao.cn\/posts\/cognitive-complexity\/"},"image":[{"@type":"ImageObject","url":"https:\/\/lruihao.cn\/posts\/cognitive-complexity\/images\/featured-image.png","width":1940,"height":1298}],"genre":"posts","wordcount":5604,"url":"https:\/\/lruihao.cn\/posts\/cognitive-complexity\/","datePublished":"2023-10-08T09:52:44+08:00","dateModified":"2023-11-17T20:39:48+08:00","license":"本站内容采用 CC BY-NC-SA 4.0 国际许可协议。","publisher":{"@type":"Organization","name":"Lruihao","logo":"https:\/\/lruihao.cn\/images\/avatar.jpg"},"author":{"@type":"Person","name":"Lruihao"},"description":""}</script><script src=/js/head/color-scheme.min.js></script></head><body data-instant-intensity=viewport data-header-desktop=sticky data-header-mobile=auto><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper data-github-corner=right><div class=header-title><a href=/ title=菠菜眾長><img class=logo src=/logo.webp alt=菠菜眾長 height=32 width=32><span class=header-title-text>菠菜众长</span></a><span class=header-subtitle>李瑞豪的博客</span></div><nav><ul class=menu><li class="menu-item has-children"><a class=menu-link href=/archives/><i class="fa-solid fa-feather fa-fw fa-sm" aria-hidden=true></i> 文章</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class=menu-item-divider aria-hidden=true></li><li class=menu-item><a class=menu-link href=https://fixit.lruihao.cn/ title="FixIt 官网" rel="noopener noreferrer" target=_blank><img class=fixit-icon src=https://fixit.lruihao.cn/images/hugo-fixit.webp alt="FixIt logo"> FixIt <i class="fa-solid fa-external-link-alt fa-fw fa-xs text-secondary"></i></a></li></ul></li><li class=menu-item><a class=menu-link href=/projects/ title=开源项目><i class="fa-solid fa-lightbulb fa-shake fa-fw fa-sm" aria-hidden=true></i> 开源</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/reward/><i class="fa-solid fa-hand-holding-dollar fa-fw fa-sm" aria-hidden=true></i> 赞赏</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comment-dots fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><a class=menu-link href=/index.xml title="通过 RSS 订阅"><i class="fa-solid fa-rss fa-fw fa-sm" aria-hidden=true></i> RSS</a></li><li class="menu-item has-children"><a class=menu-link href=/about/><i class="fa-solid fa-quote-left fa-fw fa-sm" aria-hidden=true></i> 关于</a><i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i><ul class=sub-menu><li class=menu-item><a class=menu-link href=/years/ title=我的年度总结><i class="fa-regular fa-newspaper fa-fw fa-sm" aria-hidden=true></i> 年度总结</a></li></ul></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li><li class="menu-item language-switch auto d-none" aria-hidden=true><span role=button aria-label=选择语言 title=选择语言><i class="fa-solid fa-language fa-fw" aria-hidden=true></i></span><ul class=sub-menu><li class="menu-item active" data-type=artificial><a href=/posts/cognitive-complexity/ data-lang=zh-CN class="menu-link text-secondary" title=简体中文><i class="fa-solid fa-person fa-fw fa-sm" aria-hidden=true></i> 简体中文</a></li><li class=menu-item-divider aria-hidden=true></li><li class=menu-item data-type=machine><a data-lang=chinese_simplified class=menu-link title=简体中文><i class="fa-solid fa-robot fa-fw fa-sm" aria-hidden=true></i> 简体中文</a></li><li class=menu-item data-type=machine><a data-lang=chinese_traditional class=menu-link title=繁體中文><i class="fa-solid fa-robot fa-fw fa-sm" aria-hidden=true></i> 繁體中文</a></li></ul></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=菠菜眾長><img class=logo src=/logo.webp alt=菠菜眾長 height=26 width=26><span class=header-title-text>菠菜众长</span></a><span class=header-subtitle>李瑞豪的博客</span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/archives/><i class="fa-solid fa-feather fa-fw fa-sm" aria-hidden=true></i> 文章</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/categories/><i class="fa-solid fa-folder-tree fa-fw fa-sm" aria-hidden=true></i> 分类</a></li><li class=menu-item><a class=menu-link href=/collections/><i class="fa-solid fa-layer-group fa-fw fa-sm" aria-hidden=true></i> 合集</a></li><li class=menu-item><a class=menu-link href=/tags/><i class="fa-solid fa-tags fa-fw fa-sm" aria-hidden=true></i> 标签</a></li><li class="menu-item menu-item-divider" aria-hidden=true></li><li class=menu-item><a class=menu-link href=https://fixit.lruihao.cn/ title="FixIt 官网" rel="noopener noreferrer" target=_blank><img class=fixit-icon src=https://fixit.lruihao.cn/images/hugo-fixit.webp alt="FixIt logo"> FixIt <i class="fa-solid fa-external-link-alt fa-fw fa-xs text-secondary"></i></a></li></ul></li><li class=menu-item><a class=menu-link href=/projects/ title=开源项目><i class="fa-solid fa-lightbulb fa-shake fa-fw fa-sm" aria-hidden=true></i> 开源</a></li><li class=menu-item><a class=menu-link href=/friends/ title=友情链接><i class="fa-solid fa-users fa-fw fa-sm" aria-hidden=true></i> 友链</a></li><li class=menu-item><a class=menu-link href=/reward/><i class="fa-solid fa-hand-holding-dollar fa-fw fa-sm" aria-hidden=true></i> 赞赏</a></li><li class=menu-item><a class=menu-link href=/guestbook/><i class="fa-solid fa-comment-dots fa-fw fa-sm" aria-hidden=true></i> 留言</a></li><li class=menu-item><span class=nested-item><a class=menu-link href=/about/><i class="fa-solid fa-quote-left fa-fw fa-sm" aria-hidden=true></i> 关于</a>
<i class="dropdown-icon fa-solid fa-chevron-right" aria-hidden=true></i></span><ul class=sub-menu><li class=menu-item><a class=menu-link href=/years/ title=我的年度总结><i class="fa-regular fa-newspaper fa-fw fa-sm" aria-hidden=true></i> 年度总结</a></li></ul></li><li class="menu-item text-center"><a class=menu-link href=https://github.com/Lruihao/ rel="noopener noreferrer" target=_blank><i class="fa-brands fa-github fa-lg fa-fw fa-sm" aria-hidden=true></i> 关注 Follow</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span><span id=translate class="menu-system-item language-switch auto d-none" aria-hidden=true>
<span role=button aria-label=选择语言 title=选择语言 data-current=简体中文>简体中文<i class="dropdown-icon fa-solid fa-chevron-down" aria-hidden=true></i></span></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class="breadcrumb-container sticky"><ol class=breadcrumb><li class=breadcrumb-item data-separator=/><a href=/posts/ title=Posts>文章</a></li><li class="breadcrumb-item active" data-separator=/ aria-current=page>认知复杂度（Cognitive Complexity）</li></ol></nav><main class=fi-container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=合集><div class=aside-custom><img src=/images/wxmp.webp alt=微信公众号 width=100%></div></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>认知复杂度（Cognitive Complexity）</span></h1><p class="single-subtitle animate__animated animate__fadeIn">一种衡量可理解性的新方式</p></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/Lruihao title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img class=avatar src='https://gravatar.loli.net/avatar/fee47a2f4f2cc71f99a02b0a73ecfee0?s=32&d=mp' alt=Lruihao height=16 width=16>&nbsp;Lruihao</a></span><span class=post-included-in>&nbsp;收录于 <a href=/categories/spec/ class=post-category title="分类 - 程序猿的自我修养"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 程序猿的自我修养</a>&ensp;<a href=/categories/%E7%BF%BB%E8%AF%91/ class=post-category title="分类 - 翻译"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> 翻译</a></span></div><div class=post-meta-line><span title="发布于 2023-10-08 09:52:44"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2023-10-08>2023-10-08</time></span>&nbsp;<span title="更新于 2023-11-17 20:39:48"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2023-11-17>2023-11-17</time></span>&nbsp;<span title="5604 字"><i class="fa-solid fa-pencil-alt fa-fw me-1" aria-hidden=true></i>约 5700 字</span>&nbsp;<span><i class="fa-regular fa-clock fa-fw me-1" aria-hidden=true></i>预计阅读 12 分钟</span>&nbsp;<span id=busuanzi_container_page_pv class="busuanzi_visitors comment-visitors" data-flag-title="认知复杂度（Cognitive Complexity）"><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_page_pv>-</span>&nbsp;次阅读
</span>&nbsp;</div></div><div class=featured-image><img src=/posts/cognitive-complexity/images/featured-image.png alt=/posts/cognitive-complexity/images/featured-image.png></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#摘要>摘要</a><ol><li><a href=#术语说明>术语说明</a></li></ol></li><li><a href=#引言>引言</a></li><li><a href=#问题示例>问题示例</a></li><li><a href=#基本准则和方法>基本准则和方法</a></li><li><a href=#忽略简写>忽略简写</a></li><li><a href=#中断线性流程>中断线性流程</a><ol><li><a href=#捕获catches>捕获（Catches）</a></li><li><a href=#开关switches>开关（Switches）</a></li><li><a href=#逻辑运算符序列sequences-of-logical-operators>逻辑运算符序列（Sequences of logical operators）</a></li><li><a href=#递归recursion>递归（Recursion）</a></li><li><a href=#跳转到标签jumps-to-labels>跳转到标签（Jumps to labels）</a></li></ol></li><li><a href=#嵌套流程中的增量>嵌套流程中的增量</a></li><li><a href=#影响>影响</a><ol><li><a href=#直观地正确的复杂性分数>直观地“正确”的复杂性分数</a></li><li><a href=#高于方法级别的有价值的指标>高于方法级别的有价值的指标</a></li></ol></li><li><a href=#结论>结论</a></li><li><a href=#参考文献>参考文献</a></li><li><a href=#附录-a补偿用法>附录 A：补偿用法</a><ol><li><a href=#cobol-missing-else-if>COBOL: Missing <code>else if</code></a></li><li><a href=#javascript-missing-class-structures>JavaScript: Missing class structures</a></li><li><a href=#python-decorators>Python: Decorators</a></li></ol></li><li><a href=#附录-b规范>附录 B：规范</a><ol><li><a href=#b1-增量increments>B1. 增量（Increments）</a></li><li><a href=#b2-嵌套级别nesting-level>B2. 嵌套级别（Nesting level）</a></li><li><a href=#b3-嵌套增量nesting-increments>B3. 嵌套增量（Nesting increments）</a></li></ol></li><li><a href=#附录-c示例>附录 C：示例</a></li></ol></nav></div></div><div class=content id=content data-end-flag="「本文完，更多内容汇总在我的 GitHub，持续更新，求关注、求 star、求订阅！」"><div class="expiration-reminder details admonition warning open"><div class="details-summary admonition-title"><i class="icon fa-solid fa-exclamation-triangle fa-fw" aria-hidden=true></i>警告<i class="details-icon fa-solid fa-angle-right fa-fw" aria-hidden=true></i></div><div class=details-content><div class=admonition-content>本文最后更新于 2023-11-17，文中内容可能已过时。</div></div></div><h2 class=heading-element id=摘要><span>1 摘要</span>
<a href=#%e6%91%98%e8%a6%81 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>循环复杂度（Cyclomatic Complexity）最初被制定为衡量模块控制流的“可测试性和可维护性”的一种度量标准。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。</p><h3 class=heading-element id=术语说明><span>1.1 术语说明</span>
<a href=#%e6%9c%af%e8%af%ad%e8%af%b4%e6%98%8e class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>虽然认知复杂度（Cognitive Complexity）是一种语言中立的度量标准，同样适用于文件和类，以及方法、过程、函数等等，但为了方便起见，本文中使用面向对象的术语“类”和“方法”。</p><hr><h2 class=heading-element id=引言><span>2 引言</span>
<a href=#%e5%bc%95%e8%a8%80 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>循环复杂度（Cyclomatic Complexity）是一种用于衡量代码中控制流的度量标准，它最初是由 Thomas J. McCabe 在 1976 年提出的。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> 该度量标准的目的是衡量代码的“可测试性和可维护性”。虽然它在衡量前者方面表现出色，但其底层的数学模型在产生衡量后者的值方面不尽如人意。本文介绍了一种新的度量标准，它摒弃了使用数学模型评估代码的做法，以弥补循环复杂度的不足之处，并产生更准确地反映方法、类和应用程序的相对难度的度量标准。</p><p>与此同时，循环复杂度已经不再全面。它于 1976 年在 Fortran 环境中制定，不包括像 <code>try/catch</code> 和 <code>lambda</code> 这样的现代语言结构。</p><p>最后，由于每个方法的最小循环复杂度分数为 1，我们无法知道具有高聚合循环复杂度的任何给定类是一个大型、易于维护的域类，还是一个具有复杂控制流的小型类。除了类级别之外，广泛认可的观点是应用程序的循环复杂度得分与其代码行数总和相关。换句话说，循环复杂度在方法级别以上几乎没有用处。</p><p>为了解决这些问题，认知复杂度（Cognitive Complexity）已经被制定出来，以解决现代语言结构的问题，并产生在类和应用程序级别上有意义的值。更重要的是，它摒弃了基于数学模型评估代码的做法，以便能够提供与程序员对理解流程所需的心智或认知努力的直觉相符的控制流评估。</p><h2 class=heading-element id=问题示例><span>3 问题示例</span>
<a href=#%e9%97%ae%e9%a2%98%e7%a4%ba%e4%be%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>从一个示例开始讨论认知复杂度可以帮助理解它的应用对象。下面的两个方法具有相同的循环复杂度，但在可理解性方面却存在明显的差异。</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696818696.png title="An illustration of the problem" data-thumbnail=/posts/cognitive-complexity/images/23_1696818696.png data-sub-html="<h2>An illustration of the problem</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696818696.png alt="An illustration of the problem" height=428 width=1476></a></p><p>循环复杂度的数学模型给予这两个方法相同的权重，然而直观上很明显，sumOfPrimes 方法的控制流比 getWords 方法更难理解。这就是为什么认知复杂度放弃了使用数学模型评估控制流的做法，而采用了一组简单的规则，将程序员的直觉转化为数字。</p><h2 class=heading-element id=基本准则和方法><span>4 基本准则和方法</span>
<a href=#%e5%9f%ba%e6%9c%ac%e5%87%86%e5%88%99%e5%92%8c%e6%96%b9%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>根据三个基本规则来评估认知复杂度得分：</p><ol><li>忽略允许多个语句可读性缩写成一个的结构</li><li>每次中断代码的线性流程时增加一个（加一）</li><li>嵌套时进行增量计算</li></ol><dl><dt>此外，复杂度得分由四种不同类型的增量组成：</dt><dd>A. 嵌套（Nesting）— 对嵌套控制流结构进行评估</dd><dd>B. 结构（Structural）— 对受嵌套增量影响并增加嵌套计数的控制流结构进行评估</dd><dd>C. 基础（Fundamental）— 对不受嵌套增量影响的语句进行评估</dd><dd>D. 混合（Hybrid）— 对不受嵌套增量影响的控制流结构进行评估</dd></dl><p>虽然在数学上，增量的类型没有影响，每个增量都会将最终得分增加一点，但对被计数的特征类别进行区分可以更容易地理解嵌套增量适用和不适用的地方。</p><p>这些规则及其背后的原则在以下章节中进一步详细介绍。</p><h2 class=heading-element id=忽略简写><span>5 忽略简写</span>
<a href=#%e5%bf%bd%e7%95%a5%e7%ae%80%e5%86%99 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在制定认知复杂度的过程中，一个指导原则是它应该激励良好的编码实践。也就是说，它应该忽略或减少使代码更易读的特性。</p><p>方法的结构本身就是一个很好的例子。将代码分解为方法可以将多个语句压缩为一个具有描述性名称的调用，即“简写（shorthand）”。因此，认知复杂度不会针对方法进行增量计算。</p><p>认知复杂度还忽略许多编程语言中常见的空合并运算符，因为它们允许将多行代码缩减为一行。例如，下面两个代码示例执行相同的操作：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696826535.png title="ignore shorthand" data-thumbnail=/posts/cognitive-complexity/images/23_1696826535.png data-sub-html="<h2>ignore shorthand</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696826535.png alt="ignore shorthand" height=176 width=1084></a></p><p>左侧版本的含义需要一些时间来理解，而一旦理解了空合并语法，右侧版本就立即清晰明了。因此，认知复杂度忽略了空合并运算符。</p><h2 class=heading-element id=中断线性流程><span>6 中断线性流程</span>
<a href=#%e4%b8%ad%e6%96%ad%e7%ba%bf%e6%80%a7%e6%b5%81%e7%a8%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>在制定认知复杂度的过程中，另一个指导原则是打破代码从上到下、从左到右的正常线性流程的结构会使维护者在理解代码时需要付出更多的努力。为了认可这种额外的努力，认知复杂度对以下结构进行结构增量评估：</p><ul><li>循环结构：<code>for</code>、<code>while</code>、<code>do while</code>、&mldr;</li><li>条件判断：三元运算符、<code>if</code>、<code>#if</code>、<code>#ifdef</code>、&mldr;</li></ul><p>它对混合增量进行评估：</p><ul><li><code>else if</code>、<code>elif</code>、<code>else</code>、&mldr;</li></ul><p>对于这些结构，不会评估嵌套增量，因为在阅读条件语句时已经承担了心理成本。</p><p>这些增量目标对于那些习惯于圈复杂度的人来说可能会很熟悉。此外，认知复杂度还会增加以下方面的复杂度：</p><h3 class=heading-element id=捕获catches><span>6.1 捕获（Catches）</span>
<a href=#%e6%8d%95%e8%8e%b7catches class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p><code>catch</code> 语句与 <code>if</code> 语句一样，代表了控制流程中的一种分支。因此，每个 <code>catch</code> 子句都会对认知复杂度进行结构增量评估。请注意，无论捕获了多少种异常类型，每个 <code>catch</code> 子句只会给认知复杂度得分增加一个点。<code>try</code> 和 <code>finally</code> 块则完全被忽略。</p><h3 class=heading-element id=开关switches><span>6.2 开关（Switches）</span>
<a href=#%e5%bc%80%e5%85%b3switches class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>一个 <code>switch</code> 语句及其所有的 <code>case</code> 合并会导致一个单独的结构增量。</p><p>在圈复杂度中，<code>switch</code> 语句被视为类似于 <code>if-else</code> <code>if</code> 链的模拟。也就是说，<code>switch</code> 语句中的每个 <code>case</code> 都会导致增量，因为它在控制流的数学模型中引起了一个分支。</p><p>但是从维护者的角度来看，一个 <code>switch</code> 语句，它将一个变量与一组明确命名的字面值进行比较，比一个 <code>if-else</code> <code>if</code> 链容易理解得多，因为后者可能进行任意数量的比较，使用任意数量的变量和值。</p><p>简而言之，必须仔细阅读 <code>if-else</code> <code>if</code> 链，而 <code>switch</code> 语句通常可以一目了然地理解。</p><h3 class=heading-element id=逻辑运算符序列sequences-of-logical-operators><span>6.3 逻辑运算符序列（Sequences of logical operators）</span>
<a href=#%e9%80%bb%e8%be%91%e8%bf%90%e7%ae%97%e7%ac%a6%e5%ba%8f%e5%88%97sequences-of-logical-operators class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>出于类似的原因，认知复杂度不会对每个二进制逻辑运算符进行增量计算。相反，它对每个二进制逻辑运算符序列进行基本增量评估。例如，考虑以下几对示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>a</span> <span class=o>&amp;&amp;</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>&amp;&amp;</span> <span class=nx>b</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span> <span class=o>&amp;&amp;</span> <span class=nx>d</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>||</span> <span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>||</span> <span class=nx>b</span> <span class=o>||</span> <span class=nx>c</span> <span class=o>||</span> <span class=nx>d</span></span></span></code></pre></td></tr></table></div></div><p>理解每对示例中的第二行并不比理解第一行困难太多。然而，对于理解下面两行的努力确实存在明显的差异：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>a</span> <span class=o>&amp;&amp;</span> <span class=nx>b</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span> <span class=o>&amp;&amp;</span> <span class=nx>d</span>
</span></span><span class=line><span class=cl><span class=nx>a</span> <span class=o>||</span> <span class=nx>b</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span> <span class=o>||</span> <span class=nx>d</span></span></span></code></pre></td></tr></table></div></div><p>因为混合运算符的布尔表达式变得更难理解，所以认知复杂度会对每个新的相同运算符序列进行增量计算。例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>a</span>                   <span class=c1>// +1 for `if`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>&amp;&amp;</span> <span class=nx>b</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span>             <span class=c1>// +1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>||</span> <span class=nx>d</span> <span class=o>||</span> <span class=nx>e</span>             <span class=c1>// +1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>&amp;&amp;</span> <span class=nx>f</span><span class=p>)</span>                 <span class=c1>// +1
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nx>a</span>                   <span class=c1>// +1 for `if`
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>&amp;&amp;</span>                    <span class=c1>// +1
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=o>!</span><span class=p>(</span><span class=nx>b</span> <span class=o>&amp;&amp;</span> <span class=nx>c</span><span class=p>))</span>            <span class=c1>// +1
</span></span></span></code></pre></td></tr></table></div></div><p>虽然相对于圈复杂度，认知复杂度对相同的运算符提供了一种“折扣”，但它会对所有的二元布尔运算符序列进行增量计算，例如变量赋值、方法调用和返回语句中的序列。</p><h3 class=heading-element id=递归recursion><span>6.4 递归（Recursion）</span>
<a href=#%e9%80%92%e5%bd%92recursion class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>与圈复杂度不同，认知复杂度对递归循环中的每个方法（无论是直接递归还是间接递归）都会增加一个基本增量。</p><p>这个决定有两个动机。首先，递归代表了一种“元循环（meta-loop）”，而认知复杂度对循环进行增量计算。其次，认知复杂度旨在估计理解方法控制流的相对难度，即使对一些经验丰富的程序员来说，递归也很难理解。</p><h3 class=heading-element id=跳转到标签jumps-to-labels><span>6.5 跳转到标签（Jumps to labels）</span>
<a href=#%e8%b7%b3%e8%bd%ac%e5%88%b0%e6%a0%87%e7%ad%bejumps-to-labels class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>使用 <code>goto</code> 语句会给认知复杂度增加一个基本增量，同样的，使用带有标签的 <code>break</code> 或 <code>continue</code> 语句以及其他多级跳转（如某些语言中的带有数字的 <code>break</code> 或 <code>continue</code> 语句）也会增加增量。但是，因为提前返回通常可以使代码更清晰，其他跳转或提前退出不会增加增量。</p><h2 class=heading-element id=嵌套流程中的增量><span>7 嵌套流程中的增量</span>
<a href=#%e5%b5%8c%e5%a5%97%e6%b5%81%e7%a8%8b%e4%b8%ad%e7%9a%84%e5%a2%9e%e9%87%8f class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>直观上很明显，一系列线性的五个 <code>if</code> 和 <code>for</code> 结构比相同的五个结构连续嵌套更容易理解，而不管每个系列中的执行路径数量如何。因为这样的嵌套增加了理解代码的心理需求，认知复杂度对其进行了嵌套增量的评估。</p><p>具体来说，每当一个导致结构增量或混合增量的结构嵌套在另一个这样的结构内部时，每个嵌套级别都会增加一个嵌套增量。例如，在下面的示例中，对于方法本身或 <code>try</code> 语句，都没有嵌套增量，因为这两个结构都不会导致结构增量或混合增量：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696904025.png title="Illustration 1 of “Increment for nested flow-break structures”" data-thumbnail=/posts/cognitive-complexity/images/23_1696904025.png data-sub-html="<h2>Illustration 1 of “Increment for nested flow-break structures”</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696904025.png alt="Illustration 1 of “Increment for nested flow-break structures”" height=456 width=1366></a></p><p>然而，<code>if</code>、<code>for</code>、<code>while</code>和<code>catch</code>结构都会受到结构增量和嵌套增量的影响。
此外，顶层方法会被忽略，并且 <code>lambda</code> 表达式、嵌套方法和类似特性不会导致结构增量，但当这些方法嵌套在其他类似方法的结构内部时，会增加嵌套级别：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696904298.png title="Illustration 2 of “Increment for nested flow-break structures”" data-thumbnail=/posts/cognitive-complexity/images/23_1696904298.png data-sub-html="<h2>Illustration 2 of “Increment for nested flow-break structures”</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696904298.png alt="Illustration 2 of “Increment for nested flow-break structures”" height=594 width=1368></a></p><h2 class=heading-element id=影响><span>8 影响</span>
<a href=#%e5%bd%b1%e5%93%8d class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>认知复杂度的主要目标是计算方法分数，以更准确地反映方法的相对可理解性，并且其次目标是处理现代语言结构并生成在方法级别以上有价值的度量标准。可以证明，处理现代语言结构的目标已经实现。下面将对另外两个目标进行详细讨论。</p><h3 class=heading-element id=直观地正确的复杂性分数><span>8.1 直观地“正确”的复杂性分数</span>
<a href=#%e7%9b%b4%e8%a7%82%e5%9c%b0%e6%ad%a3%e7%a1%ae%e7%9a%84%e5%a4%8d%e6%9d%82%e6%80%a7%e5%88%86%e6%95%b0 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>这次讨论始于一对具有相等圈复杂度但明显不同可理解性的方法。现在是重新审视这些方法并计算它们的认知复杂度分数的时候了。</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696904888.png title="Intuitively ‘right’ complexity scores" data-thumbnail=/posts/cognitive-complexity/images/23_1696904888.png data-sub-html="<h2>Intuitively ‘right’ complexity scores</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696904888.png alt="Intuitively ‘right’ complexity scores" height=534 width=1734></a></p><p>认知复杂度算法给出了这两个方法明显不同的分数，这些分数更能反映它们相对可理解性的差异。</p><h3 class=heading-element id=高于方法级别的有价值的指标><span>8.2 高于方法级别的有价值的指标</span>
<a href=#%e9%ab%98%e4%ba%8e%e6%96%b9%e6%b3%95%e7%ba%a7%e5%88%ab%e7%9a%84%e6%9c%89%e4%bb%b7%e5%80%bc%e7%9a%84%e6%8c%87%e6%a0%87 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>此外，由于认知复杂度不会针对方法结构增加增量，聚合的数值变得有用起来。现在，通过比较它们的度量值，你可以轻松区分一个包含大量简单的 <code>getter</code> 和 <code>setter</code> 的领域类和一个包含复杂控制流的类。因此，认知复杂度成为衡量类和应用程序相对可理解性的工具。</p><h2 class=heading-element id=结论><span>9 结论</span>
<a href=#%e7%bb%93%e8%ae%ba class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>编写和维护代码是人类过程，它们的输出必须符合数学模型，但它们本身并不适合数学模型。这就是为什么数学模型不足以评估它们所需努力的原因。</p><p>认知复杂度打破了使用数学模型评估软件可维护性的做法。它起源于圈复杂度所设定的先例，但使用人类判断来评估应该如何计算结构，并决定整体模型应该加入什么内容。结果，它产生了方法复杂度分数，相对于以前的模型，程序员认为这些分数更公平地评估了可理解性。</p><p>此外，因为认知复杂度对于一个方法没有“进入成本”的要求，它不仅在方法级别产生了这些更公平的相对评估，还在类和应用程序级别上产生了相应的评估。</p><h2 class=heading-element id=参考文献><span>10 参考文献</span>
<a href=#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>本文翻译自 G. Ann Campbell 的文章“{Cognitive Complexity} a new way of measuring understandability”<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>，原文发表于 2023 年 8 月 29 日，版本号为 1.7。</p><h2 class=heading-element id=附录-a补偿用法><span>11 附录 A：补偿用法</span>
<a href=#%e9%99%84%e5%bd%95-a%e8%a1%a5%e5%81%bf%e7%94%a8%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>认知复杂度被设计为一种与语言无关的度量标准，但不可忽视的是不同的编程语言提供了不同的特性。例如，COBOL 中没有 <code>else if</code> 结构，而 JavaScript 直到最近也缺乏类似的结构。不幸的是，这些缺陷并不能阻止开发人员需要这些结构或者试图用手头的工具构建类似的结构。在这种情况下，严格遵守认知复杂度规则会导致不成比例的高分。</p><p>因此，为了不惩罚一种语言相对于另一种语言的使用，对于语言的缺陷，即在考虑的语言中普遍使用并且在大多数现代语言中都是期望的结构，但在该语言中缺失的结构（例如 COBOL 缺少的 <code>else if</code>），可以进行例外处理。</p><p>另一方面，当一种语言创新引入一个特性时，例如 Java 7 可以一次捕获多个异常类型，其他语言中缺乏这种创新不应被视为缺陷，因此不应有例外。</p><p>这意味着如果一次捕获多个异常类型成为一种常见预期的语言特性，那么对于不提供该功能的语言中的“额外”<code>catch</code> 子句可能会添加例外。这种可能性并没有排除，但对于是否添加这样的未来例外的评估应该以保守为原则。换句话说，新的例外应该慢慢引入。</p><p>另一方面，如果 COBOL 标准的未来版本添加了"else if"结构，应尽快放弃 COBOL 的"else &mldr; if"例外（如下所述）。</p><p>到目前为止，已经确定了三个例外情况：</p><h3 class=heading-element id=cobol-missing-else-if><span>11.1 COBOL: Missing <code>else if</code></span>
<a href=#cobol-missing-else-if class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>对于缺乏 <code>else if</code> 结构的 COBOL 语言，一个 <code>else</code> 子句中如果只包含一个 <code>if</code> 语句，则不会增加嵌套惩罚。此外，<code>else</code> 本身不会增加复杂度。也就是说，如果 <code>else</code> 后面紧跟着 <code>if</code> 语句，尽管从语法上讲它并不是 <code>else if</code>，但在计算复杂度时会视作 <code>else if</code>。</p><p>例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-COBOL data-lang=COBOL><span class=line><span class=cl><span class=c>IF con</span><span class=nv>dition1</span>        <span class=o>//</span> <span class=o>+</span><span class=mi>1 </span><span class=nv>structure</span><span class=p>,</span> <span class=o>+</span><span class=mi>0 </span><span class=kp>for</span> <span class=nv>nesting</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>  <span class=p>...</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=kr>ELSE
</span></span></span><span class=line><span class=cl><span class=kr> </span> <span class=kr>IF</span> <span class=nv>condition2</span>      <span class=o>//</span> <span class=o>+</span><span class=mi>1 </span><span class=nv>structure</span><span class=p>,</span> <span class=o>+</span><span class=mi>0 </span><span class=kp>for</span> <span class=nv>nesting</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>    ..</span><span class=p>.</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>  ELSE</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>    IF</span> <span class=nv>condition3</span>    <span class=o>//</span> <span class=o>+</span><span class=mi>1 </span><span class=nv>structure</span><span class=p>,</span> <span class=o>+</span><span class=mi>0 </span><span class=kp>for</span> <span class=nv>nesting</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>      </span><span class=nv>statement1</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>      </span><span class=kr>IF</span> <span class=nv>condition4</span>  <span class=o>//</span> <span class=o>+</span><span class=mi>1 </span><span class=nv>structure</span><span class=p>,</span> <span class=o>+</span><span class=mi>1 </span><span class=kp>for</span> <span class=nv>nesting</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>      </span>  <span class=p>...</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>      </span><span class=kr>END-IF
</span></span></span><span class=line><span class=cl><span class=kr>   </span> <span class=kr>END-IF
</span></span></span><span class=line><span class=cl><span class=kr> </span> <span class=nv>ENDIF</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c>ENDIF.</span></span></span></code></pre></td></tr></table></div></div><h3 class=heading-element id=javascript-missing-class-structures><span>11.2 JavaScript: Missing class structures</span>
<a href=#javascript-missing-class-structures class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>尽管 ECMAScript 6 规范最近为 JavaScript 添加了类的功能，但这个特性尚未被广泛采用。实际上，许多流行的框架要求继续使用一种补偿习惯用法：使用外部函数作为替代，创建一种命名空间或伪类。为了不对 JavaScript 用户进行惩罚，当外部函数仅用作声明机制时（即它们只包含顶级的声明），它们将被忽略。</p><p>然而，如果一个函数位于顶级（即不嵌套在子函数内部），并且包含需要进行结构增加的语句，那么说明它不仅仅是纯粹的声明使用。因此，这类函数应该接受标准处理。</p><p>例如：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696907520.png title="ES5 class" data-thumbnail=/posts/cognitive-complexity/images/23_1696907520.png data-sub-html="<h2>ES5 class</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696907520.png alt="ES5 class" height=968 width=1368></a></p><h3 class=heading-element id=python-decorators><span>11.3 Python: Decorators</span>
<a href=#python-decorators class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>Python 的装饰器习惯用法允许在不修改函数本身的情况下向现有函数添加额外的行为。这是通过在装饰器中使用嵌套函数来实现的，嵌套函数提供了额外的行为。</p><p>为了不对使用其语言的 Python 开发人员进行惩罚，已经添加了一个例外。然而，已经试图对例外进行明确定义。具体来说，要符合例外的条件，一个函数只能包含一个嵌套函数和一个 <code>return</code> 语句。</p><p>例如：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696907633.png title="Python decorator" data-thumbnail=/posts/cognitive-complexity/images/23_1696907633.png data-sub-html="<h2>Python decorator</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696907633.png alt="Python decorator" height=948 width=1368></a></p><h2 class=heading-element id=附录-b规范><span>12 附录 B：规范</span>
<a href=#%e9%99%84%e5%bd%95-b%e8%a7%84%e8%8c%83 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>本节的目的是对增加认知复杂度的结构和情况进行简明列举，但需考虑 <strong>附录 A</strong> 中列出的例外情况。这旨在提供一个全面的列表，但并非穷尽所有编程语言。也就是说，如果某种语言对关键字有非典型的拼写，例如用 <code>elif</code> 表示 <code>else if</code>，那么在此处的省略并不意味着在规范中忽略该结构。</p><h3 class=heading-element id=b1-增量increments><span>12.1 B1. 增量（Increments）</span>
<a href=#b1-%e5%a2%9e%e9%87%8fincrements class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>对于以下每个结构，都会增加复杂度的计数：</p><ul><li><code>if</code>、<code>else if</code>、<code>else</code> 条件语句和三元运算符</li><li><code>switch</code></li><li><code>for</code>、<code>foreach</code></li><li><code>while</code>、<code>do while</code></li><li><code>catch</code></li><li><code>goto LABEL</code>、<code>break LABEL</code>、<code>continue LABEL</code>、<code>break NUMBER</code>、<code>continue NUMBER</code></li><li>连续的二元逻辑运算符</li><li>递归循环中的每个方法</li></ul><h3 class=heading-element id=b2-嵌套级别nesting-level><span>12.2 B2. 嵌套级别（Nesting level）</span>
<a href=#b2-%e5%b5%8c%e5%a5%97%e7%ba%a7%e5%88%abnesting-level class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>以下结构会增加嵌套层级的计数：</p><ul><li><code>if</code>、<code>else if</code>、<code>else</code> 条件语句和三元运算符</li><li><code>switch</code></li><li><code>for</code>、<code>foreach</code></li><li><code>while</code>、<code>do while</code></li><li><code>catch</code></li><li>嵌套方法和类似方法的结构，如 <code>lambda</code> 表达式。</li></ul><h3 class=heading-element id=b3-嵌套增量nesting-increments><span>12.3 B3. 嵌套增量（Nesting increments）</span>
<a href=#b3-%e5%b5%8c%e5%a5%97%e5%a2%9e%e9%87%8fnesting-increments class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h3><p>以下结构将根据其在 B2 结构内的嵌套深度而增加相应的嵌套层级计数：</p><ul><li><code>if</code> 条件语句和三元运算符</li><li><code>switch</code></li><li><code>for</code>、<code>foreach</code></li><li><code>while</code>、<code>do while</code></li><li><code>catch</code></li></ul><h2 class=heading-element id=附录-c示例><span>13 附录 C：示例</span>
<a href=#%e9%99%84%e5%bd%95-c%e7%a4%ba%e4%be%8b class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><blockquote><p><strong>Note</strong>
译者注：在各大 IDE 中可以安装 SonarLint 插件，以便在编码过程中实时检查代码质量，<a href="https://www.sonarsource.com/products/sonarlint/?gads_campaign=SL-Class02-Brand&amp;gads_ad_group=SonarLint&amp;gads_keyword=sonarlint&amp;gclid=CjwKCAjwyY6pBhA9EiwAMzmfwba_MRBC_UXg_im757z_Om_T6Jfd_vt_gVuNL-Wxh9S0HVKKqK7nRhoCl5UQAvD_BwE" target=_blank rel="external nofollow noopener noreferrer">详见<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a></p></blockquote><p>来自 SonarJava 分析器中的 <code>org.sonar.java.resolve.JavaSymbol.java</code>：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696908636.png title=org.sonar.java.resolve.JavaSymbol.java data-thumbnail=/posts/cognitive-complexity/images/23_1696908636.png data-sub-html="<h2>org.sonar.java.resolve.JavaSymbol.java</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696908636.png alt=org.sonar.java.resolve.JavaSymbol.java height=1094 width=1378></a></p><p>来自 sonar-persistit 中的 <code>com.persistit.TimelyResource.java</code>：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696908742.png title=com.persistit.TimelyResource.java data-thumbnail=/posts/cognitive-complexity/images/23_1696908742.png data-sub-html="<h2>com.persistit.TimelyResource.java</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696908742.png alt=com.persistit.TimelyResource.java height=1540 width=1354></a></p><p>来自 SonarQube 中的 <code>org.sonar.api.utils.WildcardPattern.java</code>：</p><p>来自 YUI 中的 <code>model.js</code>：</p><p><a class=lightgallery href=/posts/cognitive-complexity/images/23_1696908890.png title=model.js data-thumbnail=/posts/cognitive-complexity/images/23_1696908890.png data-sub-html="<h2>model.js</h2>"><img loading=lazy src=/posts/cognitive-complexity/images/23_1696908890.png alt=model.js height=1532 width=1166></a></p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>Thomas J. McCabe, &ldquo;A Complexity Measure&rdquo;, IEEE Transactions on Software Engineering, Vol. SE-2, No. 4, December 1976&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>G. Ann Campbell, &ldquo;<a href=https://www.sonarsource.com/docs/CognitiveComplexity.pdf target=_blank rel="external nofollow noopener noreferrer">Cognitive Complexity - a new way of measuring understandability<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>&rdquo;, <a href=https://www.sonarsource.com/ target=_blank rel="external nofollow noopener noreferrer">Sonar<i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden=true></i></a>, 29 August 2023, Version 1.7&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-reward><div class=comment>Buy me a coffee~</div><input type=checkbox class=reward-input name=reward id=fi-reward hidden>
<label class=reward-button for=fi-reward><i class="fa-solid fa-qrcode fa-fw" aria-hidden=true></i>赞赏</label><div class=reward-ways data-mode=fixed><div><img src=/images/alipay.jpg alt="Lruihao 支付宝"><span data-animation>支付宝</span></div><div><img src=/images/wechatpay.jpg alt="Lruihao 微信"><span data-animation>微信</span></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-11-17 20:39:48">更新于 2023-11-17&nbsp;<a class=git-hash href=https://github.com/Lruihao/hugo-blog/commit/b034df8bf933c0c3253d4950797da157bfed5ce9 rel="external nofollow noopener noreferrer" target=_blank title="Docs: 整理系统文件夹分类&#10_ 开头的为物理分类，和 Hugo 的文件夹区分开来&#10Commit: b034df8bf933c0c3253d4950797da157bfed5ce9 [b034df8]&#10Author: Cell<1024@lruihao.cn>&#10Date: 2023-11-17 20:39:48"><i class="fa-solid fa-hashtag fa-fw" aria-hidden=true></i>b034df8</a></span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a href=/posts/cognitive-complexity/index.md title=阅读原始文档 class=link-to-markdown>阅读原始文档</a></span><span><a href="https://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_spec/cognitive-complexity/index.md?plain=1" title=查看源码 target=_blank rel="external nofollow noopener noreferrer" class=link-to-source>查看源码</a></span><span><a href=https://github.com/Lruihao/hugo-blog/edit/docs/content/posts/_spec/cognitive-complexity/index.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span><span><a href="https://github.com/Lruihao/hugo-blog/issues/new?title=[BUG]%20%E8%AE%A4%E7%9F%A5%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88Cognitive+Complexity%EF%BC%89&amp;body=%7cField%7cValue%7c%0A%7c-%7c-%7c%0A%7cTitle%7c%E8%AE%A4%E7%9F%A5%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%88Cognitive+Complexity%EF%BC%89%7c%0A%7cURL%7chttps://lruihao.cn/posts/cognitive-complexity/%7c%0A%7cFilename%7chttps://github.com/Lruihao/hugo-blog/blob/docs/content/posts/_spec/cognitive-complexity/index.md?plain=1%7c" title=报告问题 target=_blank rel="external nofollow noopener noreferrer" class=link-to-report>报告问题</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 X" data-sharer=twitter data-url=https://lruihao.cn/posts/cognitive-complexity/ data-title="认知复杂度（Cognitive Complexity）"><i class="fa-brands fa-x-twitter fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://lruihao.cn/posts/cognitive-complexity/><i class="fa-brands fa-facebook-square fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 Linkedin" data-sharer=linkedin data-url=https://lruihao.cn/posts/cognitive-complexity/><i class="fa-brands fa-linkedin fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://lruihao.cn/posts/cognitive-complexity/ data-title="认知复杂度（Cognitive Complexity）" data-ralateuid=liahao><i class="fa-brands fa-weibo fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); title="分享到 百度" data-sharer=baidu data-url=https://lruihao.cn/posts/cognitive-complexity/ data-title="认知复杂度（Cognitive Complexity）"><i data-svg-src=https://unpkg.com/simple-icons@9.19.0/icons/baidu.svg aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/article-structure/ class=post-nav-item rel=prev title=写作技巧：如何搭建文章的框架结构？><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>写作技巧：如何搭建文章的框架结构？</a><a href=/posts/markdownlint/ class=post-nav-item rel=next title="给你的 Markdown 挑挑刺">给你的 Markdown 挑挑刺<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div><div class=post-footer__after><div class="d-none-desktop text-center"><img src=/images/wxmp.webp alt=微信公众号 width=70%></div></div><div id=comments><div id=giscus class=comment><script src=https://giscus.app/client.js data-repo=Lruihao/hugo-blog data-repo-id="MDEwOlJlcG9zaXRvcnk0MDQzNDY3MDk=" data-category=General data-category-id=DIC_kwDOGBnXVc4CApHL data-mapping=title data-strict=0 data-theme=preferred_color_scheme data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-lang=zh-CN data-loading=lazy crossorigin=anonymous async defer></script></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://giscus.app/ rel="external nofollow noopener noreferrer">giscus</a>.</noscript></div></article><aside class=toc id=toc-auto aria-label=目录><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class=toc-content id=toc-content-auto></div></aside><dialog id=toc-dialog aria-labelledby=toc-dialog-title role=dialog><div class=toc><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-drawer><nav><ol><li><a href=#摘要>摘要</a><ol><li><a href=#术语说明>术语说明</a></li></ol></li><li><a href=#引言>引言</a></li><li><a href=#问题示例>问题示例</a></li><li><a href=#基本准则和方法>基本准则和方法</a></li><li><a href=#忽略简写>忽略简写</a></li><li><a href=#中断线性流程>中断线性流程</a><ol><li><a href=#捕获catches>捕获（Catches）</a></li><li><a href=#开关switches>开关（Switches）</a></li><li><a href=#逻辑运算符序列sequences-of-logical-operators>逻辑运算符序列（Sequences of logical operators）</a></li><li><a href=#递归recursion>递归（Recursion）</a></li><li><a href=#跳转到标签jumps-to-labels>跳转到标签（Jumps to labels）</a></li></ol></li><li><a href=#嵌套流程中的增量>嵌套流程中的增量</a></li><li><a href=#影响>影响</a><ol><li><a href=#直观地正确的复杂性分数>直观地“正确”的复杂性分数</a></li><li><a href=#高于方法级别的有价值的指标>高于方法级别的有价值的指标</a></li></ol></li><li><a href=#结论>结论</a></li><li><a href=#参考文献>参考文献</a></li><li><a href=#附录-a补偿用法>附录 A：补偿用法</a><ol><li><a href=#cobol-missing-else-if>COBOL: Missing <code>else if</code></a></li><li><a href=#javascript-missing-class-structures>JavaScript: Missing class structures</a></li><li><a href=#python-decorators>Python: Decorators</a></li></ol></li><li><a href=#附录-b规范>附录 B：规范</a><ol><li><a href=#b1-增量increments>B1. 增量（Increments）</a></li><li><a href=#b2-嵌套级别nesting-level>B2. 嵌套级别（Nesting level）</a></li><li><a href=#b3-嵌套增量nesting-increments>B3. 嵌套增量（Nesting increments）</a></li></ol></li><li><a href=#附录-c示例>附录 C：示例</a></li></ol></nav></div></div></dialog></main><footer class=footer><div class=footer-container><div class="footer-line powered order-1">由 <a href=https://gohugo.io/ target=_blank rel="external nofollow noopener noreferrer" title="Hugo 0.152.2"><img class=hugo-icon src=/images/hugo.min.svg alt="Hugo logo"> Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/hugo-fixit/FixIt target=_blank rel=external title="FixIt v0.4.0-alpha.3-20251119085609-237c2f3d"><img class=fixit-icon src=/images/fixit.min.svg alt="FixIt logo"> FixIt</a></div><div class="footer-line copyright order-2" itemscope itemtype=http://schema.org/CreativeWork><i class="fa-regular fa-copyright fa-fw" aria-hidden=true></i>
<span itemprop=copyrightYear>2018 - 2025</span><span class=author itemprop=copyrightHolder>
<a href=https://github.com/Lruihao target=_blank rel="external nofollow noopener noreferrer">Lruihao</a></span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc-sa/4.0/ target=_blank>CC BY-NC-SA 4.0</a></span></div><div class="footer-line statistics order-3"><span class=site-time title=网站运行中……><i class="fa-solid fa-heartbeat fa-fw animate-icon" aria-hidden=true></i><span class="ms-1 d-none">博客已运行</span><span class="run-times ms-1">网站运行中……</span></span></div><div class="footer-line visitor order-4"><span id=busuanzi_container_site_uv title=总访客数><i class="fa-regular fa-user fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_uv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span><span id=busuanzi_container_site_pv class=footer-divider title=总访问量><i class="fa-regular fa-eye fa-fw me-1" aria-hidden=true></i><span id=busuanzi_value_site_pv><i class="fa-solid fa-spinner fa-spin fa-fw" aria-hidden=true></i></span></span></div></div></footer></div><div class=widgets><div class=fixed-buttons><div class="fixed-button back-to-top animate__faster d-none" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><svg viewBox="0 0 100 100"><circle class="bg" cx="50" cy="50" r="50"/><circle class="progress" cx="50" cy="50" r="50"/></svg></div><div id=toc-drawer-button class="fixed-button toc-drawer-button d-none" role=button aria-label=目录><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></div><div class="fixed-button view-comments d-none" role=button aria-label=查看评论><i class="fa-solid fa-comment fa-fw" aria-hidden=true></i></div></div><a href=https://github.com/Lruihao/hugo-blog title="在 GitHub 上查看源码，订阅请点 Watch~" target=_blank rel="external nofollow" class="github-corner right d-none-mobile"><svg viewBox="0 0 250 250" aria-hidden="true" width="56" height="56"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentColor" class="octo-body"/></svg></a><div id=mask></div><div class=reading-progress-bar style=left:0;top:0;--bg-progress:#8581dd;--bg-progress-dark:#fff></div><noscript><div class=noscript-warning>该网站在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=https://unpkg.com/lightgallery@2.7.2/css/lightgallery-bundle.min.css><link rel=stylesheet href=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.css><link rel=stylesheet href=https://unpkg.com/pace-js@1.2.4/themes/blue/pace-theme-minimal.css><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.js?features=Array.prototype.fill%2CArray.prototype.find%2CArray.from%2CIntersectionObserver%2CMath.sign%2CObject.assign%2CPromise%2CObject.entries%2Chtml5shiv%2CObject.values%2Cfetch%2CElement.prototype.after"></script><script src=https://unpkg.com/autocomplete.js@0.38.1/dist/autocomplete.min.js defer></script><script src=https://unpkg.com/algoliasearch@4.20.0/dist/algoliasearch-lite.umd.js defer></script><script src=https://unpkg.com/instant.page@5.2.0/instantpage.js async defer type=module></script><script src=https://unpkg.com/lightgallery@2.7.2/lightgallery.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=https://unpkg.com/lightgallery@2.7.2/plugins/zoom/lg-zoom.min.js defer></script><script src=https://unpkg.com/sharer.js@0.5.1/sharer.min.js async defer></script><script src=https://unpkg.com/cookieconsent@3.1.1/build/cookieconsent.min.js defer></script><script src=https://unpkg.com/pangu@4.0.7/dist/browser/pangu.min.js defer></script><script src=https://unpkg.com/cell-watermark@1.0.3/src/watermark.min.js defer></script><script src=https://vercount.one/js async defer></script><script src=https://unpkg.com/pace-js@1.2.4/pace.min.js async defer></script><script src=/posts/cognitive-complexity/config/post-chat.js defer></script><script src=https://ai.zhheo.com/static/public/postChatUser.min.js defer data-postchat_key=ed872bf9336506bea545183089f5034f81fea6af></script><script src=/posts/cognitive-complexity/config/page.js defer></script><script src=/js/theme.min.js defer></script><script src=/js/flyfish.min.js defer></script><script src=/lib/translate.min.js defer></script><script>window.ATConfig={hugoLangCodes:["zh-CN"],hugoLangMap:{"zh-CN":"/posts/cognitive-complexity/"}}</script><script src=/js/translate.fixit.min.js defer></script><script src=/js/custom.min.js defer></script><script async defer data-website-id=4049c0b0-87c9-4573-8ae5-d84449e40e05 src=https://cloud.umami.is/script.js></script></body></html>