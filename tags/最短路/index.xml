<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最短路 - 标签 | 菠菜眾長</title><link>https://lruihao.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/</link><description>Hugo FixIt 作者，喜欢瞎折腾、造轮子、写东西，分享一些前端开发中的所见、所闻、所思。</description><generator>Hugo 0.153.5 &amp; FixIt v0.4.0-alpha.3-20251230083959-721c9d9b</generator><language>zh-CN</language><managingEditor>1024@lruihao.cn (Lruihao)</managingEditor><webMaster>1024@lruihao.cn (Lruihao)</webMaster><copyright>本站内容采用 CC BY-NC-SA 4.0 国际许可协议。</copyright><lastBuildDate>Thu, 30 Nov 2023 23:35:38 +0800</lastBuildDate><atom:link href="https://lruihao.cn/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/index.xml" rel="self" type="application/rss+xml"/><item><title>Heavy Transportation-poj1797(dijkstra 或最大生成树）</title><link>https://lruihao.cn/posts/poj1797/</link><pubDate>Mon, 06 Aug 2018 09:42:11 +0800</pubDate><author>1024@lruihao.cn (Lruihao)</author><guid>https://lruihao.cn/posts/poj1797/</guid><category domain="https://lruihao.cn/categories/acm/">ACM</category><description>&lt;p&gt;&lt;a href="http://poj.org/problem?id=1797" target="_blank" rel="external nofollow noopener noreferrer"&gt;题目链接&lt;i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大意：&lt;br&gt;
要从城市 1 到城市 N 运送货物，有 M 条道路，每条道路都有它的最大载重量，问从城市 1 到城市 N 运送最多的重量是多少。&lt;br&gt;
其实题意很简单，就是找一条 1&amp;ndash;&amp;gt;N 的路径，在不超过每条路径的最大载重量的情况下，使得运送的货物最多。一条路径上的最大载重量为这个路径上权值最小的边；
&lt;a class="lightgallery" target="_blank" href="images/update.jpg" title="更新" data-thumbnail="images/update.jpg" data-sub-html="&lt;h2&gt;更新&lt;/h2&gt;"&gt;&lt;img loading="lazy" src='images/update.jpg' alt="更新"&gt;&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Til the Cows Come Home-poj2387(dijkstra 判断重边）</title><link>https://lruihao.cn/posts/poj2387/</link><pubDate>Fri, 03 Aug 2018 21:40:33 +0800</pubDate><author>1024@lruihao.cn (Lruihao)</author><guid>https://lruihao.cn/posts/poj2387/</guid><category domain="https://lruihao.cn/categories/acm/">ACM</category><description>&lt;p&gt;&lt;a href="http://poj.org/problem?id=2387" target="_blank" rel="external nofollow noopener noreferrer"&gt;题目链接&lt;i class="fa-solid fa-external-link-alt fa-fw fa-xs ms-1 text-secondary" aria-hidden="true"&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目大意：&lt;br&gt;
说的是，一只奶牛位于 N 号节点，输入 N 个节点和 T 对双向的边，求出由 N 到 1 的最短的距离，其实就是问的单源最短路问题。&lt;/p&gt;
&lt;p&gt;两个点可能有多条路，选择最短的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;
#include&amp;lt;string.h&amp;gt;
#include&amp;lt;algorithm&amp;gt;
using namespace std;

const int INF=99999999; //设为无穷大
int maps[1005][1005],v[1005],d[1005]; //v 表示是否已经过遍历 d 表示从源到点当前最短路
int n;

void Dijkstra(int s,int t)
{
 int i,j,k,mini;
 for(i=1;i&amp;lt;=n;i&amp;#43;&amp;#43;)
 d[i]=INF; //除源点设为 0 距离外 其他先设为无穷大
 d[s]=0;
 for(i=1;i&amp;lt;=n;i&amp;#43;&amp;#43;) //n 点循环 n 次 , 找出 n 个 k, 找 n 个点
 {
 mini=INF;
 k=-1;
 for(j=1;j&amp;lt;=n;j&amp;#43;&amp;#43;) //在所有未标记点中 选 d 值最小的点
 if(!v[j] &amp;amp;&amp;amp; d[j]&amp;lt;mini)
 mini=d[k=j];

 v[k]=1; //标记节点
 if(k==t)
 {
 printf(&amp;#34;%d\n&amp;#34;,d[t]);
 return;
 }
 for(j=1;j&amp;lt;=n;j&amp;#43;&amp;#43;)
 if(!v[j] &amp;amp;&amp;amp; (d[k]&amp;#43;maps[k][j])&amp;lt;d[j]) //表示从 k 出发的点，对于所有边，更新相连点
 d[j]=d[k]&amp;#43;maps[k][j];
 }
}

int main()
{
 int T,i,j,x,y,D;
 while(scanf(&amp;#34;%d %d&amp;#34;,&amp;amp;T,&amp;amp;n)!=EOF)
 {
 memset(v,0,sizeof(v)); //清除标记
 for(i=1;i&amp;lt;=n;i&amp;#43;&amp;#43;)
 for(j=1;j&amp;lt;=n;j&amp;#43;&amp;#43;)
 maps[i][j]=INF;

 for(i=1;i&amp;lt;=T;i&amp;#43;&amp;#43;){
 scanf(&amp;#34;%d%d%d&amp;#34;,&amp;amp;x,&amp;amp;y,&amp;amp;D);
 if(maps[x][y]&amp;gt;D) //可能有多条路，只记录最短的
 maps[x][y]=D,maps[y][x]=D;
 }
 Dijkstra(1,n);
 }
 return 0;
}&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>最短路入门</title><link>https://lruihao.cn/posts/zuiduanlu/</link><pubDate>Fri, 03 Aug 2018 16:27:16 +0800</pubDate><author>1024@lruihao.cn (Lruihao)</author><guid>https://lruihao.cn/posts/zuiduanlu/</guid><category domain="https://lruihao.cn/categories/acm/">ACM</category><description>&lt;!-- markdownlint-disable MD033 --&gt;
&lt;h2 class="heading-element" id="dijkstra-算法"&gt;&lt;span&gt;1 Dijkstra 算法&lt;/span&gt;
 &lt;a href="#dijkstra-%e7%ae%97%e6%b3%95" class="heading-mark"&gt;
 &lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"&gt;&lt;/path&gt;&lt;/svg&gt;
 &lt;/a&gt;
&lt;/h2&gt;&lt;h3 class="heading-element" id="1-定义概览"&gt;&lt;span&gt;1.1 1. 定义概览&lt;/span&gt;
 &lt;a href="#1-%e5%ae%9a%e4%b9%89%e6%a6%82%e8%a7%88" class="heading-mark"&gt;
 &lt;svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"&gt;&lt;path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"&gt;&lt;/path&gt;&lt;/svg&gt;
 &lt;/a&gt;
&lt;/h3&gt;&lt;p&gt;Dijkstra（迪杰斯特拉）算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra 算法是很有代表性的最短路径算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。注意该算法要求图中不存在负权边。&lt;/p&gt;</description></item></channel></rss>